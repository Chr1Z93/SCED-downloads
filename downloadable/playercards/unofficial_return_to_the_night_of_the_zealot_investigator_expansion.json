{
  "ColorDiffuse": {
    "b": 1.0,
    "g": 1.0,
    "r": 1.0
  },
  "ContainedObjects": [
    {
      "ColorDiffuse": {
        "b": 1.0,
        "g": 1.0,
        "r": 1.0
      },
      "ContainedObjects": [
        {
          "CardID": 806100,
          "CustomDeck": {
            "8061": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415029/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/001.RolandBanks_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415025/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/001.RolandBanks_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "The Fed",
          "GMNotes": "{\n  \"id\": \"d545b38e-f3cf-486a-a026-12ed94b33453\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Agency. Detective.\",\n  \"class\": \"Guardian\",\n  \"willpowerIcons\": 3,\n  \"intellectIcons\": 3,\n  \"combatIcons\": 4,\n  \"agilityIcons\": 2,\n  \"extraToken\": \"Reaction\",\n  \"signatures\": [\n    {\n      \"43433775-620b-4e10-8583-253eb3f3e6c2\": 1,\n      \"3497e84b-9698-4d54-937c-65096eb6c82c\": 1\n    }\n  ]\n}",
          "GUID": "4cccd2",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…Roland Banks",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 157200,
          "CustomDeck": {
            "1572": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415036/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/002.Rolands38Special_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"43433775-620b-4e10-8583-253eb3f3e6c2\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Roland's .38 Special\",\n  \"traits\": \"Item.Weapon.Firearm.\",\n  \"class\": \"Neutral\",\n  \"level\": -1,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 4,\n      \"type\": \"Ammo\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "b1e03e",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Roland's .38 Special",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 432500,
          "CustomDeck": {
            "4325": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419416/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/003.CoverUp_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"3497e84b-9698-4d54-937c-65096eb6c82c\",\n  \"type\": \"Treachery\",\n  \"name\": \"Cover Up\",\n  \"traits\": \"Task.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "cba99b",
          "Name": "CardCustom",
          "Nickname": "Cover Up",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 170600,
          "CustomDeck": {
            "1706": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415038/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/019.Ithaca37_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"65d2caa3-55a1-495c-8538-445c3b874d88\",\n  \"type\": \"Asset\",\n  \"name\": \"Ithaca 37.\",\n  \"traits\": \"Item.Weapon.Firearm.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 4,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Ammo\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "f10bc1",
          "Name": "CardCustom",
          "Nickname": "Ithaca 37.",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 760400,
          "CustomDeck": {
            "7604": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419420/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/020.MarkedforExposure_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"fa4fc03d-1518-410f-9907-13b5d033d3bf\",\n  \"type\": \"Asset\",\n  \"name\": \"Marked for Exposure\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "f88649",
          "Name": "CardCustom",
          "Nickname": "Marked for Exposure",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 856600,
          "CustomDeck": {
            "8566": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419423/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/021.PatrolOfficer_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"7acb0b77-618e-4ecf-8b40-f73ea408b7ce\",\n  \"type\": \"Asset\",\n  \"name\": \"Patrol Officer\",\n  \"traits\": \"Ally.Police.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "437872",
          "Name": "CardCustom",
          "Nickname": "Patrol Officer",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 600800,
          "CustomDeck": {
            "6008": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419425/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/022.ArmorPiercingRounds_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"90f891d9-68b9-45d1-bcde-f2b60e101a0f\",\n  \"type\": \"Event\",\n  \"name\": \"Armor Piercing Rounds\",\n  \"traits\": \"Upgrade.Supply.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 2,\n      \"type\": \"Ammo\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "ebc589",
          "Name": "CardCustom",
          "Nickname": "Armor Piercing Rounds",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 119600,
          "CustomDeck": {
            "1196": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419428/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/023.LethalLesson_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b85df6c2-e20f-49e7-b599-4813f62182a4\",\n  \"type\": \"Event\",\n  \"name\": \"Lethal Lesson\",\n  \"traits\": \"Tactic.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 1\n}",
          "GUID": "93a816",
          "Name": "CardCustom",
          "Nickname": "Lethal Lesson",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 803000,
          "CustomDeck": {
            "8030": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419430/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/024.PullthePlaceApart_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"c47a41b2-917c-4115-9453-a8282817b133\",\n  \"type\": \"Event\",\n  \"name\": \"Pull the Place Apart\",\n  \"traits\": \"Tactic.Insight.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 1\n}",
          "GUID": "dee9a2",
          "Name": "CardCustom",
          "Nickname": "Pull the Place Apart",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 646800,
          "CustomDeck": {
            "6468": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419433/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/025.Resourcefulness_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"c7426563-ce1d-41bd-9f9f-ddc2117bee60\",\n  \"type\": \"Event\",\n  \"name\": \"Resourcefulness\",\n  \"traits\": \"Tactic.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "0bd689",
          "Name": "CardCustom",
          "Nickname": "Resourcefulness",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 350300,
          "CustomDeck": {
            "3503": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419434/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/026.Looting_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"012db1e8-d517-4b56-b7e4-6b835194a12c\",\n  \"type\": \"Skill\",\n  \"name\": \"Looting\",\n  \"traits\": \"Fortune.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "74a89c",
          "Name": "CardCustom",
          "Nickname": "Looting",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 489000,
          "CustomDeck": {
            "4890": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419438/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/027.Technician_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6bd203f9-dda2-4b7b-a309-ec7340fb4e56\",\n  \"type\": \"Skill\",\n  \"name\": \"Technician\",\n  \"traits\": \"Practiced.\",\n  \"class\": \"Guardian\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "1d5570",
          "Name": "CardCustom",
          "Nickname": "Technician",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 159700,
          "CustomDeck": {
            "1597": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419441/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/028.GearAssignment_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2488ce13-de22-4c57-af80-f402d177888d\",\n  \"type\": \"Event\",\n  \"name\": \"Gear Assignment\",\n  \"traits\": \"Upgrade.Tactic.\",\n  \"class\": \"Guardian\",\n  \"level\": 1,\n  \"cost\": 3\n}",
          "GUID": "8d7534",
          "Name": "CardCustom",
          "Nickname": "Gear Assignment",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 145800,
          "CustomDeck": {
            "1458": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415043/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/029.Ithaca37_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6f33256b-3f9a-4098-bbab-a3a35a2c7ce2\",\n  \"type\": \"Asset\",\n  \"name\": \"Ithaca 37.\",\n  \"traits\": \"Item.Weapon.Firearm.\",\n  \"class\": \"Guardian\",\n  \"level\": 2,\n  \"cost\": 4,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Ammo\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "295051",
          "Name": "CardCustom",
          "Nickname": "Ithaca 37.",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 384400,
          "CustomDeck": {
            "3844": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419445/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/030.MarkedforExposure_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"bf5be32c-dd7f-4343-a394-7be9e64562d1\",\n  \"type\": \"Asset\",\n  \"name\": \"Marked for Exposure\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Guardian\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "8707f4",
          "Name": "CardCustom",
          "Nickname": "Marked for Exposure",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 402800,
          "CustomDeck": {
            "4028": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419449/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/031.TrenchKnife_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"0e696712-f226-4b3e-80fc-2f016ec9d1d8\",\n  \"type\": \"Asset\",\n  \"name\": \"Trench Knife\",\n  \"traits\": \"Item.Weapon.Melee.\",\n  \"class\": \"Guardian\",\n  \"level\": 2,\n  \"cost\": 1\n}",
          "GUID": "61ac91",
          "Name": "CardCustom",
          "Nickname": "Trench Knife",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 911300,
          "CustomDeck": {
            "9113": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419452/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/032.WardetchedSkin_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"503d7d35-9a3d-47f1-8ce1-8e9ace10ab36\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Ward-etched Skin\",\n  \"traits\": \"Spirit.Blessed.Cursed.\",\n  \"class\": \"Guardian\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "fb1707",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Ward-etched Skin",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 261800,
          "CustomDeck": {
            "2618": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419455/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/033.EvidenceinBlood_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"ca8debdb-ed47-4496-82f8-12b6a5d4b6de\",\n  \"type\": \"Skill\",\n  \"name\": \"Evidence in Blood\",\n  \"traits\": \"Practiced.Expert.\",\n  \"class\": \"Guardian\",\n  \"level\": 2,\n  \"cost\": -1\n}",
          "GUID": "479b0f",
          "Name": "CardCustom",
          "Nickname": "Evidence in Blood",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 715300,
          "CustomDeck": {
            "7153": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419457/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/034.SisterAurelia_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "Balm of the Angels",
          "GMNotes": "{\n  \"id\": \"471967ab-cdae-46af-a413-8354dfa0a637\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Sister Aurelia\",\n  \"traits\": \"Ally.Blessed.Believer.\",\n  \"class\": \"Guardian\",\n  \"level\": 3,\n  \"cost\": 3\n}",
          "GUID": "717027",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Sister Aurelia",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 222500,
          "CustomDeck": {
            "2225": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419459/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/035.DualWielding_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6b0a7f29-c95e-4dd1-b810-7059cb0d29e4\",\n  \"type\": \"Event\",\n  \"name\": \"Dual Wielding\",\n  \"traits\": \"Tactic.\",\n  \"class\": \"Guardian\",\n  \"level\": 3,\n  \"cost\": 1\n}",
          "GUID": "8d137b",
          "Name": "CardCustom",
          "Nickname": "Dual Wielding",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 501900,
          "CustomDeck": {
            "5019": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419461/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/036.Bandolier_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"cbd20783-17ea-45f1-930e-12376be73825\",\n  \"type\": \"Asset\",\n  \"name\": \"Bandolier\",\n  \"traits\": \"Item.\",\n  \"class\": \"Guardian\",\n  \"level\": 4,\n  \"cost\": 2\n}",
          "GUID": "0c4c52",
          "Name": "CardCustom",
          "Nickname": "Bandolier",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 451000,
          "CustomDeck": {
            "4510": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415049/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/010.AgnesBaker_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415046/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/010.AgnesBaker_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "The Waitress",
          "GMNotes": "{\n  \"id\": \"43c6f1af-6bfc-40f6-af6c-a597816517b1\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Sorcerer.\",\n  \"class\": \"Mystic\",\n  \"willpowerIcons\": 5,\n  \"intellectIcons\": 2,\n  \"combatIcons\": 2,\n  \"agilityIcons\": 3,\n  \"extraToken\": \"Reaction\",\n  \"signatures\": [\n    {\n      \"72c24b02-73a3-45d7-b3af-c3caa561e00d\": 1,\n      \"b1198eb7-0345-4e57-903c-a07eb3f88fc9\": 1\n    }\n  ]\n}",
          "GUID": "834775",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…Agnes Baker",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 704900,
          "CustomDeck": {
            "7049": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415053/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/011.HeirloomofHyperborea_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "Artifact from Another Life",
          "GMNotes": "{\n  \"id\": \"72c24b02-73a3-45d7-b3af-c3caa561e00d\",\n  \"type\": \"Asset\",\n  \"traits\": \"Item. Relic.\",\n  \"class\": \"Neutral\",\n  \"cost\": 3\n}",
          "GUID": "5828ad",
          "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"playercards/cards/SealTemplate\")\nend)\n__bundle_register(\"chaosbag/BlessCurseManagerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local BlessCurseManagerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  local function getManager()\n    return guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"BlessCurseManager\")\n  end\n\n  -- removes all taken tokens and resets the counts\n  BlessCurseManagerApi.removeTakenTokensAndReset = function()\n    local BlessCurseManager = getManager()\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Bless\") end, 0.05)\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Curse\") end, 0.10)\n    Wait.time(function() BlessCurseManager.call(\"doReset\", \"White\") end, 0.15)\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.sealedToken = function(type, guid, silent)\n    getManager().call(\"sealedToken\", { type = type, guid = guid, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param fromBag? boolean Whether or not token was just drawn from the chaos bag\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.releasedToken = function(type, guid, fromBag, silent)\n    getManager().call(\"releasedToken\", { type = type, guid = guid, fromBag = fromBag, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  BlessCurseManagerApi.returnedToken = function(type, guid)\n    getManager().call(\"returnedToken\", { type = type, guid = guid })\n  end\n\n  -- broadcasts the current status for bless/curse tokens\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.broadcastStatus = function(playerColor)\n    getManager().call(\"broadcastStatus\", playerColor)\n  end\n\n  -- removes all bless / curse tokens from the chaos bag and play\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.removeAll = function(playerColor)\n    getManager().call(\"doRemove\", playerColor)\n  end\n\n  -- adds bless / curse sealing to the hovered card\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param hoveredObject tts__Object Hovered object\n  ---@param noCurse? boolean True if just Bless sealing should be added (Parallel Mateo)\n  BlessCurseManagerApi.addBlurseSealingMenu = function(playerColor, hoveredObject, noCurse)\n    getManager().call(\"addMenuOptions\", { playerColor = playerColor, hoveredObject = hoveredObject, noCurse = noCurse })\n  end\n\n  -- adds bless / curse to the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.addToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = false })\n  end\n\n  -- removes bless / curse from the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.removeToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = true })\n  end\n\n  BlessCurseManagerApi.getBlessCurseInBag = function()\n    return getManager().call(\"getBlessCurseInBag\", {})\n  end\n\n  return BlessCurseManagerApi\nend\nend)\n__bundle_register(\"chaosbag/ChaosBagApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local ChaosBagApi = {}\n\n  -- respawns the chaos bag with a new state of tokens\n  ---@param tokenList table List of chaos token ids\n  ChaosBagApi.setChaosBagState = function(tokenList)\n    Global.call(\"setChaosBagState\", tokenList)\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getChaosBagState = function()\n    local chaosBagContentsCatcher = Global.call(\"getChaosBagState\")\n    local chaosBagContents = {}\n    for _, v in ipairs(chaosBagContentsCatcher) do\n      table.insert(chaosBagContents, v)\n    end\n    return chaosBagContents\n  end\n\n  -- checks scripting zone for chaos bag (also called by a lot of objects!)\n  ChaosBagApi.findChaosBag = function()\n    return Global.call(\"findChaosBag\")\n  end\n\n  -- returns a table of object references to the tokens in play (does not include sealed tokens!)\n  ChaosBagApi.getTokensInPlay = function()\n    return Global.call(\"getChaosTokensinPlay\")\n  end\n\n  -- returns all sealed tokens on cards to the chaos bag\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param filterName? string Name of the token to release\n  ---@param silent? boolean Whether or not to hide messages\n  ChaosBagApi.releaseAllSealedTokens = function(playerColor, filterName, silent)\n    Global.call(\"releaseAllSealedTokens\", { playerColor = playerColor, filterName = filterName, silent = silent })\n  end\n\n  -- returns all drawn tokens to the chaos bag\n  ChaosBagApi.returnChaosTokens = function()\n    Global.call(\"returnChaosTokens\")\n  end\n\n  -- removes the specified chaos token from the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.removeChaosToken = function(id)\n    Global.call(\"removeChaosToken\", id)\n  end\n\n  -- returns a chaos token to the bag and calls all relevant functions\n  ---@param token tts__Object Chaos token to return\n  ---@param fromBag boolean whether or not the token to return was in the middle of being drawn (true) or elsewhere (false)\n  ChaosBagApi.returnChaosTokenToBag = function(token, fromBag)\n    Global.call(\"returnChaosTokenToBag\", { token = token, fromBag = fromBag })\n  end\n\n  -- spawns the specified chaos token and puts it into the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.spawnChaosToken = function(id)\n    Global.call(\"spawnChaosToken\", id)\n  end\n\n  -- Checks to see if the chaos bag can be manipulated.  If a player is searching the bag when tokens\n  -- are drawn or replaced a TTS bug can cause those tokens to vanish.  Any functions which change the\n  -- contents of the bag should check this method before doing so.\n  -- This method will broadcast a message to all players if the bag is being searched.\n  ---@return any: True if the bag is manipulated, false if it should be blocked.\n  ChaosBagApi.canTouchChaosTokens = function()\n    return Global.call(\"canTouchChaosTokens\")\n  end\n\n  ChaosBagApi.activeRedrawEffect = function(validTokens, invalidTokens, returnToPool, drawSpecificToken)\n    Global.call(\"activeRedrawEffect\", {\n      validTokens = validTokens,\n      invalidTokens = invalidTokens,\n      returnToPool = returnToPool,\n      drawSpecificToken = drawSpecificToken\n    })\n  end\n\n  ChaosBagApi.getReadableTokenName = function(tokenName)\n    return Global.call(\"getReadableTokenName\", tokenName)\n  end\n\n  ChaosBagApi.getChaosTokenName = function(chosenToken)\n    return Global.call(\"getChaosTokenName\", chosenToken)\n  end\n\n  -- draws a chaos token to a playermat\n  ---@param mat tts__Object|string Playermat that triggered this (either object or matColor)\n  ---@param drawAdditional boolean Controls whether additional tokens should be drawn\n  ---@param tokenType? string Name of token (e.g. \"Bless\") to be drawn from the bag\n  ---@param guidToBeResolved? string GUID of the sealed token to be resolved instead of drawing a token from the bag\n  ---@param takeParameters? table Position and rotation of the location where the new token should be drawn to, usually to replace a returned token\n  ---@return tts__Object: Object reference to the token that was drawn\n  ChaosBagApi.drawChaosToken = function(mat, drawAdditional, tokenType, guidToBeResolved, takeParameters)\n    return Global.call(\"drawChaosToken\", {\n      mat              = mat,\n      drawAdditional   = drawAdditional,\n      tokenType        = tokenType,\n      guidToBeResolved = guidToBeResolved,\n      takeParameters   = takeParameters\n    })\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getIdUrlMap = function()\n    return Global.getTable(\"ID_URL_MAP\")\n  end\n\n  return ChaosBagApi\nend\nend)\n__bundle_register(\"core/GUIDReferenceApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local GUIDReferenceApi = {}\n\n  local function getGuidHandler()\n    return getObjectFromGUID(\"123456\")\n  end\n\n  -- Returns the matching object\n  ---@param owner string Parent object for this search\n  ---@param type string Type of object to search for\n  ---@return any: Object reference to the matching object\n  GUIDReferenceApi.getObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"getObjectByOwnerAndType\", { owner = owner, type = type })\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param type string Type of object to search for\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByType = function(type)\n    return getGuidHandler().call(\"getObjectsByType\", type)\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param owner string Parent object for this search\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByOwner = function(owner)\n    return getGuidHandler().call(\"getObjectsByOwner\", owner)\n  end\n\n  -- Sends new information to the reference handler to edit the main index (if type/guid are omitted, entry will be removed)\n  ---@param owner string Parent of the object\n  ---@param type? string Type of the object\n  ---@param guid? string GUID of the object\n  GUIDReferenceApi.editIndex = function(owner, type, guid)\n    return getGuidHandler().call(\"editIndex\", {\n      owner = owner,\n      type = type,\n      guid = guid\n    })\n  end\n\n  -- Returns the owner of an object or the object it's located on\n  ---@param object tts__GameObject Object for this search\n  ---@return string: Parent of the object or object it's located on\n  GUIDReferenceApi.getOwnerOfObject = function(object)\n    return getGuidHandler().call(\"getOwnerOfObject\", object)\n  end\n\n  -- Remove object\n  ---@param owner string Parent of the object\n  ---@param type string Type of the object\n  GUIDReferenceApi.removeObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"removeObjectByOwnerAndType\", {\n      owner = owner,\n      type = type\n    })\n  end\n\n  return GUIDReferenceApi\nend\nend)\n__bundle_register(\"playercards/CardsThatSealTokens\", function(require, _LOADED, __bundle_register, __bundle_modules)\n--[[ Library for cards that seal tokens\nThis file is used to add sealing option to cards' context menu.\nNOTE: all cards are allowed to release a single token to enable Hallow and A Watchful Peace,\nand to release all sealed tokens to allow for cards that might leave play with sealed tokens on them.\nValid options (set before requiring this file):\n\nMAX_SEALED          --@type: number (maximum number of tokens allowable by the card to be sealed)\n  - required for all cards\n  - if MAX_SEALED is more than 1, then an XML label is created for the topmost token indicating the number of sealed tokens\n  - gives an error if user tries to seal additional tokens on the card\n  - example usage: \"The Chthonian Stone\"\n    > MAX_SEALED = 1\n\nUPDATE_ON_HOVER     --@type: boolean\n  - automatically updates the context menu options when the card is hovered\n  - the \"Read Bag\" function reads the content of the chaos bag to update the context menu\n  - example usage: \"Unrelenting\" (to only display valid tokens)\n\nKEEP_OPEN           --@type: boolean\n- meant for cards that seal single tokens multiple times (one by one)\n- makes the context menu stay open after selecting an option\n- example usage: \"Unrelenting\"\n\nSHOW_MULTI_RELEASE  --@type: number (maximum amount of tokens to release at once)\n  - enables an entry in the context menu\n  - this entry allows releasing of multiple tokens at once, to the maximum number\n  - does not fail if there are fewer than the maximum sealed\n  - example usage: \"Nephthys\" (to release up to 3 bless tokens at once)\n\nSHOW_MULTI_RETURN   --@type: number (amount of tokens to return to pool at once)\n  - enables an entry in the context menu\n  - this entry allows returning tokens to the token pool\n  - fails if not enough tokens are sealed\n  - example usage: \"Nephthys\" (to return 3 bless tokens at once)\n\nSHOW_RETURN_ALL   --@boolean:\n  - enables an entry in the context menu\n  - this entry allows returning all sealed tokens to the token pool\n  - example usage: \"Radiant Smite\" (to return whatever number of bless tokens that are sealed at once)\n\nSHOW_MULTI_SEAL     --@type: number (amount of tokens to seal at once)\n  - enables an entry in the context menu\n  - this entry allows sealing of multiple tokens at once\n  - example usage: \"Holy Spear\" (to seal two bless tokens at once)\n\nVALID_TOKENS        --@type: table ([tokenName] = true)\n  - this table defines which tokens should be abled to be sealed\n  - needs to be defined for each card -> even if empty\n  - example usage: \"The Chthonian Stone\"\n    > VALID_TOKENS = {\n    >   [\"Skull\"]       = true,\n    >   [\"Cultist\"]     = true,\n    >   [\"Tablet\"]      = true,\n    >   [\"Elder Thing\"] = true,\n    > }\n\nINVALID_TOKENS      --@type: table ([tokenName] = true)\n  - this table defines which tokens are invalid for sealing\n  - only needs to be defined if needed\n  - usually combined with empty \"VALID_TOKENS\" table\n  - example usage: \"Protective Incantation\" (not allowed to seal Auto-fail)\n\n----------------------------------------------------------\nExample 1: Crystalline Elder Sign\nThis card can only seal the \"+1\" or \"Elder Sign\" token,\nit does not need specific options for multi-sealing or releasing.\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"+1\"] = true,\n  >   [\"Elder Sign\"] = true\n  > }\n  > MAX_SEALED = 1\n  > require...\n----------------------------------------------------------\nExample 2: Holy Spear\nThis card features the following abilities (just listing the relevant parts):\n- releasing a single bless token\n- sealing two bless tokens\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"Bless\"] = true\n  > }\n  > SHOW_MULTI_SEAL = 2\n  > MAX_SEALED = 10\n  > require...\n----------------------------------------------------------]]\n\nlocal blessCurseManagerApi = require(\"chaosbag/BlessCurseManagerApi\")\nlocal chaosBagApi          = require(\"chaosbag/ChaosBagApi\")\nlocal playermatApi         = require(\"playermat/PlayermatApi\")\nlocal tokenArrangerApi     = require(\"tokens/TokenArrangerApi\")\n\nlocal sealedTokens         = {}\nlocal ID_URL_MAP           = {}\nlocal tokensInBag          = {}\n\n-- XML background color for each token for label when stacked\nlocal tokenColor           = {\n  [\"Skull\"]       = \"#4A0400E6\",\n  [\"Cultist\"]     = \"#173B0BE6\",\n  [\"Tablet\"]      = \"#1D2238E6\",\n  [\"Elder Thing\"] = \"#4D2331E6\",\n  [\"Auto-fail\"]   = \"#9B0004E6\",\n  [\"Bless\"]       = \"#9D702CE6\",\n  [\"Curse\"]       = \"#633A84E6\",\n  [\"Frost\"]       = \"#404450E6\",\n  [\"Elder Sign\"]  = \"#50A8CEE6\",\n  [\"\"]            = \"#77674DE6\"\n}\n\nfunction updateSave()\n  updateStackSize()\n  self.script_state = JSON.encode(sealedTokens)\nend\n\nfunction onLoad(savedData)\n  -- if MAX_SEALED is not set, default to 99\n  MAX_SEALED = MAX_SEALED or 99\n\n  -- verify sealed tokens\n  for _, guid in ipairs(JSON.decode(savedData) or {}) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      table.insert(sealedTokens, guid)\n    end\n  end\n\n  ID_URL_MAP = chaosBagApi.getIdUrlMap()\n  generateContextMenu()\n  updateStackSize()\n  self.addTag(\"CardThatSeals\")\nend\n\n-- i18n menu labels (injected by generator)\nlocal MENU_RELEASE_ONE = \"Release one token\"\nlocal MENU_RELEASE_ONE_PREFIX = \"Release \"\nlocal MENU_RELEASE_ALL = \"Release all tokens\"\nlocal MENU_RELEASE_MULTI_PREFIX = \"Release \"\nlocal MENU_RETURN_MULTI_PREFIX = \"Return \"\nlocal MENU_TOKEN_SUFFIX = \" token(s)\"\nlocal MENU_RETURN_ALL = \"Return all tokens\"\nlocal MENU_RESOLVE_PREFIX = \"Resolve \"\nlocal MENU_RESOLVE_ONE = \"Resolve one token\"\nlocal MENU_RESOLVE_ONE_PREFIX = \"Resolve \"\nlocal MENU_SEAL_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_INFIX = \" \"\nlocal function TOKEN_DISPLAY(name) return name end\nlocal function TOKEN_DISPLAY_OR_DEFAULT(name, default) return (name and TOKEN_DISPLAY(name)) or default end\n\nlocal GENERIC_TOKEN_LABEL = \"token\"\n\n-- builds the context menu\nfunction generateContextMenu()\n  -- determine if exactly one valid token type is configured\n  local SINGLE_VALID_TOKEN = nil\n  for k, _ in pairs(VALID_TOKENS) do\n    if SINGLE_VALID_TOKEN == nil then\n      SINGLE_VALID_TOKEN = k\n    else\n      SINGLE_VALID_TOKEN = false -- more than one\n      break\n    end\n  end\n\n  local releaseOneLabel\n  if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n    releaseOneLabel = MENU_RELEASE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n  else\n    releaseOneLabel = MENU_RELEASE_ONE\n  end\n  self.addContextMenuItem(releaseOneLabel, releaseOneToken)\n\n  -- conditional release options\n  if MAX_SEALED > 1 then\n    self.addContextMenuItem(MENU_RELEASE_ALL, releaseAllTokens)\n  end\n\n  if SHOW_MULTI_RELEASE then\n    self.addContextMenuItem(MENU_RELEASE_MULTI_PREFIX .. SHOW_MULTI_RELEASE .. MENU_TOKEN_SUFFIX, releaseMultipleTokens)\n  end\n\n  if RESOLVE_TOKEN then\n    local resolveOneLabel\n    if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n      resolveOneLabel = MENU_RESOLVE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n    else\n      resolveOneLabel = MENU_RESOLVE_ONE\n    end\n    self.addContextMenuItem(resolveOneLabel, resolveSealed)\n  end\n\n  if SHOW_MULTI_RETURN then\n    self.addContextMenuItem(MENU_RETURN_MULTI_PREFIX .. SHOW_MULTI_RETURN .. MENU_TOKEN_SUFFIX, returnMultipleTokens)\n  end\n\n  if SHOW_RETURN_ALL then\n    self.addContextMenuItem(MENU_RETURN_ALL, returnAllTokens)\n  end\n\n  -- main context menu options to seal tokens\n  for _, map in pairs(ID_URL_MAP) do\n    if (VALID_TOKENS[map.name] ~= nil) or (UPDATE_ON_HOVER and tokensInBag[map.name] and INVALID_TOKENS and not INVALID_TOKENS[map.name]) then\n      if not SHOW_MULTI_SEAL then\n        self.addContextMenuItem(MENU_SEAL_PREFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          sealToken(map.name, playerColor)\n        end, KEEP_OPEN)\n      else\n        self.addContextMenuItem(MENU_SEAL_MULTI_PREFIX .. SHOW_MULTI_SEAL .. MENU_SEAL_MULTI_INFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          readBag()\n          local allowed = true\n          local notFound\n\n          for name, _ in pairs(VALID_TOKENS) do\n            if (tokensInBag[name] or 0) < SHOW_MULTI_SEAL then\n              allowed = false\n              notFound = name\n            end\n          end\n\n          if allowed then\n            for i = SHOW_MULTI_SEAL, 1, -1 do\n              sealToken(map.name, playerColor)\n            end\n          else\n            printToColor(\"Not enough \" .. notFound .. \" tokens in the chaos bag.\", playerColor)\n          end\n        end)\n      end\n    end\n  end\nend\n\n-- generates a list of chaos tokens that is in the chaos bag\nfunction readBag()\n  local chaosbag = chaosBagApi.findChaosBag()\n  tokensInBag = {}\n\n  for _, token in ipairs(chaosbag.getObjects()) do\n    tokensInBag[token.name] = (tokensInBag[token.name] or 0) + 1\n  end\nend\n\nfunction resetSealedTokens()\n  sealedTokens = {}\n  updateSave()\nend\n\n-- native event from TTS - used to update the context menu for cards like \"Unrelenting\"\nfunction onHover()\n  if UPDATE_ON_HOVER then\n    readBag()\n    self.clearContextMenu()\n    generateContextMenu()\n  end\nend\n\n-- seals the named token on this card\nfunction sealToken(name, playerColor)\n  if #sealedTokens >= MAX_SEALED then\n    printToColor(\"Cannot seal any more tokens on this card\", playerColor, \"Red\")\n    return\n  end\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  local chaosbag = chaosBagApi.findChaosBag()\n  for i, obj in ipairs(chaosbag.getObjects()) do\n    if obj.name == name then\n      return chaosbag.takeObject({\n        position = self.getPosition() + Vector(0, 0.5 + 0.1 * #sealedTokens, 0),\n        rotation = self.getRotation(),\n        index = i - 1,\n        smooth = false,\n        callback_function = function(token)\n          local guid = token.getGUID()\n          table.insert(sealedTokens, guid)\n          tokenArrangerApi.layout()\n          if name == \"Bless\" or name == \"Curse\" then\n            blessCurseManagerApi.sealedToken(name, guid)\n          end\n          -- destroy XML on just covered token\n          if #sealedTokens > 1 then\n            local coveredToken = getObjectFromGUID(sealedTokens[#sealedTokens - 1])\n            if coveredToken ~= nil then\n              coveredToken.UI.setXml(\"\")\n            else\n              table.remove(sealedTokens, #sealedTokens - 1)\n            end\n          end\n          updateSave()\n        end\n      })\n    end\n  end\n  printToColor(name .. \" token not found in chaos bag\", playerColor)\nend\n\n-- release the last sealed token\nfunction releaseOneToken(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"No sealed token(s) found\", playerColor)\n  else\n    printToColor(\"Releasing token\", playerColor)\n\n    -- make list of token names\n    local tokenNames = {}\n    local differentNames = 0\n    for _, guid in ipairs(sealedTokens) do\n      local token = getObjectFromGUID(guid)\n      if token ~= nil then\n        local name = token.getName()\n        if tokenNames[name] == nil then\n          differentNames = differentNames + 1\n        end\n        tokenNames[name] = guid\n      end\n    end\n\n    -- if there are multiple tokens, ask the player to choose\n    if differentNames < 2 then\n      putTokenAway(table.remove(sealedTokens))\n      updateSave()\n    else\n      local choices = {}\n      for name, _ in pairs(tokenNames) do\n        table.insert(choices, name)\n      end\n      Player[playerColor].showOptionsDialog(\"Choose token to release:\", choices, 1, function(optionText, optionIndex)\n        for i = #sealedTokens, 1, -1 do\n          local token = getObjectFromGUID(sealedTokens[i])\n          if token ~= nil and token.getName() == optionText then\n            putTokenAway(table.remove(sealedTokens, i))\n            updateSave()\n            break\n          end\n        end\n      end)\n    end\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- release up to multiple tokens at once with no minimum\nfunction releaseMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n    return\n  end\n\n  local numRemoved = SHOW_MULTI_RELEASE\n  if #sealedTokens < SHOW_MULTI_RELEASE then\n    numRemoved = #sealedTokens\n  end\n\n  for i = 1, numRemoved do\n    putTokenAway(table.remove(sealedTokens))\n  end\n  updateSave()\n  printToColor(\"Releasing \" .. numRemoved .. \" tokens\", playerColor)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction releaseAllTokensWrapper(params)\n  releaseAllTokens(params.playerColor, _, _, params.filterName, params.silent)\nend\n\n-- releases all sealed tokens\nfunction releaseAllTokens(playerColor, _, _, filterName, silent)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    if not silent then\n      printToColor(\"No sealed token(s) found\", playerColor)\n    end\n  else\n    if not silent then\n      printToColor(\"Releasing token(s)\", playerColor)\n    end\n\n    for i = #sealedTokens, 1, -1 do\n      local success = putTokenAway(sealedTokens[i], filterName, silent)\n      if success then\n        table.remove(sealedTokens, i)\n      end\n    end\n\n    updateSave()\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns multiple tokens at once to the token pool (with minimum)\nfunction returnMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if SHOW_MULTI_RETURN <= #sealedTokens then\n    for i = 1, SHOW_MULTI_RETURN do\n      returnToken(table.remove(sealedTokens))\n    end\n    updateSave()\n    printToColor(\"Returning \" .. SHOW_MULTI_RETURN .. \" tokens to the token pool\", playerColor)\n  else\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns all sealed tokens to the token pool\nfunction returnAllTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  printToColor(\"Returning \" .. #sealedTokens .. \" tokens to the token pool\", playerColor)\n  for i = 1, #sealedTokens do\n    returnToken(table.remove(sealedTokens))\n  end\n  updateSave()\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns the token (referenced by GUID) to the chaos bag\n---@return boolean: True if a token was returned\nfunction putTokenAway(guid, filterName, silent)\n  local token = getObjectFromGUID(guid)\n  if not token then return false end\n\n  local name = token.getName()\n  if filterName and filterName ~= name then return false end\n\n  local chaosbag = chaosBagApi.findChaosBag()\n  chaosbag.putObject(token)\n\n  tokenArrangerApi.layout()\n\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.releasedToken(name, guid, nil, silent)\n  end\n\n  return true\nend\n\n-- returns the token to the pool (== removes it)\nfunction returnToken(guid)\n  local token = getObjectFromGUID(guid)\n  if not token then return end\n\n  local name = token.getName()\n  token.destruct()\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.returnedToken(name, guid)\n  end\nend\n\n-- resolves sealed token as if it came from the chaos bag\nfunction resolveSealed(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if #sealedTokens == 0 then\n    broadcastToAll(\"No tokens sealed.\", \"Red\")\n    return\n  end\n\n  -- make list of token names\n  local tokenNames = {}\n  local differentNames = 0\n  for _, guid in ipairs(sealedTokens) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      local name = token.getName()\n      if tokenNames[name] == nil then\n        differentNames = differentNames + 1\n      end\n      tokenNames[name] = guid\n    end\n  end\n\n  -- if there are multiple tokens, ask the player to choose\n  if differentNames < 2 then\n    resolveTokenByGuid(playerColor, table.remove(sealedTokens))\n    updateSave()\n  else\n    local choices = {}\n    for name, _ in pairs(tokenNames) do\n      table.insert(choices, name)\n    end\n    Player[playerColor].showOptionsDialog(\"Choose token to resolve:\", choices, 1, function(optionText, optionIndex)\n      for i = #sealedTokens, 1, -1 do\n        local token = getObjectFromGUID(sealedTokens[i])\n        if token ~= nil and token.getName() == optionText then\n          resolveTokenByGuid(playerColor, table.remove(sealedTokens, i))\n          updateSave()\n          return\n        end\n      end\n    end)\n  end\nend\n\nfunction resolveTokenByGuid(playerColor, guidToBeResolved)\n  local resolvedToken = getObjectFromGUID(guidToBeResolved)\n  if resolvedToken ~= nil then\n    resolvedToken.UI.setXml(\"\")\n  end\n\n  local closestMatColor = playermatApi.getMatColorByPosition(self.getPosition())\n  chaosBagApi.drawChaosToken(closestMatColor, true, _, guidToBeResolved)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction updateStackSize()\n  if MAX_SEALED == 1 then return end\n  if #sealedTokens == 0 then return end\n\n  -- get topmost sealed token\n  local topToken = getObjectFromGUID(sealedTokens[#sealedTokens])\n  if topToken == nil then return end\n\n  -- handling for two-digit numbers\n  local fontsize = 380\n  if #sealedTokens > 9 then\n    fontsize = 360\n  end\n\n  topToken.UI.setXmlTable({\n    {\n      tag = \"Panel\",\n      attributes = {\n        height = 380,\n        width = 380,\n        rotation = \"0 0 180\",\n        scale = \"0.2 0.2 1\",\n        position = \"0 0 -12\",\n        color = tokenColor[topToken.getName()] or \"#77674DE6\"\n      },\n      children = {\n        tag = \"Text\",\n        attributes = {\n          fontSize = fontsize,\n          font = \"font_teutonic-arkham\",\n          color = \"#ffffff\",\n          outline = \"#000000\",\n          outlineSize = \"8 -8\",\n          text = \"x\" .. #sealedTokens\n        }\n      }\n    }\n  })\nend\nend)\n__bundle_register(\"playercards/cards/SealTemplate\", function(require, _LOADED, __bundle_register, __bundle_modules)\nVALID_TOKENS = {\n  [\"0\"] = true,\n  [\"-1\"] = true\n}\n\nINVALID_TOKENS = nil\n\nUPDATE_ON_HOVER = true\n\nMAX_SEALED = 3\n\n-- RESOLVE_TOKEN config\nRESOLVE_TOKEN = true\n\nrequire(\"playercards/CardsThatSealTokens\")\nend)\n__bundle_register(\"playermat/PlayermatApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local PlayermatApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n  local searchLib = require(\"util/SearchLib\")\n  local localInvestigatorPosition = { x = -1.17, y = 1, z = -0.01 }\n\n  -- Convenience function to look up a mat's object by color, or get all mats.\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@return table: Single-element if only single playermat is requested\n  local function getMatForColor(matColor)\n    if matColor == \"All\" then\n      return guidReferenceApi.getObjectsByType(\"Playermat\")\n    else\n      return { matColor = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\") }\n    end\n  end\n\n  -- Returns the color of the closest playermat\n  ---@param startPos table Starting position to get the closest mat from\n  PlayermatApi.getMatColorByPosition = function(startPos)\n    local result, smallestDistance\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local distance = Vector.between(startPos, mat.getPosition()):magnitude()\n      if smallestDistance == nil or distance < smallestDistance then\n        smallestDistance = distance\n        result = matColor\n      end\n    end\n    return result\n  end\n\n  -- Returns the color of the player's hand that is seated next to the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getPlayerColor = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getVar(\"playerColor\")\n    end\n  end\n\n  -- Returns the color of the playermat that owns the playercolor's hand\n  ---@param handColor string Color of the playermat\n  PlayermatApi.getMatColor = function(handColor)\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local playerColor = mat.getVar(\"playerColor\")\n      if playerColor == handColor then\n        return matColor\n      end\n    end\n    return nil\n  end\n\n  -- gets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getSlotData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getTable(\"slotData\")\n    end\n  end\n\n  -- sets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param newSlotData table New slot data for the playermat\n  PlayermatApi.loadSlotData = function(matColor, newSlotData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.setTable(\"slotData\", newSlotData)\n      mat.call(\"updateSave\")\n      mat.call(\"updateSlotSymbols\")\n      return\n    end\n  end\n\n  -- Performs a search of the deck area of the requested playermat and returns the result as table\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDeckAreaObjects = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getDeckAreaObjects\")\n    end\n  end\n\n  -- Flips the top card of the deck (useful after deck manipulation for Norman Withers)\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.flipTopCardFromDeck = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"flipTopCardFromDeck\")\n    end\n  end\n\n  -- Returns the position of the discard pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDiscardPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDiscardPosition\")\n    end\n  end\n\n  -- Returns the position of the draw pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDrawPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDrawPosition\")\n    end\n  end\n\n  -- Transforms a local position into a global position\n  ---@param localPos table Local position to be transformed\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.transformLocalPosition = function(localPos, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.positionToWorld(localPos)\n    end\n  end\n\n  -- Returns the rotation of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.returnRotation = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getRotation()\n    end\n  end\n\n  -- Returns a table with spawn data (position and rotation) for a helper object\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param helperName string Name of the helper object\n  PlayermatApi.getHelperSpawnData = function(matColor, helperName)\n    local resultTable = {}\n    local localPositionTable = {\n      [\"Hand Helper\"] = Vector(-0.055, 0, -1.132),\n      [\"Search Assistant\"] = Vector(-0.34, 0, -1.132)\n    }\n\n    for color, mat in pairs(getMatForColor(matColor)) do\n      resultTable[color] = {\n        position = mat.positionToWorld(localPositionTable[helperName]),\n        rotation = mat.getRotation()\n      }\n    end\n    return resultTable\n  end\n\n\n  -- Triggers the Upkeep for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param playerColor string Color of the calling player (for messages)\n  PlayermatApi.doUpkeepFromHotkey = function(matColor, playerColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doUpkeepFromHotkey\", playerColor)\n    end\n  end\n\n  -- Handles discarding for the requested playermat for the provided list of objects\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param objList table List of objects to discard\n  PlayermatApi.discardListOfObjects = function(matColor, objList)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"discardListOfObjects\", objList)\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getActiveInvestigatorData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getActiveInvestigatorData\")\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param newData table New active investigator data (class and id)\n  PlayermatApi.setActiveInvestigatorData = function(matColor, newData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setActiveInvestigatorData\", newData)\n    end\n  end\n\n  -- Returns the position for encounter card drawing\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param stack boolean If true, returns the leftmost position instead of the first empty from the right\n  PlayermatApi.getEncounterCardDrawPosition = function(matColor, stack)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return Vector(mat.call(\"getEncounterCardDrawPosition\", stack))\n    end\n  end\n\n  -- Sets the requested playermat's snap points to limit snapping to matching card types or not.  If\n  -- matchTypes is true, the main card slot snap points will only snap assets, while the\n  -- investigator area point will only snap Investigators.  If matchTypes is false, snap points will\n  -- be reset to snap all cards.\n  ---@param matchCardTypes boolean Whether snap points should only snap for the matching card types\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.setLimitSnapsByType = function(matchCardTypes, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setLimitSnapsByType\", matchCardTypes)\n    end\n  end\n\n  -- Sets the requested playermat's draw 1 button to visible\n  ---@param isDrawButtonVisible boolean Whether the draw 1 button should be visible or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.showDrawButton = function(isDrawButtonVisible, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"showDrawButton\", isDrawButtonVisible)\n    end\n  end\n\n  -- Shows or hides the clickable clue counter for the requested playermat\n  ---@param showCounter boolean Whether the clickable counter should be present or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.clickableClues = function(showCounter, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"clickableClues\", showCounter)\n    end\n  end\n\n  -- Toggles the use of class textures for the requested playermat\n  ---@param state boolean Whether the class texture should be used or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.useClassTexture = function(state, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"useClassTexture\", state)\n    end\n  end\n\n  -- updates the texture of the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param overrideName? string Force a specific texture\n  PlayermatApi.updateTexture = function(matColor, overrideName)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateTexture\", overrideName)\n    end\n  end\n\n  -- Removes all clues (to the trash for tokens and counters set to 0) for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.removeClues = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"removeClues\")\n    end\n  end\n\n  -- Reports the clue count for the requested playermat\n  ---@param useClickableCounters boolean Controls which type of counter is getting checked\n  PlayermatApi.getClueCount = function(useClickableCounters, matColor)\n    local count = 0\n    for _, mat in pairs(getMatForColor(matColor)) do\n      count = count + mat.call(\"getClueCount\", useClickableCounters)\n    end\n    return count\n  end\n\n  -- Updates the specified owned counter\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param type string Counter to target\n  ---@param newValue number Value to set the counter to\n  ---@param modifier number If newValue is not provided, the existing value will be adjusted by this modifier\n  PlayermatApi.updateCounter = function(matColor, type, newValue, modifier)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateCounter\", { type = type, newValue = newValue, modifier = modifier })\n    end\n  end\n\n  -- Triggers the draw function for the specified playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param number number Amount of cards to draw\n  PlayermatApi.drawCardsWithReshuffle = function(matColor, number)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"drawCardsWithReshuffle\", number)\n    end\n  end\n\n  -- Returns the resource counter amount\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param type string Counter to target\n  PlayermatApi.getCounterValue = function(matColor, type)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getCounterValue\", type)\n    end\n  end\n\n  -- Returns a list of mat colors that have an investigator placed\n  PlayermatApi.getUsedMatColors = function()\n    local usedColors = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        table.insert(usedColors, matColor)\n      end\n    end\n    return usedColors\n  end\n\n  -- Returns a list of investigator card objects\n  PlayermatApi.getUsedInvestigatorCards = function()\n    local usedCards = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        usedCards[matColor] = searchResult[1]\n      end\n    end\n    return usedCards\n  end\n\n  -- Returns investigator name\n  ---@param matColor string Color of the playmat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getInvestigatorName = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult == 1 then\n        return searchResult[1].getName()\n      end\n    end\n    return \"\"\n  end\n\n  -- Resets the specified skill tracker to \"1, 1, 1, 1\"\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.resetSkillTracker = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"resetSkillTracker\")\n    end\n  end\n\n  -- Updates the XML for the slot symbols based on the slotData table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.updateSlotSymbols = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateSlotSymbols\")\n    end\n  end\n\n  -- Finds all objects on the playermat and associated set aside zone and returns a table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param filter? string Name of the filte function (see util/SearchLib)\n  PlayermatApi.searchAroundPlayermat = function(matColor, filter)\n    local objList = {}\n    for _, mat in pairs(getMatForColor(matColor)) do\n      for _, obj in ipairs(mat.call(\"searchAroundSelf\", filter)) do\n        table.insert(objList, obj)\n      end\n    end\n    return objList\n  end\n\n  -- Discard a non-hidden card from the corresponding player's hand\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.doDiscardOne = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doDiscardOne\")\n    end\n  end\n\n  -- Spawns the regular action tokens\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.spawnActionTokens = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"spawnActionTokens\")\n    end\n  end\n\n  -- Triggers the metadata sync for all playermats\n  PlayermatApi.syncAllCustomizableCards = function()\n    for _, mat in pairs(getMatForColor(\"All\")) do\n      mat.call(\"syncAllCustomizableCards\")\n    end\n  end\n\n  -- moves + rotates a playermat (and related objects)\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param position? table New position for the playermat\n  ---@param rotationY? number New y-rotation for the playermat (X and Z will be 0)\n  ---@param positionOffset? table Positional offset for the playermat\n  PlayermatApi.moveAndRotate = function(matColor, position, rotationY, positionOffset)\n    -- get mat and related objects\n    local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\")\n    if not mat then return end\n\n    -- get current transform data\n    local currentMatPos = mat.getPosition()\n    local currentMatRotY = mat.getRotation().y\n\n    -- use current values if undefined\n    position = position or currentMatPos\n    rotationY = rotationY or currentMatRotY\n\n    if positionOffset then\n      position = Vector(position) + Vector(positionOffset)\n    end\n\n    local movedObjects = {}\n    local function moveAndRotateObject(obj)\n      local relativePos = obj.getPosition() - currentMatPos\n      obj.setPosition(position + relativePos:rotateOver(\"y\", rotationY - currentMatRotY))\n\n      if obj.type == \"Hand\" then\n        obj.setRotation({ 0, rotationY + 180, 0 })\n      else\n        local objRot = obj.getRotation()\n        local relativeRotY = objRot.y - currentMatRotY\n        obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })\n      end\n\n      movedObjects[obj.getGUID()] = true\n    end\n\n    -- get objects on the mat\n    for _, obj in ipairs(searchLib.onObject(mat, \"isInteractable\")) do\n      if not movedObjects[obj.getGUID()] then\n        -- make sure object isn't owned by another mat\n        local owner = guidReferenceApi.getOwnerOfObject(obj)\n        if owner == \"Mythos\" or owner == matColor then\n          moveAndRotateObject(obj)\n        end\n      end\n    end\n\n    -- move owned objects (including the mat)\n    for _, obj in pairs(guidReferenceApi.getObjectsByOwner(matColor)) do\n      if not movedObjects[obj.getGUID()] then\n        moveAndRotateObject(obj)\n      end\n    end\n  end\n\n  return PlayermatApi\nend\nend)\n__bundle_register(\"tokens/TokenArrangerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local TokenArrangerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  -- internal function to create a copy of the table to avoid operating on variables owned by different objects\n  local function deepCopy(data)\n    if type(data) ~= \"table\" then return data end\n    local copiedList = {}\n    for key, value in pairs(data) do\n      if type(value) == \"table\" then\n        copiedList[key] = deepCopy(value)\n      else\n        copiedList[key] = value\n      end\n    end\n    return copiedList\n  end\n\n  -- local function to call the token arranger, if it is on the table\n  ---@param functionName string Name of the function to cal\n  ---@param argument? table Parameter to pass\n  local function callIfExistent(functionName, argument)\n    local tokenArranger = guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"TokenArranger\")\n    if tokenArranger ~= nil then\n      return tokenArranger.call(functionName, argument)\n    end\n  end\n\n  -- updates the token modifiers with the provided data\n  ---@param fullData table Contains the chaos token metadata\n  TokenArrangerApi.onTokenDataChanged = function(fullData)\n    callIfExistent(\"onTokenDataChanged\", fullData)\n  end\n\n  -- deletes already laid out tokens\n  TokenArrangerApi.deleteCopiedTokens = function()\n    callIfExistent(\"deleteCopiedTokens\")\n  end\n\n  -- updates the laid out tokens\n  TokenArrangerApi.layout = function()\n    Wait.time(function() callIfExistent(\"layout\") end, 0.1)\n  end\n\n  TokenArrangerApi.getSaveData = function()\n    return deepCopy(callIfExistent(\"getSaveData\"))\n  end\n\n  TokenArrangerApi.loadData = function(loadedData)\n    callIfExistent(\"loadData\", loadedData)\n  end\n\n  return TokenArrangerApi\nend\nend)\n__bundle_register(\"util/SearchLib\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local SearchLib = {}\n  local filterFunctions = {\n    isCard = function(x) return x.type == \"Card\" end,\n    isDeck = function(x) return x.type == \"Deck\" end,\n    isCardOrDeck = function(x) return x.type == \"Card\" or x.type == \"Deck\" end,\n    isClue = function(x) return x.memo == \"clueDoom\" and x.is_face_down == false end,\n    isDoom = function(x) return x.memo == \"clueDoom\" and x.is_face_down == true end,\n    isInteractable = function(x) return x.interactable end,\n    isTileOrToken = function(x) return not x.Book and (x.type == \"Tile\" or x.type == \"Generic\") end,\n    isUniversalToken = function(x) return x.getMemo() == \"universalActionAbility\" end,\n  }\n\n  -- performs the actual search and returns a filtered list of object references\n  ---@param pos tts__Vector Global position\n  ---@param rot? tts__Vector Global rotation\n  ---@param size table Size\n  ---@param filter? string Name of the filter function\n  ---@param direction? table Direction (positive is up)\n  ---@param maxDistance? number Distance for the cast\n  local function returnSearchResult(pos, rot, size, filter, direction, maxDistance)\n    local filterFunc = filter and filterFunctions[filter]\n    local searchResult = Physics.cast({\n      origin       = pos,\n      direction    = direction or { 0, 1, 0 },\n      orientation  = rot or { 0, 0, 0 },\n      type         = 3,\n      size         = size,\n      max_distance = maxDistance or 0\n    })\n\n    -- filter the result for matching objects\n    local objList = {}\n    for _, v in ipairs(searchResult) do\n      if (not filter or filterFunc(v.hit_object)) then\n        table.insert(objList, v.hit_object)\n      end\n    end\n    return objList\n  end\n\n  -- searches the specified area\n  function SearchLib.inArea(pos, rot, size, filter)\n    return returnSearchResult(pos, rot, size, filter)\n  end\n\n  -- searches the area on an object\n  function SearchLib.onObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, 1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the area directly below an object\n  function SearchLib.belowObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, -1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the specified position (a single point)\n  function SearchLib.atPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches below the specified position (downwards until y = 0)\n  function SearchLib.belowPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    local direction = { 0, -1, 0 }\n    local maxDistance = pos.y\n    return returnSearchResult(pos, _, size, filter, direction, maxDistance)\n  end\n\n  return SearchLib\nend\nend)\nreturn __bundle_require(\"__root\")\n",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Heirloom of Hyperborea",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 291300,
          "CustomDeck": {
            "2913": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415055/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/012.DarkMemory_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b1198eb7-0345-4e57-903c-a07eb3f88fc9\",\n  \"type\": \"Treachery\",\n  \"traits\": \"Curse. Omen.\",\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "6962a3",
          "Name": "CardCustom",
          "Nickname": "Dark Memory",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 295900,
          "CustomDeck": {
            "2959": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415058/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/074.EyesThroughtheVeil_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"cef9a713-1afa-4353-b436-dd3af1dfe6c0\",\n  \"type\": \"Asset\",\n  \"name\": \"Eyes Through the Veil\",\n  \"traits\": \"Spell.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 5,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "e41674",
          "Name": "CardCustom",
          "Nickname": "Eyes Through the Veil",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 689800,
          "CustomDeck": {
            "6898": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415060/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/075.MasterofSecrets_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"4a54b42b-c493-49b9-b81d-0e3a626ad6f5\",\n  \"type\": \"Asset\",\n  \"traits\": \"Ally. Witch.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "47e463",
          "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"playercards/cards/SealTemplate\")\nend)\n__bundle_register(\"chaosbag/BlessCurseManagerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local BlessCurseManagerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  local function getManager()\n    return guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"BlessCurseManager\")\n  end\n\n  -- removes all taken tokens and resets the counts\n  BlessCurseManagerApi.removeTakenTokensAndReset = function()\n    local BlessCurseManager = getManager()\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Bless\") end, 0.05)\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Curse\") end, 0.10)\n    Wait.time(function() BlessCurseManager.call(\"doReset\", \"White\") end, 0.15)\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.sealedToken = function(type, guid, silent)\n    getManager().call(\"sealedToken\", { type = type, guid = guid, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param fromBag? boolean Whether or not token was just drawn from the chaos bag\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.releasedToken = function(type, guid, fromBag, silent)\n    getManager().call(\"releasedToken\", { type = type, guid = guid, fromBag = fromBag, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  BlessCurseManagerApi.returnedToken = function(type, guid)\n    getManager().call(\"returnedToken\", { type = type, guid = guid })\n  end\n\n  -- broadcasts the current status for bless/curse tokens\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.broadcastStatus = function(playerColor)\n    getManager().call(\"broadcastStatus\", playerColor)\n  end\n\n  -- removes all bless / curse tokens from the chaos bag and play\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.removeAll = function(playerColor)\n    getManager().call(\"doRemove\", playerColor)\n  end\n\n  -- adds bless / curse sealing to the hovered card\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param hoveredObject tts__Object Hovered object\n  ---@param noCurse? boolean True if just Bless sealing should be added (Parallel Mateo)\n  BlessCurseManagerApi.addBlurseSealingMenu = function(playerColor, hoveredObject, noCurse)\n    getManager().call(\"addMenuOptions\", { playerColor = playerColor, hoveredObject = hoveredObject, noCurse = noCurse })\n  end\n\n  -- adds bless / curse to the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.addToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = false })\n  end\n\n  -- removes bless / curse from the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.removeToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = true })\n  end\n\n  BlessCurseManagerApi.getBlessCurseInBag = function()\n    return getManager().call(\"getBlessCurseInBag\", {})\n  end\n\n  return BlessCurseManagerApi\nend\nend)\n__bundle_register(\"chaosbag/ChaosBagApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local ChaosBagApi = {}\n\n  -- respawns the chaos bag with a new state of tokens\n  ---@param tokenList table List of chaos token ids\n  ChaosBagApi.setChaosBagState = function(tokenList)\n    Global.call(\"setChaosBagState\", tokenList)\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getChaosBagState = function()\n    local chaosBagContentsCatcher = Global.call(\"getChaosBagState\")\n    local chaosBagContents = {}\n    for _, v in ipairs(chaosBagContentsCatcher) do\n      table.insert(chaosBagContents, v)\n    end\n    return chaosBagContents\n  end\n\n  -- checks scripting zone for chaos bag (also called by a lot of objects!)\n  ChaosBagApi.findChaosBag = function()\n    return Global.call(\"findChaosBag\")\n  end\n\n  -- returns a table of object references to the tokens in play (does not include sealed tokens!)\n  ChaosBagApi.getTokensInPlay = function()\n    return Global.call(\"getChaosTokensinPlay\")\n  end\n\n  -- returns all sealed tokens on cards to the chaos bag\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param filterName? string Name of the token to release\n  ---@param silent? boolean Whether or not to hide messages\n  ChaosBagApi.releaseAllSealedTokens = function(playerColor, filterName, silent)\n    Global.call(\"releaseAllSealedTokens\", { playerColor = playerColor, filterName = filterName, silent = silent })\n  end\n\n  -- returns all drawn tokens to the chaos bag\n  ChaosBagApi.returnChaosTokens = function()\n    Global.call(\"returnChaosTokens\")\n  end\n\n  -- removes the specified chaos token from the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.removeChaosToken = function(id)\n    Global.call(\"removeChaosToken\", id)\n  end\n\n  -- returns a chaos token to the bag and calls all relevant functions\n  ---@param token tts__Object Chaos token to return\n  ---@param fromBag boolean whether or not the token to return was in the middle of being drawn (true) or elsewhere (false)\n  ChaosBagApi.returnChaosTokenToBag = function(token, fromBag)\n    Global.call(\"returnChaosTokenToBag\", { token = token, fromBag = fromBag })\n  end\n\n  -- spawns the specified chaos token and puts it into the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.spawnChaosToken = function(id)\n    Global.call(\"spawnChaosToken\", id)\n  end\n\n  -- Checks to see if the chaos bag can be manipulated.  If a player is searching the bag when tokens\n  -- are drawn or replaced a TTS bug can cause those tokens to vanish.  Any functions which change the\n  -- contents of the bag should check this method before doing so.\n  -- This method will broadcast a message to all players if the bag is being searched.\n  ---@return any: True if the bag is manipulated, false if it should be blocked.\n  ChaosBagApi.canTouchChaosTokens = function()\n    return Global.call(\"canTouchChaosTokens\")\n  end\n\n  ChaosBagApi.activeRedrawEffect = function(validTokens, invalidTokens, returnToPool, drawSpecificToken)\n    Global.call(\"activeRedrawEffect\", {\n      validTokens = validTokens,\n      invalidTokens = invalidTokens,\n      returnToPool = returnToPool,\n      drawSpecificToken = drawSpecificToken\n    })\n  end\n\n  ChaosBagApi.getReadableTokenName = function(tokenName)\n    return Global.call(\"getReadableTokenName\", tokenName)\n  end\n\n  ChaosBagApi.getChaosTokenName = function(chosenToken)\n    return Global.call(\"getChaosTokenName\", chosenToken)\n  end\n\n  -- draws a chaos token to a playermat\n  ---@param mat tts__Object|string Playermat that triggered this (either object or matColor)\n  ---@param drawAdditional boolean Controls whether additional tokens should be drawn\n  ---@param tokenType? string Name of token (e.g. \"Bless\") to be drawn from the bag\n  ---@param guidToBeResolved? string GUID of the sealed token to be resolved instead of drawing a token from the bag\n  ---@param takeParameters? table Position and rotation of the location where the new token should be drawn to, usually to replace a returned token\n  ---@return tts__Object: Object reference to the token that was drawn\n  ChaosBagApi.drawChaosToken = function(mat, drawAdditional, tokenType, guidToBeResolved, takeParameters)\n    return Global.call(\"drawChaosToken\", {\n      mat              = mat,\n      drawAdditional   = drawAdditional,\n      tokenType        = tokenType,\n      guidToBeResolved = guidToBeResolved,\n      takeParameters   = takeParameters\n    })\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getIdUrlMap = function()\n    return Global.getTable(\"ID_URL_MAP\")\n  end\n\n  return ChaosBagApi\nend\nend)\n__bundle_register(\"core/GUIDReferenceApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local GUIDReferenceApi = {}\n\n  local function getGuidHandler()\n    return getObjectFromGUID(\"123456\")\n  end\n\n  -- Returns the matching object\n  ---@param owner string Parent object for this search\n  ---@param type string Type of object to search for\n  ---@return any: Object reference to the matching object\n  GUIDReferenceApi.getObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"getObjectByOwnerAndType\", { owner = owner, type = type })\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param type string Type of object to search for\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByType = function(type)\n    return getGuidHandler().call(\"getObjectsByType\", type)\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param owner string Parent object for this search\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByOwner = function(owner)\n    return getGuidHandler().call(\"getObjectsByOwner\", owner)\n  end\n\n  -- Sends new information to the reference handler to edit the main index (if type/guid are omitted, entry will be removed)\n  ---@param owner string Parent of the object\n  ---@param type? string Type of the object\n  ---@param guid? string GUID of the object\n  GUIDReferenceApi.editIndex = function(owner, type, guid)\n    return getGuidHandler().call(\"editIndex\", {\n      owner = owner,\n      type = type,\n      guid = guid\n    })\n  end\n\n  -- Returns the owner of an object or the object it's located on\n  ---@param object tts__GameObject Object for this search\n  ---@return string: Parent of the object or object it's located on\n  GUIDReferenceApi.getOwnerOfObject = function(object)\n    return getGuidHandler().call(\"getOwnerOfObject\", object)\n  end\n\n  -- Remove object\n  ---@param owner string Parent of the object\n  ---@param type string Type of the object\n  GUIDReferenceApi.removeObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"removeObjectByOwnerAndType\", {\n      owner = owner,\n      type = type\n    })\n  end\n\n  return GUIDReferenceApi\nend\nend)\n__bundle_register(\"playercards/CardsThatSealTokens\", function(require, _LOADED, __bundle_register, __bundle_modules)\n--[[ Library for cards that seal tokens\nThis file is used to add sealing option to cards' context menu.\nNOTE: all cards are allowed to release a single token to enable Hallow and A Watchful Peace,\nand to release all sealed tokens to allow for cards that might leave play with sealed tokens on them.\nValid options (set before requiring this file):\n\nMAX_SEALED          --@type: number (maximum number of tokens allowable by the card to be sealed)\n  - required for all cards\n  - if MAX_SEALED is more than 1, then an XML label is created for the topmost token indicating the number of sealed tokens\n  - gives an error if user tries to seal additional tokens on the card\n  - example usage: \"The Chthonian Stone\"\n    > MAX_SEALED = 1\n\nUPDATE_ON_HOVER     --@type: boolean\n  - automatically updates the context menu options when the card is hovered\n  - the \"Read Bag\" function reads the content of the chaos bag to update the context menu\n  - example usage: \"Unrelenting\" (to only display valid tokens)\n\nKEEP_OPEN           --@type: boolean\n- meant for cards that seal single tokens multiple times (one by one)\n- makes the context menu stay open after selecting an option\n- example usage: \"Unrelenting\"\n\nSHOW_MULTI_RELEASE  --@type: number (maximum amount of tokens to release at once)\n  - enables an entry in the context menu\n  - this entry allows releasing of multiple tokens at once, to the maximum number\n  - does not fail if there are fewer than the maximum sealed\n  - example usage: \"Nephthys\" (to release up to 3 bless tokens at once)\n\nSHOW_MULTI_RETURN   --@type: number (amount of tokens to return to pool at once)\n  - enables an entry in the context menu\n  - this entry allows returning tokens to the token pool\n  - fails if not enough tokens are sealed\n  - example usage: \"Nephthys\" (to return 3 bless tokens at once)\n\nSHOW_RETURN_ALL   --@boolean:\n  - enables an entry in the context menu\n  - this entry allows returning all sealed tokens to the token pool\n  - example usage: \"Radiant Smite\" (to return whatever number of bless tokens that are sealed at once)\n\nSHOW_MULTI_SEAL     --@type: number (amount of tokens to seal at once)\n  - enables an entry in the context menu\n  - this entry allows sealing of multiple tokens at once\n  - example usage: \"Holy Spear\" (to seal two bless tokens at once)\n\nVALID_TOKENS        --@type: table ([tokenName] = true)\n  - this table defines which tokens should be abled to be sealed\n  - needs to be defined for each card -> even if empty\n  - example usage: \"The Chthonian Stone\"\n    > VALID_TOKENS = {\n    >   [\"Skull\"]       = true,\n    >   [\"Cultist\"]     = true,\n    >   [\"Tablet\"]      = true,\n    >   [\"Elder Thing\"] = true,\n    > }\n\nINVALID_TOKENS      --@type: table ([tokenName] = true)\n  - this table defines which tokens are invalid for sealing\n  - only needs to be defined if needed\n  - usually combined with empty \"VALID_TOKENS\" table\n  - example usage: \"Protective Incantation\" (not allowed to seal Auto-fail)\n\n----------------------------------------------------------\nExample 1: Crystalline Elder Sign\nThis card can only seal the \"+1\" or \"Elder Sign\" token,\nit does not need specific options for multi-sealing or releasing.\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"+1\"] = true,\n  >   [\"Elder Sign\"] = true\n  > }\n  > MAX_SEALED = 1\n  > require...\n----------------------------------------------------------\nExample 2: Holy Spear\nThis card features the following abilities (just listing the relevant parts):\n- releasing a single bless token\n- sealing two bless tokens\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"Bless\"] = true\n  > }\n  > SHOW_MULTI_SEAL = 2\n  > MAX_SEALED = 10\n  > require...\n----------------------------------------------------------]]\n\nlocal blessCurseManagerApi = require(\"chaosbag/BlessCurseManagerApi\")\nlocal chaosBagApi          = require(\"chaosbag/ChaosBagApi\")\nlocal playermatApi         = require(\"playermat/PlayermatApi\")\nlocal tokenArrangerApi     = require(\"tokens/TokenArrangerApi\")\n\nlocal sealedTokens         = {}\nlocal ID_URL_MAP           = {}\nlocal tokensInBag          = {}\n\n-- XML background color for each token for label when stacked\nlocal tokenColor           = {\n  [\"Skull\"]       = \"#4A0400E6\",\n  [\"Cultist\"]     = \"#173B0BE6\",\n  [\"Tablet\"]      = \"#1D2238E6\",\n  [\"Elder Thing\"] = \"#4D2331E6\",\n  [\"Auto-fail\"]   = \"#9B0004E6\",\n  [\"Bless\"]       = \"#9D702CE6\",\n  [\"Curse\"]       = \"#633A84E6\",\n  [\"Frost\"]       = \"#404450E6\",\n  [\"Elder Sign\"]  = \"#50A8CEE6\",\n  [\"\"]            = \"#77674DE6\"\n}\n\nfunction updateSave()\n  updateStackSize()\n  self.script_state = JSON.encode(sealedTokens)\nend\n\nfunction onLoad(savedData)\n  -- if MAX_SEALED is not set, default to 99\n  MAX_SEALED = MAX_SEALED or 99\n\n  -- verify sealed tokens\n  for _, guid in ipairs(JSON.decode(savedData) or {}) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      table.insert(sealedTokens, guid)\n    end\n  end\n\n  ID_URL_MAP = chaosBagApi.getIdUrlMap()\n  generateContextMenu()\n  updateStackSize()\n  self.addTag(\"CardThatSeals\")\nend\n\n-- i18n menu labels (injected by generator)\nlocal MENU_RELEASE_ONE = \"Release one token\"\nlocal MENU_RELEASE_ONE_PREFIX = \"Release \"\nlocal MENU_RELEASE_ALL = \"Release all tokens\"\nlocal MENU_RELEASE_MULTI_PREFIX = \"Release \"\nlocal MENU_RETURN_MULTI_PREFIX = \"Return \"\nlocal MENU_TOKEN_SUFFIX = \" token(s)\"\nlocal MENU_RETURN_ALL = \"Return all tokens\"\nlocal MENU_RESOLVE_PREFIX = \"Resolve \"\nlocal MENU_RESOLVE_ONE = \"Resolve one token\"\nlocal MENU_RESOLVE_ONE_PREFIX = \"Resolve \"\nlocal MENU_SEAL_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_INFIX = \" \"\nlocal function TOKEN_DISPLAY(name) return name end\nlocal function TOKEN_DISPLAY_OR_DEFAULT(name, default) return (name and TOKEN_DISPLAY(name)) or default end\n\nlocal GENERIC_TOKEN_LABEL = \"token\"\n\n-- builds the context menu\nfunction generateContextMenu()\n  -- determine if exactly one valid token type is configured\n  local SINGLE_VALID_TOKEN = nil\n  for k, _ in pairs(VALID_TOKENS) do\n    if SINGLE_VALID_TOKEN == nil then\n      SINGLE_VALID_TOKEN = k\n    else\n      SINGLE_VALID_TOKEN = false -- more than one\n      break\n    end\n  end\n\n  local releaseOneLabel\n  if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n    releaseOneLabel = MENU_RELEASE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n  else\n    releaseOneLabel = MENU_RELEASE_ONE\n  end\n  self.addContextMenuItem(releaseOneLabel, releaseOneToken)\n\n  -- conditional release options\n  if MAX_SEALED > 1 then\n    self.addContextMenuItem(MENU_RELEASE_ALL, releaseAllTokens)\n  end\n\n  if SHOW_MULTI_RELEASE then\n    self.addContextMenuItem(MENU_RELEASE_MULTI_PREFIX .. SHOW_MULTI_RELEASE .. MENU_TOKEN_SUFFIX, releaseMultipleTokens)\n  end\n\n  if RESOLVE_TOKEN then\n    local resolveOneLabel\n    if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n      resolveOneLabel = MENU_RESOLVE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n    else\n      resolveOneLabel = MENU_RESOLVE_ONE\n    end\n    self.addContextMenuItem(resolveOneLabel, resolveSealed)\n  end\n\n  if SHOW_MULTI_RETURN then\n    self.addContextMenuItem(MENU_RETURN_MULTI_PREFIX .. SHOW_MULTI_RETURN .. MENU_TOKEN_SUFFIX, returnMultipleTokens)\n  end\n\n  if SHOW_RETURN_ALL then\n    self.addContextMenuItem(MENU_RETURN_ALL, returnAllTokens)\n  end\n\n  -- main context menu options to seal tokens\n  for _, map in pairs(ID_URL_MAP) do\n    if (VALID_TOKENS[map.name] ~= nil) or (UPDATE_ON_HOVER and tokensInBag[map.name] and INVALID_TOKENS and not INVALID_TOKENS[map.name]) then\n      if not SHOW_MULTI_SEAL then\n        self.addContextMenuItem(MENU_SEAL_PREFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          sealToken(map.name, playerColor)\n        end, KEEP_OPEN)\n      else\n        self.addContextMenuItem(MENU_SEAL_MULTI_PREFIX .. SHOW_MULTI_SEAL .. MENU_SEAL_MULTI_INFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          readBag()\n          local allowed = true\n          local notFound\n\n          for name, _ in pairs(VALID_TOKENS) do\n            if (tokensInBag[name] or 0) < SHOW_MULTI_SEAL then\n              allowed = false\n              notFound = name\n            end\n          end\n\n          if allowed then\n            for i = SHOW_MULTI_SEAL, 1, -1 do\n              sealToken(map.name, playerColor)\n            end\n          else\n            printToColor(\"Not enough \" .. notFound .. \" tokens in the chaos bag.\", playerColor)\n          end\n        end)\n      end\n    end\n  end\nend\n\n-- generates a list of chaos tokens that is in the chaos bag\nfunction readBag()\n  local chaosbag = chaosBagApi.findChaosBag()\n  tokensInBag = {}\n\n  for _, token in ipairs(chaosbag.getObjects()) do\n    tokensInBag[token.name] = (tokensInBag[token.name] or 0) + 1\n  end\nend\n\nfunction resetSealedTokens()\n  sealedTokens = {}\n  updateSave()\nend\n\n-- native event from TTS - used to update the context menu for cards like \"Unrelenting\"\nfunction onHover()\n  if UPDATE_ON_HOVER then\n    readBag()\n    self.clearContextMenu()\n    generateContextMenu()\n  end\nend\n\n-- seals the named token on this card\nfunction sealToken(name, playerColor)\n  if #sealedTokens >= MAX_SEALED then\n    printToColor(\"Cannot seal any more tokens on this card\", playerColor, \"Red\")\n    return\n  end\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  local chaosbag = chaosBagApi.findChaosBag()\n  for i, obj in ipairs(chaosbag.getObjects()) do\n    if obj.name == name then\n      return chaosbag.takeObject({\n        position = self.getPosition() + Vector(0, 0.5 + 0.1 * #sealedTokens, 0),\n        rotation = self.getRotation(),\n        index = i - 1,\n        smooth = false,\n        callback_function = function(token)\n          local guid = token.getGUID()\n          table.insert(sealedTokens, guid)\n          tokenArrangerApi.layout()\n          if name == \"Bless\" or name == \"Curse\" then\n            blessCurseManagerApi.sealedToken(name, guid)\n          end\n          -- destroy XML on just covered token\n          if #sealedTokens > 1 then\n            local coveredToken = getObjectFromGUID(sealedTokens[#sealedTokens - 1])\n            if coveredToken ~= nil then\n              coveredToken.UI.setXml(\"\")\n            else\n              table.remove(sealedTokens, #sealedTokens - 1)\n            end\n          end\n          updateSave()\n        end\n      })\n    end\n  end\n  printToColor(name .. \" token not found in chaos bag\", playerColor)\nend\n\n-- release the last sealed token\nfunction releaseOneToken(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"No sealed token(s) found\", playerColor)\n  else\n    printToColor(\"Releasing token\", playerColor)\n\n    -- make list of token names\n    local tokenNames = {}\n    local differentNames = 0\n    for _, guid in ipairs(sealedTokens) do\n      local token = getObjectFromGUID(guid)\n      if token ~= nil then\n        local name = token.getName()\n        if tokenNames[name] == nil then\n          differentNames = differentNames + 1\n        end\n        tokenNames[name] = guid\n      end\n    end\n\n    -- if there are multiple tokens, ask the player to choose\n    if differentNames < 2 then\n      putTokenAway(table.remove(sealedTokens))\n      updateSave()\n    else\n      local choices = {}\n      for name, _ in pairs(tokenNames) do\n        table.insert(choices, name)\n      end\n      Player[playerColor].showOptionsDialog(\"Choose token to release:\", choices, 1, function(optionText, optionIndex)\n        for i = #sealedTokens, 1, -1 do\n          local token = getObjectFromGUID(sealedTokens[i])\n          if token ~= nil and token.getName() == optionText then\n            putTokenAway(table.remove(sealedTokens, i))\n            updateSave()\n            break\n          end\n        end\n      end)\n    end\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- release up to multiple tokens at once with no minimum\nfunction releaseMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n    return\n  end\n\n  local numRemoved = SHOW_MULTI_RELEASE\n  if #sealedTokens < SHOW_MULTI_RELEASE then\n    numRemoved = #sealedTokens\n  end\n\n  for i = 1, numRemoved do\n    putTokenAway(table.remove(sealedTokens))\n  end\n  updateSave()\n  printToColor(\"Releasing \" .. numRemoved .. \" tokens\", playerColor)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction releaseAllTokensWrapper(params)\n  releaseAllTokens(params.playerColor, _, _, params.filterName, params.silent)\nend\n\n-- releases all sealed tokens\nfunction releaseAllTokens(playerColor, _, _, filterName, silent)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    if not silent then\n      printToColor(\"No sealed token(s) found\", playerColor)\n    end\n  else\n    if not silent then\n      printToColor(\"Releasing token(s)\", playerColor)\n    end\n\n    for i = #sealedTokens, 1, -1 do\n      local success = putTokenAway(sealedTokens[i], filterName, silent)\n      if success then\n        table.remove(sealedTokens, i)\n      end\n    end\n\n    updateSave()\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns multiple tokens at once to the token pool (with minimum)\nfunction returnMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if SHOW_MULTI_RETURN <= #sealedTokens then\n    for i = 1, SHOW_MULTI_RETURN do\n      returnToken(table.remove(sealedTokens))\n    end\n    updateSave()\n    printToColor(\"Returning \" .. SHOW_MULTI_RETURN .. \" tokens to the token pool\", playerColor)\n  else\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns all sealed tokens to the token pool\nfunction returnAllTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  printToColor(\"Returning \" .. #sealedTokens .. \" tokens to the token pool\", playerColor)\n  for i = 1, #sealedTokens do\n    returnToken(table.remove(sealedTokens))\n  end\n  updateSave()\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns the token (referenced by GUID) to the chaos bag\n---@return boolean: True if a token was returned\nfunction putTokenAway(guid, filterName, silent)\n  local token = getObjectFromGUID(guid)\n  if not token then return false end\n\n  local name = token.getName()\n  if filterName and filterName ~= name then return false end\n\n  local chaosbag = chaosBagApi.findChaosBag()\n  chaosbag.putObject(token)\n\n  tokenArrangerApi.layout()\n\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.releasedToken(name, guid, nil, silent)\n  end\n\n  return true\nend\n\n-- returns the token to the pool (== removes it)\nfunction returnToken(guid)\n  local token = getObjectFromGUID(guid)\n  if not token then return end\n\n  local name = token.getName()\n  token.destruct()\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.returnedToken(name, guid)\n  end\nend\n\n-- resolves sealed token as if it came from the chaos bag\nfunction resolveSealed(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if #sealedTokens == 0 then\n    broadcastToAll(\"No tokens sealed.\", \"Red\")\n    return\n  end\n\n  -- make list of token names\n  local tokenNames = {}\n  local differentNames = 0\n  for _, guid in ipairs(sealedTokens) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      local name = token.getName()\n      if tokenNames[name] == nil then\n        differentNames = differentNames + 1\n      end\n      tokenNames[name] = guid\n    end\n  end\n\n  -- if there are multiple tokens, ask the player to choose\n  if differentNames < 2 then\n    resolveTokenByGuid(playerColor, table.remove(sealedTokens))\n    updateSave()\n  else\n    local choices = {}\n    for name, _ in pairs(tokenNames) do\n      table.insert(choices, name)\n    end\n    Player[playerColor].showOptionsDialog(\"Choose token to resolve:\", choices, 1, function(optionText, optionIndex)\n      for i = #sealedTokens, 1, -1 do\n        local token = getObjectFromGUID(sealedTokens[i])\n        if token ~= nil and token.getName() == optionText then\n          resolveTokenByGuid(playerColor, table.remove(sealedTokens, i))\n          updateSave()\n          return\n        end\n      end\n    end)\n  end\nend\n\nfunction resolveTokenByGuid(playerColor, guidToBeResolved)\n  local resolvedToken = getObjectFromGUID(guidToBeResolved)\n  if resolvedToken ~= nil then\n    resolvedToken.UI.setXml(\"\")\n  end\n\n  local closestMatColor = playermatApi.getMatColorByPosition(self.getPosition())\n  chaosBagApi.drawChaosToken(closestMatColor, true, _, guidToBeResolved)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction updateStackSize()\n  if MAX_SEALED == 1 then return end\n  if #sealedTokens == 0 then return end\n\n  -- get topmost sealed token\n  local topToken = getObjectFromGUID(sealedTokens[#sealedTokens])\n  if topToken == nil then return end\n\n  -- handling for two-digit numbers\n  local fontsize = 380\n  if #sealedTokens > 9 then\n    fontsize = 360\n  end\n\n  topToken.UI.setXmlTable({\n    {\n      tag = \"Panel\",\n      attributes = {\n        height = 380,\n        width = 380,\n        rotation = \"0 0 180\",\n        scale = \"0.2 0.2 1\",\n        position = \"0 0 -12\",\n        color = tokenColor[topToken.getName()] or \"#77674DE6\"\n      },\n      children = {\n        tag = \"Text\",\n        attributes = {\n          fontSize = fontsize,\n          font = \"font_teutonic-arkham\",\n          color = \"#ffffff\",\n          outline = \"#000000\",\n          outlineSize = \"8 -8\",\n          text = \"x\" .. #sealedTokens\n        }\n      }\n    }\n  })\nend\nend)\n__bundle_register(\"playercards/cards/SealTemplate\", function(require, _LOADED, __bundle_register, __bundle_modules)\nVALID_TOKENS = {}\n\nINVALID_TOKENS = {}\n\nUPDATE_ON_HOVER = true\n\n\n\n-- RESOLVE_TOKEN config\nRESOLVE_TOKEN = true\n\nrequire(\"playercards/CardsThatSealTokens\")\nend)\n__bundle_register(\"playermat/PlayermatApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local PlayermatApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n  local searchLib = require(\"util/SearchLib\")\n  local localInvestigatorPosition = { x = -1.17, y = 1, z = -0.01 }\n\n  -- Convenience function to look up a mat's object by color, or get all mats.\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@return table: Single-element if only single playermat is requested\n  local function getMatForColor(matColor)\n    if matColor == \"All\" then\n      return guidReferenceApi.getObjectsByType(\"Playermat\")\n    else\n      return { matColor = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\") }\n    end\n  end\n\n  -- Returns the color of the closest playermat\n  ---@param startPos table Starting position to get the closest mat from\n  PlayermatApi.getMatColorByPosition = function(startPos)\n    local result, smallestDistance\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local distance = Vector.between(startPos, mat.getPosition()):magnitude()\n      if smallestDistance == nil or distance < smallestDistance then\n        smallestDistance = distance\n        result = matColor\n      end\n    end\n    return result\n  end\n\n  -- Returns the color of the player's hand that is seated next to the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getPlayerColor = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getVar(\"playerColor\")\n    end\n  end\n\n  -- Returns the color of the playermat that owns the playercolor's hand\n  ---@param handColor string Color of the playermat\n  PlayermatApi.getMatColor = function(handColor)\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local playerColor = mat.getVar(\"playerColor\")\n      if playerColor == handColor then\n        return matColor\n      end\n    end\n    return nil\n  end\n\n  -- gets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getSlotData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getTable(\"slotData\")\n    end\n  end\n\n  -- sets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param newSlotData table New slot data for the playermat\n  PlayermatApi.loadSlotData = function(matColor, newSlotData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.setTable(\"slotData\", newSlotData)\n      mat.call(\"updateSave\")\n      mat.call(\"updateSlotSymbols\")\n      return\n    end\n  end\n\n  -- Performs a search of the deck area of the requested playermat and returns the result as table\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDeckAreaObjects = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getDeckAreaObjects\")\n    end\n  end\n\n  -- Flips the top card of the deck (useful after deck manipulation for Norman Withers)\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.flipTopCardFromDeck = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"flipTopCardFromDeck\")\n    end\n  end\n\n  -- Returns the position of the discard pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDiscardPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDiscardPosition\")\n    end\n  end\n\n  -- Returns the position of the draw pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDrawPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDrawPosition\")\n    end\n  end\n\n  -- Transforms a local position into a global position\n  ---@param localPos table Local position to be transformed\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.transformLocalPosition = function(localPos, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.positionToWorld(localPos)\n    end\n  end\n\n  -- Returns the rotation of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.returnRotation = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getRotation()\n    end\n  end\n\n  -- Returns a table with spawn data (position and rotation) for a helper object\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param helperName string Name of the helper object\n  PlayermatApi.getHelperSpawnData = function(matColor, helperName)\n    local resultTable = {}\n    local localPositionTable = {\n      [\"Hand Helper\"] = Vector(-0.055, 0, -1.132),\n      [\"Search Assistant\"] = Vector(-0.34, 0, -1.132)\n    }\n\n    for color, mat in pairs(getMatForColor(matColor)) do\n      resultTable[color] = {\n        position = mat.positionToWorld(localPositionTable[helperName]),\n        rotation = mat.getRotation()\n      }\n    end\n    return resultTable\n  end\n\n\n  -- Triggers the Upkeep for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param playerColor string Color of the calling player (for messages)\n  PlayermatApi.doUpkeepFromHotkey = function(matColor, playerColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doUpkeepFromHotkey\", playerColor)\n    end\n  end\n\n  -- Handles discarding for the requested playermat for the provided list of objects\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param objList table List of objects to discard\n  PlayermatApi.discardListOfObjects = function(matColor, objList)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"discardListOfObjects\", objList)\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getActiveInvestigatorData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getActiveInvestigatorData\")\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param newData table New active investigator data (class and id)\n  PlayermatApi.setActiveInvestigatorData = function(matColor, newData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setActiveInvestigatorData\", newData)\n    end\n  end\n\n  -- Returns the position for encounter card drawing\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param stack boolean If true, returns the leftmost position instead of the first empty from the right\n  PlayermatApi.getEncounterCardDrawPosition = function(matColor, stack)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return Vector(mat.call(\"getEncounterCardDrawPosition\", stack))\n    end\n  end\n\n  -- Sets the requested playermat's snap points to limit snapping to matching card types or not.  If\n  -- matchTypes is true, the main card slot snap points will only snap assets, while the\n  -- investigator area point will only snap Investigators.  If matchTypes is false, snap points will\n  -- be reset to snap all cards.\n  ---@param matchCardTypes boolean Whether snap points should only snap for the matching card types\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.setLimitSnapsByType = function(matchCardTypes, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setLimitSnapsByType\", matchCardTypes)\n    end\n  end\n\n  -- Sets the requested playermat's draw 1 button to visible\n  ---@param isDrawButtonVisible boolean Whether the draw 1 button should be visible or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.showDrawButton = function(isDrawButtonVisible, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"showDrawButton\", isDrawButtonVisible)\n    end\n  end\n\n  -- Shows or hides the clickable clue counter for the requested playermat\n  ---@param showCounter boolean Whether the clickable counter should be present or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.clickableClues = function(showCounter, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"clickableClues\", showCounter)\n    end\n  end\n\n  -- Toggles the use of class textures for the requested playermat\n  ---@param state boolean Whether the class texture should be used or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.useClassTexture = function(state, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"useClassTexture\", state)\n    end\n  end\n\n  -- updates the texture of the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param overrideName? string Force a specific texture\n  PlayermatApi.updateTexture = function(matColor, overrideName)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateTexture\", overrideName)\n    end\n  end\n\n  -- Removes all clues (to the trash for tokens and counters set to 0) for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.removeClues = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"removeClues\")\n    end\n  end\n\n  -- Reports the clue count for the requested playermat\n  ---@param useClickableCounters boolean Controls which type of counter is getting checked\n  PlayermatApi.getClueCount = function(useClickableCounters, matColor)\n    local count = 0\n    for _, mat in pairs(getMatForColor(matColor)) do\n      count = count + mat.call(\"getClueCount\", useClickableCounters)\n    end\n    return count\n  end\n\n  -- Updates the specified owned counter\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param type string Counter to target\n  ---@param newValue number Value to set the counter to\n  ---@param modifier number If newValue is not provided, the existing value will be adjusted by this modifier\n  PlayermatApi.updateCounter = function(matColor, type, newValue, modifier)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateCounter\", { type = type, newValue = newValue, modifier = modifier })\n    end\n  end\n\n  -- Triggers the draw function for the specified playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param number number Amount of cards to draw\n  PlayermatApi.drawCardsWithReshuffle = function(matColor, number)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"drawCardsWithReshuffle\", number)\n    end\n  end\n\n  -- Returns the resource counter amount\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param type string Counter to target\n  PlayermatApi.getCounterValue = function(matColor, type)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getCounterValue\", type)\n    end\n  end\n\n  -- Returns a list of mat colors that have an investigator placed\n  PlayermatApi.getUsedMatColors = function()\n    local usedColors = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        table.insert(usedColors, matColor)\n      end\n    end\n    return usedColors\n  end\n\n  -- Returns a list of investigator card objects\n  PlayermatApi.getUsedInvestigatorCards = function()\n    local usedCards = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        usedCards[matColor] = searchResult[1]\n      end\n    end\n    return usedCards\n  end\n\n  -- Returns investigator name\n  ---@param matColor string Color of the playmat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getInvestigatorName = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult == 1 then\n        return searchResult[1].getName()\n      end\n    end\n    return \"\"\n  end\n\n  -- Resets the specified skill tracker to \"1, 1, 1, 1\"\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.resetSkillTracker = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"resetSkillTracker\")\n    end\n  end\n\n  -- Updates the XML for the slot symbols based on the slotData table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.updateSlotSymbols = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateSlotSymbols\")\n    end\n  end\n\n  -- Finds all objects on the playermat and associated set aside zone and returns a table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param filter? string Name of the filte function (see util/SearchLib)\n  PlayermatApi.searchAroundPlayermat = function(matColor, filter)\n    local objList = {}\n    for _, mat in pairs(getMatForColor(matColor)) do\n      for _, obj in ipairs(mat.call(\"searchAroundSelf\", filter)) do\n        table.insert(objList, obj)\n      end\n    end\n    return objList\n  end\n\n  -- Discard a non-hidden card from the corresponding player's hand\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.doDiscardOne = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doDiscardOne\")\n    end\n  end\n\n  -- Spawns the regular action tokens\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.spawnActionTokens = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"spawnActionTokens\")\n    end\n  end\n\n  -- Triggers the metadata sync for all playermats\n  PlayermatApi.syncAllCustomizableCards = function()\n    for _, mat in pairs(getMatForColor(\"All\")) do\n      mat.call(\"syncAllCustomizableCards\")\n    end\n  end\n\n  -- moves + rotates a playermat (and related objects)\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param position? table New position for the playermat\n  ---@param rotationY? number New y-rotation for the playermat (X and Z will be 0)\n  ---@param positionOffset? table Positional offset for the playermat\n  PlayermatApi.moveAndRotate = function(matColor, position, rotationY, positionOffset)\n    -- get mat and related objects\n    local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\")\n    if not mat then return end\n\n    -- get current transform data\n    local currentMatPos = mat.getPosition()\n    local currentMatRotY = mat.getRotation().y\n\n    -- use current values if undefined\n    position = position or currentMatPos\n    rotationY = rotationY or currentMatRotY\n\n    if positionOffset then\n      position = Vector(position) + Vector(positionOffset)\n    end\n\n    local movedObjects = {}\n    local function moveAndRotateObject(obj)\n      local relativePos = obj.getPosition() - currentMatPos\n      obj.setPosition(position + relativePos:rotateOver(\"y\", rotationY - currentMatRotY))\n\n      if obj.type == \"Hand\" then\n        obj.setRotation({ 0, rotationY + 180, 0 })\n      else\n        local objRot = obj.getRotation()\n        local relativeRotY = objRot.y - currentMatRotY\n        obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })\n      end\n\n      movedObjects[obj.getGUID()] = true\n    end\n\n    -- get objects on the mat\n    for _, obj in ipairs(searchLib.onObject(mat, \"isInteractable\")) do\n      if not movedObjects[obj.getGUID()] then\n        -- make sure object isn't owned by another mat\n        local owner = guidReferenceApi.getOwnerOfObject(obj)\n        if owner == \"Mythos\" or owner == matColor then\n          moveAndRotateObject(obj)\n        end\n      end\n    end\n\n    -- move owned objects (including the mat)\n    for _, obj in pairs(guidReferenceApi.getObjectsByOwner(matColor)) do\n      if not movedObjects[obj.getGUID()] then\n        moveAndRotateObject(obj)\n      end\n    end\n  end\n\n  return PlayermatApi\nend\nend)\n__bundle_register(\"tokens/TokenArrangerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local TokenArrangerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  -- internal function to create a copy of the table to avoid operating on variables owned by different objects\n  local function deepCopy(data)\n    if type(data) ~= \"table\" then return data end\n    local copiedList = {}\n    for key, value in pairs(data) do\n      if type(value) == \"table\" then\n        copiedList[key] = deepCopy(value)\n      else\n        copiedList[key] = value\n      end\n    end\n    return copiedList\n  end\n\n  -- local function to call the token arranger, if it is on the table\n  ---@param functionName string Name of the function to cal\n  ---@param argument? table Parameter to pass\n  local function callIfExistent(functionName, argument)\n    local tokenArranger = guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"TokenArranger\")\n    if tokenArranger ~= nil then\n      return tokenArranger.call(functionName, argument)\n    end\n  end\n\n  -- updates the token modifiers with the provided data\n  ---@param fullData table Contains the chaos token metadata\n  TokenArrangerApi.onTokenDataChanged = function(fullData)\n    callIfExistent(\"onTokenDataChanged\", fullData)\n  end\n\n  -- deletes already laid out tokens\n  TokenArrangerApi.deleteCopiedTokens = function()\n    callIfExistent(\"deleteCopiedTokens\")\n  end\n\n  -- updates the laid out tokens\n  TokenArrangerApi.layout = function()\n    Wait.time(function() callIfExistent(\"layout\") end, 0.1)\n  end\n\n  TokenArrangerApi.getSaveData = function()\n    return deepCopy(callIfExistent(\"getSaveData\"))\n  end\n\n  TokenArrangerApi.loadData = function(loadedData)\n    callIfExistent(\"loadData\", loadedData)\n  end\n\n  return TokenArrangerApi\nend\nend)\n__bundle_register(\"util/SearchLib\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local SearchLib = {}\n  local filterFunctions = {\n    isCard = function(x) return x.type == \"Card\" end,\n    isDeck = function(x) return x.type == \"Deck\" end,\n    isCardOrDeck = function(x) return x.type == \"Card\" or x.type == \"Deck\" end,\n    isClue = function(x) return x.memo == \"clueDoom\" and x.is_face_down == false end,\n    isDoom = function(x) return x.memo == \"clueDoom\" and x.is_face_down == true end,\n    isInteractable = function(x) return x.interactable end,\n    isTileOrToken = function(x) return not x.Book and (x.type == \"Tile\" or x.type == \"Generic\") end,\n    isUniversalToken = function(x) return x.getMemo() == \"universalActionAbility\" end,\n  }\n\n  -- performs the actual search and returns a filtered list of object references\n  ---@param pos tts__Vector Global position\n  ---@param rot? tts__Vector Global rotation\n  ---@param size table Size\n  ---@param filter? string Name of the filter function\n  ---@param direction? table Direction (positive is up)\n  ---@param maxDistance? number Distance for the cast\n  local function returnSearchResult(pos, rot, size, filter, direction, maxDistance)\n    local filterFunc = filter and filterFunctions[filter]\n    local searchResult = Physics.cast({\n      origin       = pos,\n      direction    = direction or { 0, 1, 0 },\n      orientation  = rot or { 0, 0, 0 },\n      type         = 3,\n      size         = size,\n      max_distance = maxDistance or 0\n    })\n\n    -- filter the result for matching objects\n    local objList = {}\n    for _, v in ipairs(searchResult) do\n      if (not filter or filterFunc(v.hit_object)) then\n        table.insert(objList, v.hit_object)\n      end\n    end\n    return objList\n  end\n\n  -- searches the specified area\n  function SearchLib.inArea(pos, rot, size, filter)\n    return returnSearchResult(pos, rot, size, filter)\n  end\n\n  -- searches the area on an object\n  function SearchLib.onObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, 1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the area directly below an object\n  function SearchLib.belowObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, -1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the specified position (a single point)\n  function SearchLib.atPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches below the specified position (downwards until y = 0)\n  function SearchLib.belowPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    local direction = { 0, -1, 0 }\n    local maxDistance = pos.y\n    return returnSearchResult(pos, _, size, filter, direction, maxDistance)\n  end\n\n  return SearchLib\nend\nend)\nreturn __bundle_require(\"__root\")\n",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Master of Secrets",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 881000,
          "CustomDeck": {
            "8810": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419478/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/076.ProfessorCyrusDelane_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "Cult Epigrapher",
          "GMNotes": "{\n  \"id\": \"12963369-4690-4fef-8b1d-8789d3478659\",\n  \"type\": \"Asset\",\n  \"name\": \"Professor Cyrus Delane\",\n  \"traits\": \"Ally.Miskatonic.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "be6a74",
          "Name": "CardCustom",
          "Nickname": "Professor Cyrus Delane",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 113100,
          "CustomDeck": {
            "1131": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419481/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/077.SoporificGrimoire_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"631b3de0-7be9-412c-bf84-f642655b8a1b\",\n  \"type\": \"Asset\",\n  \"name\": \"Soporific Grimoire\",\n  \"traits\": \"Item.Tome.Relic.Occult.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "9bee40",
          "Name": "CardCustom",
          "Nickname": "Soporific Grimoire",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 583500,
          "CustomDeck": {
            "5835": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415064/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/078.TattoosoftheVoid_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"a644228e-24ea-4e43-b4b6-5cc723e70a2b\",\n  \"type\": \"Asset\",\n  \"traits\": \"Charm. Blessed.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "534c4b",
          "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"playercards/cards/SealTemplate\")\nend)\n__bundle_register(\"chaosbag/BlessCurseManagerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local BlessCurseManagerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  local function getManager()\n    return guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"BlessCurseManager\")\n  end\n\n  -- removes all taken tokens and resets the counts\n  BlessCurseManagerApi.removeTakenTokensAndReset = function()\n    local BlessCurseManager = getManager()\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Bless\") end, 0.05)\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Curse\") end, 0.10)\n    Wait.time(function() BlessCurseManager.call(\"doReset\", \"White\") end, 0.15)\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.sealedToken = function(type, guid, silent)\n    getManager().call(\"sealedToken\", { type = type, guid = guid, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param fromBag? boolean Whether or not token was just drawn from the chaos bag\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.releasedToken = function(type, guid, fromBag, silent)\n    getManager().call(\"releasedToken\", { type = type, guid = guid, fromBag = fromBag, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  BlessCurseManagerApi.returnedToken = function(type, guid)\n    getManager().call(\"returnedToken\", { type = type, guid = guid })\n  end\n\n  -- broadcasts the current status for bless/curse tokens\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.broadcastStatus = function(playerColor)\n    getManager().call(\"broadcastStatus\", playerColor)\n  end\n\n  -- removes all bless / curse tokens from the chaos bag and play\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.removeAll = function(playerColor)\n    getManager().call(\"doRemove\", playerColor)\n  end\n\n  -- adds bless / curse sealing to the hovered card\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param hoveredObject tts__Object Hovered object\n  ---@param noCurse? boolean True if just Bless sealing should be added (Parallel Mateo)\n  BlessCurseManagerApi.addBlurseSealingMenu = function(playerColor, hoveredObject, noCurse)\n    getManager().call(\"addMenuOptions\", { playerColor = playerColor, hoveredObject = hoveredObject, noCurse = noCurse })\n  end\n\n  -- adds bless / curse to the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.addToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = false })\n  end\n\n  -- removes bless / curse from the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.removeToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = true })\n  end\n\n  BlessCurseManagerApi.getBlessCurseInBag = function()\n    return getManager().call(\"getBlessCurseInBag\", {})\n  end\n\n  return BlessCurseManagerApi\nend\nend)\n__bundle_register(\"chaosbag/ChaosBagApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local ChaosBagApi = {}\n\n  -- respawns the chaos bag with a new state of tokens\n  ---@param tokenList table List of chaos token ids\n  ChaosBagApi.setChaosBagState = function(tokenList)\n    Global.call(\"setChaosBagState\", tokenList)\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getChaosBagState = function()\n    local chaosBagContentsCatcher = Global.call(\"getChaosBagState\")\n    local chaosBagContents = {}\n    for _, v in ipairs(chaosBagContentsCatcher) do\n      table.insert(chaosBagContents, v)\n    end\n    return chaosBagContents\n  end\n\n  -- checks scripting zone for chaos bag (also called by a lot of objects!)\n  ChaosBagApi.findChaosBag = function()\n    return Global.call(\"findChaosBag\")\n  end\n\n  -- returns a table of object references to the tokens in play (does not include sealed tokens!)\n  ChaosBagApi.getTokensInPlay = function()\n    return Global.call(\"getChaosTokensinPlay\")\n  end\n\n  -- returns all sealed tokens on cards to the chaos bag\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param filterName? string Name of the token to release\n  ---@param silent? boolean Whether or not to hide messages\n  ChaosBagApi.releaseAllSealedTokens = function(playerColor, filterName, silent)\n    Global.call(\"releaseAllSealedTokens\", { playerColor = playerColor, filterName = filterName, silent = silent })\n  end\n\n  -- returns all drawn tokens to the chaos bag\n  ChaosBagApi.returnChaosTokens = function()\n    Global.call(\"returnChaosTokens\")\n  end\n\n  -- removes the specified chaos token from the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.removeChaosToken = function(id)\n    Global.call(\"removeChaosToken\", id)\n  end\n\n  -- returns a chaos token to the bag and calls all relevant functions\n  ---@param token tts__Object Chaos token to return\n  ---@param fromBag boolean whether or not the token to return was in the middle of being drawn (true) or elsewhere (false)\n  ChaosBagApi.returnChaosTokenToBag = function(token, fromBag)\n    Global.call(\"returnChaosTokenToBag\", { token = token, fromBag = fromBag })\n  end\n\n  -- spawns the specified chaos token and puts it into the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.spawnChaosToken = function(id)\n    Global.call(\"spawnChaosToken\", id)\n  end\n\n  -- Checks to see if the chaos bag can be manipulated.  If a player is searching the bag when tokens\n  -- are drawn or replaced a TTS bug can cause those tokens to vanish.  Any functions which change the\n  -- contents of the bag should check this method before doing so.\n  -- This method will broadcast a message to all players if the bag is being searched.\n  ---@return any: True if the bag is manipulated, false if it should be blocked.\n  ChaosBagApi.canTouchChaosTokens = function()\n    return Global.call(\"canTouchChaosTokens\")\n  end\n\n  ChaosBagApi.activeRedrawEffect = function(validTokens, invalidTokens, returnToPool, drawSpecificToken)\n    Global.call(\"activeRedrawEffect\", {\n      validTokens = validTokens,\n      invalidTokens = invalidTokens,\n      returnToPool = returnToPool,\n      drawSpecificToken = drawSpecificToken\n    })\n  end\n\n  ChaosBagApi.getReadableTokenName = function(tokenName)\n    return Global.call(\"getReadableTokenName\", tokenName)\n  end\n\n  ChaosBagApi.getChaosTokenName = function(chosenToken)\n    return Global.call(\"getChaosTokenName\", chosenToken)\n  end\n\n  -- draws a chaos token to a playermat\n  ---@param mat tts__Object|string Playermat that triggered this (either object or matColor)\n  ---@param drawAdditional boolean Controls whether additional tokens should be drawn\n  ---@param tokenType? string Name of token (e.g. \"Bless\") to be drawn from the bag\n  ---@param guidToBeResolved? string GUID of the sealed token to be resolved instead of drawing a token from the bag\n  ---@param takeParameters? table Position and rotation of the location where the new token should be drawn to, usually to replace a returned token\n  ---@return tts__Object: Object reference to the token that was drawn\n  ChaosBagApi.drawChaosToken = function(mat, drawAdditional, tokenType, guidToBeResolved, takeParameters)\n    return Global.call(\"drawChaosToken\", {\n      mat              = mat,\n      drawAdditional   = drawAdditional,\n      tokenType        = tokenType,\n      guidToBeResolved = guidToBeResolved,\n      takeParameters   = takeParameters\n    })\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getIdUrlMap = function()\n    return Global.getTable(\"ID_URL_MAP\")\n  end\n\n  return ChaosBagApi\nend\nend)\n__bundle_register(\"core/GUIDReferenceApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local GUIDReferenceApi = {}\n\n  local function getGuidHandler()\n    return getObjectFromGUID(\"123456\")\n  end\n\n  -- Returns the matching object\n  ---@param owner string Parent object for this search\n  ---@param type string Type of object to search for\n  ---@return any: Object reference to the matching object\n  GUIDReferenceApi.getObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"getObjectByOwnerAndType\", { owner = owner, type = type })\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param type string Type of object to search for\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByType = function(type)\n    return getGuidHandler().call(\"getObjectsByType\", type)\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param owner string Parent object for this search\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByOwner = function(owner)\n    return getGuidHandler().call(\"getObjectsByOwner\", owner)\n  end\n\n  -- Sends new information to the reference handler to edit the main index (if type/guid are omitted, entry will be removed)\n  ---@param owner string Parent of the object\n  ---@param type? string Type of the object\n  ---@param guid? string GUID of the object\n  GUIDReferenceApi.editIndex = function(owner, type, guid)\n    return getGuidHandler().call(\"editIndex\", {\n      owner = owner,\n      type = type,\n      guid = guid\n    })\n  end\n\n  -- Returns the owner of an object or the object it's located on\n  ---@param object tts__GameObject Object for this search\n  ---@return string: Parent of the object or object it's located on\n  GUIDReferenceApi.getOwnerOfObject = function(object)\n    return getGuidHandler().call(\"getOwnerOfObject\", object)\n  end\n\n  -- Remove object\n  ---@param owner string Parent of the object\n  ---@param type string Type of the object\n  GUIDReferenceApi.removeObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"removeObjectByOwnerAndType\", {\n      owner = owner,\n      type = type\n    })\n  end\n\n  return GUIDReferenceApi\nend\nend)\n__bundle_register(\"playercards/CardsThatSealTokens\", function(require, _LOADED, __bundle_register, __bundle_modules)\n--[[ Library for cards that seal tokens\nThis file is used to add sealing option to cards' context menu.\nNOTE: all cards are allowed to release a single token to enable Hallow and A Watchful Peace,\nand to release all sealed tokens to allow for cards that might leave play with sealed tokens on them.\nValid options (set before requiring this file):\n\nMAX_SEALED          --@type: number (maximum number of tokens allowable by the card to be sealed)\n  - required for all cards\n  - if MAX_SEALED is more than 1, then an XML label is created for the topmost token indicating the number of sealed tokens\n  - gives an error if user tries to seal additional tokens on the card\n  - example usage: \"The Chthonian Stone\"\n    > MAX_SEALED = 1\n\nUPDATE_ON_HOVER     --@type: boolean\n  - automatically updates the context menu options when the card is hovered\n  - the \"Read Bag\" function reads the content of the chaos bag to update the context menu\n  - example usage: \"Unrelenting\" (to only display valid tokens)\n\nKEEP_OPEN           --@type: boolean\n- meant for cards that seal single tokens multiple times (one by one)\n- makes the context menu stay open after selecting an option\n- example usage: \"Unrelenting\"\n\nSHOW_MULTI_RELEASE  --@type: number (maximum amount of tokens to release at once)\n  - enables an entry in the context menu\n  - this entry allows releasing of multiple tokens at once, to the maximum number\n  - does not fail if there are fewer than the maximum sealed\n  - example usage: \"Nephthys\" (to release up to 3 bless tokens at once)\n\nSHOW_MULTI_RETURN   --@type: number (amount of tokens to return to pool at once)\n  - enables an entry in the context menu\n  - this entry allows returning tokens to the token pool\n  - fails if not enough tokens are sealed\n  - example usage: \"Nephthys\" (to return 3 bless tokens at once)\n\nSHOW_RETURN_ALL   --@boolean:\n  - enables an entry in the context menu\n  - this entry allows returning all sealed tokens to the token pool\n  - example usage: \"Radiant Smite\" (to return whatever number of bless tokens that are sealed at once)\n\nSHOW_MULTI_SEAL     --@type: number (amount of tokens to seal at once)\n  - enables an entry in the context menu\n  - this entry allows sealing of multiple tokens at once\n  - example usage: \"Holy Spear\" (to seal two bless tokens at once)\n\nVALID_TOKENS        --@type: table ([tokenName] = true)\n  - this table defines which tokens should be abled to be sealed\n  - needs to be defined for each card -> even if empty\n  - example usage: \"The Chthonian Stone\"\n    > VALID_TOKENS = {\n    >   [\"Skull\"]       = true,\n    >   [\"Cultist\"]     = true,\n    >   [\"Tablet\"]      = true,\n    >   [\"Elder Thing\"] = true,\n    > }\n\nINVALID_TOKENS      --@type: table ([tokenName] = true)\n  - this table defines which tokens are invalid for sealing\n  - only needs to be defined if needed\n  - usually combined with empty \"VALID_TOKENS\" table\n  - example usage: \"Protective Incantation\" (not allowed to seal Auto-fail)\n\n----------------------------------------------------------\nExample 1: Crystalline Elder Sign\nThis card can only seal the \"+1\" or \"Elder Sign\" token,\nit does not need specific options for multi-sealing or releasing.\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"+1\"] = true,\n  >   [\"Elder Sign\"] = true\n  > }\n  > MAX_SEALED = 1\n  > require...\n----------------------------------------------------------\nExample 2: Holy Spear\nThis card features the following abilities (just listing the relevant parts):\n- releasing a single bless token\n- sealing two bless tokens\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"Bless\"] = true\n  > }\n  > SHOW_MULTI_SEAL = 2\n  > MAX_SEALED = 10\n  > require...\n----------------------------------------------------------]]\n\nlocal blessCurseManagerApi = require(\"chaosbag/BlessCurseManagerApi\")\nlocal chaosBagApi          = require(\"chaosbag/ChaosBagApi\")\nlocal playermatApi         = require(\"playermat/PlayermatApi\")\nlocal tokenArrangerApi     = require(\"tokens/TokenArrangerApi\")\n\nlocal sealedTokens         = {}\nlocal ID_URL_MAP           = {}\nlocal tokensInBag          = {}\n\n-- XML background color for each token for label when stacked\nlocal tokenColor           = {\n  [\"Skull\"]       = \"#4A0400E6\",\n  [\"Cultist\"]     = \"#173B0BE6\",\n  [\"Tablet\"]      = \"#1D2238E6\",\n  [\"Elder Thing\"] = \"#4D2331E6\",\n  [\"Auto-fail\"]   = \"#9B0004E6\",\n  [\"Bless\"]       = \"#9D702CE6\",\n  [\"Curse\"]       = \"#633A84E6\",\n  [\"Frost\"]       = \"#404450E6\",\n  [\"Elder Sign\"]  = \"#50A8CEE6\",\n  [\"\"]            = \"#77674DE6\"\n}\n\nfunction updateSave()\n  updateStackSize()\n  self.script_state = JSON.encode(sealedTokens)\nend\n\nfunction onLoad(savedData)\n  -- if MAX_SEALED is not set, default to 99\n  MAX_SEALED = MAX_SEALED or 99\n\n  -- verify sealed tokens\n  for _, guid in ipairs(JSON.decode(savedData) or {}) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      table.insert(sealedTokens, guid)\n    end\n  end\n\n  ID_URL_MAP = chaosBagApi.getIdUrlMap()\n  generateContextMenu()\n  updateStackSize()\n  self.addTag(\"CardThatSeals\")\nend\n\n-- i18n menu labels (injected by generator)\nlocal MENU_RELEASE_ONE = \"Release one token\"\nlocal MENU_RELEASE_ONE_PREFIX = \"Release \"\nlocal MENU_RELEASE_ALL = \"Release all tokens\"\nlocal MENU_RELEASE_MULTI_PREFIX = \"Release \"\nlocal MENU_RETURN_MULTI_PREFIX = \"Return \"\nlocal MENU_TOKEN_SUFFIX = \" token(s)\"\nlocal MENU_RETURN_ALL = \"Return all tokens\"\nlocal MENU_RESOLVE_PREFIX = \"Resolve \"\nlocal MENU_RESOLVE_ONE = \"Resolve one token\"\nlocal MENU_RESOLVE_ONE_PREFIX = \"Resolve \"\nlocal MENU_SEAL_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_INFIX = \" \"\nlocal function TOKEN_DISPLAY(name) return name end\nlocal function TOKEN_DISPLAY_OR_DEFAULT(name, default) return (name and TOKEN_DISPLAY(name)) or default end\n\nlocal GENERIC_TOKEN_LABEL = \"token\"\n\n-- builds the context menu\nfunction generateContextMenu()\n  -- determine if exactly one valid token type is configured\n  local SINGLE_VALID_TOKEN = nil\n  for k, _ in pairs(VALID_TOKENS) do\n    if SINGLE_VALID_TOKEN == nil then\n      SINGLE_VALID_TOKEN = k\n    else\n      SINGLE_VALID_TOKEN = false -- more than one\n      break\n    end\n  end\n\n  local releaseOneLabel\n  if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n    releaseOneLabel = MENU_RELEASE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n  else\n    releaseOneLabel = MENU_RELEASE_ONE\n  end\n  self.addContextMenuItem(releaseOneLabel, releaseOneToken)\n\n  -- conditional release options\n  if MAX_SEALED > 1 then\n    self.addContextMenuItem(MENU_RELEASE_ALL, releaseAllTokens)\n  end\n\n  if SHOW_MULTI_RELEASE then\n    self.addContextMenuItem(MENU_RELEASE_MULTI_PREFIX .. SHOW_MULTI_RELEASE .. MENU_TOKEN_SUFFIX, releaseMultipleTokens)\n  end\n\n  if RESOLVE_TOKEN then\n    local resolveOneLabel\n    if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n      resolveOneLabel = MENU_RESOLVE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n    else\n      resolveOneLabel = MENU_RESOLVE_ONE\n    end\n    self.addContextMenuItem(resolveOneLabel, resolveSealed)\n  end\n\n  if SHOW_MULTI_RETURN then\n    self.addContextMenuItem(MENU_RETURN_MULTI_PREFIX .. SHOW_MULTI_RETURN .. MENU_TOKEN_SUFFIX, returnMultipleTokens)\n  end\n\n  if SHOW_RETURN_ALL then\n    self.addContextMenuItem(MENU_RETURN_ALL, returnAllTokens)\n  end\n\n  -- main context menu options to seal tokens\n  for _, map in pairs(ID_URL_MAP) do\n    if (VALID_TOKENS[map.name] ~= nil) or (UPDATE_ON_HOVER and tokensInBag[map.name] and INVALID_TOKENS and not INVALID_TOKENS[map.name]) then\n      if not SHOW_MULTI_SEAL then\n        self.addContextMenuItem(MENU_SEAL_PREFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          sealToken(map.name, playerColor)\n        end, KEEP_OPEN)\n      else\n        self.addContextMenuItem(MENU_SEAL_MULTI_PREFIX .. SHOW_MULTI_SEAL .. MENU_SEAL_MULTI_INFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          readBag()\n          local allowed = true\n          local notFound\n\n          for name, _ in pairs(VALID_TOKENS) do\n            if (tokensInBag[name] or 0) < SHOW_MULTI_SEAL then\n              allowed = false\n              notFound = name\n            end\n          end\n\n          if allowed then\n            for i = SHOW_MULTI_SEAL, 1, -1 do\n              sealToken(map.name, playerColor)\n            end\n          else\n            printToColor(\"Not enough \" .. notFound .. \" tokens in the chaos bag.\", playerColor)\n          end\n        end)\n      end\n    end\n  end\nend\n\n-- generates a list of chaos tokens that is in the chaos bag\nfunction readBag()\n  local chaosbag = chaosBagApi.findChaosBag()\n  tokensInBag = {}\n\n  for _, token in ipairs(chaosbag.getObjects()) do\n    tokensInBag[token.name] = (tokensInBag[token.name] or 0) + 1\n  end\nend\n\nfunction resetSealedTokens()\n  sealedTokens = {}\n  updateSave()\nend\n\n-- native event from TTS - used to update the context menu for cards like \"Unrelenting\"\nfunction onHover()\n  if UPDATE_ON_HOVER then\n    readBag()\n    self.clearContextMenu()\n    generateContextMenu()\n  end\nend\n\n-- seals the named token on this card\nfunction sealToken(name, playerColor)\n  if #sealedTokens >= MAX_SEALED then\n    printToColor(\"Cannot seal any more tokens on this card\", playerColor, \"Red\")\n    return\n  end\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  local chaosbag = chaosBagApi.findChaosBag()\n  for i, obj in ipairs(chaosbag.getObjects()) do\n    if obj.name == name then\n      return chaosbag.takeObject({\n        position = self.getPosition() + Vector(0, 0.5 + 0.1 * #sealedTokens, 0),\n        rotation = self.getRotation(),\n        index = i - 1,\n        smooth = false,\n        callback_function = function(token)\n          local guid = token.getGUID()\n          table.insert(sealedTokens, guid)\n          tokenArrangerApi.layout()\n          if name == \"Bless\" or name == \"Curse\" then\n            blessCurseManagerApi.sealedToken(name, guid)\n          end\n          -- destroy XML on just covered token\n          if #sealedTokens > 1 then\n            local coveredToken = getObjectFromGUID(sealedTokens[#sealedTokens - 1])\n            if coveredToken ~= nil then\n              coveredToken.UI.setXml(\"\")\n            else\n              table.remove(sealedTokens, #sealedTokens - 1)\n            end\n          end\n          updateSave()\n        end\n      })\n    end\n  end\n  printToColor(name .. \" token not found in chaos bag\", playerColor)\nend\n\n-- release the last sealed token\nfunction releaseOneToken(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"No sealed token(s) found\", playerColor)\n  else\n    printToColor(\"Releasing token\", playerColor)\n\n    -- make list of token names\n    local tokenNames = {}\n    local differentNames = 0\n    for _, guid in ipairs(sealedTokens) do\n      local token = getObjectFromGUID(guid)\n      if token ~= nil then\n        local name = token.getName()\n        if tokenNames[name] == nil then\n          differentNames = differentNames + 1\n        end\n        tokenNames[name] = guid\n      end\n    end\n\n    -- if there are multiple tokens, ask the player to choose\n    if differentNames < 2 then\n      putTokenAway(table.remove(sealedTokens))\n      updateSave()\n    else\n      local choices = {}\n      for name, _ in pairs(tokenNames) do\n        table.insert(choices, name)\n      end\n      Player[playerColor].showOptionsDialog(\"Choose token to release:\", choices, 1, function(optionText, optionIndex)\n        for i = #sealedTokens, 1, -1 do\n          local token = getObjectFromGUID(sealedTokens[i])\n          if token ~= nil and token.getName() == optionText then\n            putTokenAway(table.remove(sealedTokens, i))\n            updateSave()\n            break\n          end\n        end\n      end)\n    end\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- release up to multiple tokens at once with no minimum\nfunction releaseMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n    return\n  end\n\n  local numRemoved = SHOW_MULTI_RELEASE\n  if #sealedTokens < SHOW_MULTI_RELEASE then\n    numRemoved = #sealedTokens\n  end\n\n  for i = 1, numRemoved do\n    putTokenAway(table.remove(sealedTokens))\n  end\n  updateSave()\n  printToColor(\"Releasing \" .. numRemoved .. \" tokens\", playerColor)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction releaseAllTokensWrapper(params)\n  releaseAllTokens(params.playerColor, _, _, params.filterName, params.silent)\nend\n\n-- releases all sealed tokens\nfunction releaseAllTokens(playerColor, _, _, filterName, silent)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    if not silent then\n      printToColor(\"No sealed token(s) found\", playerColor)\n    end\n  else\n    if not silent then\n      printToColor(\"Releasing token(s)\", playerColor)\n    end\n\n    for i = #sealedTokens, 1, -1 do\n      local success = putTokenAway(sealedTokens[i], filterName, silent)\n      if success then\n        table.remove(sealedTokens, i)\n      end\n    end\n\n    updateSave()\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns multiple tokens at once to the token pool (with minimum)\nfunction returnMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if SHOW_MULTI_RETURN <= #sealedTokens then\n    for i = 1, SHOW_MULTI_RETURN do\n      returnToken(table.remove(sealedTokens))\n    end\n    updateSave()\n    printToColor(\"Returning \" .. SHOW_MULTI_RETURN .. \" tokens to the token pool\", playerColor)\n  else\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns all sealed tokens to the token pool\nfunction returnAllTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  printToColor(\"Returning \" .. #sealedTokens .. \" tokens to the token pool\", playerColor)\n  for i = 1, #sealedTokens do\n    returnToken(table.remove(sealedTokens))\n  end\n  updateSave()\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns the token (referenced by GUID) to the chaos bag\n---@return boolean: True if a token was returned\nfunction putTokenAway(guid, filterName, silent)\n  local token = getObjectFromGUID(guid)\n  if not token then return false end\n\n  local name = token.getName()\n  if filterName and filterName ~= name then return false end\n\n  local chaosbag = chaosBagApi.findChaosBag()\n  chaosbag.putObject(token)\n\n  tokenArrangerApi.layout()\n\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.releasedToken(name, guid, nil, silent)\n  end\n\n  return true\nend\n\n-- returns the token to the pool (== removes it)\nfunction returnToken(guid)\n  local token = getObjectFromGUID(guid)\n  if not token then return end\n\n  local name = token.getName()\n  token.destruct()\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.returnedToken(name, guid)\n  end\nend\n\n-- resolves sealed token as if it came from the chaos bag\nfunction resolveSealed(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if #sealedTokens == 0 then\n    broadcastToAll(\"No tokens sealed.\", \"Red\")\n    return\n  end\n\n  -- make list of token names\n  local tokenNames = {}\n  local differentNames = 0\n  for _, guid in ipairs(sealedTokens) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      local name = token.getName()\n      if tokenNames[name] == nil then\n        differentNames = differentNames + 1\n      end\n      tokenNames[name] = guid\n    end\n  end\n\n  -- if there are multiple tokens, ask the player to choose\n  if differentNames < 2 then\n    resolveTokenByGuid(playerColor, table.remove(sealedTokens))\n    updateSave()\n  else\n    local choices = {}\n    for name, _ in pairs(tokenNames) do\n      table.insert(choices, name)\n    end\n    Player[playerColor].showOptionsDialog(\"Choose token to resolve:\", choices, 1, function(optionText, optionIndex)\n      for i = #sealedTokens, 1, -1 do\n        local token = getObjectFromGUID(sealedTokens[i])\n        if token ~= nil and token.getName() == optionText then\n          resolveTokenByGuid(playerColor, table.remove(sealedTokens, i))\n          updateSave()\n          return\n        end\n      end\n    end)\n  end\nend\n\nfunction resolveTokenByGuid(playerColor, guidToBeResolved)\n  local resolvedToken = getObjectFromGUID(guidToBeResolved)\n  if resolvedToken ~= nil then\n    resolvedToken.UI.setXml(\"\")\n  end\n\n  local closestMatColor = playermatApi.getMatColorByPosition(self.getPosition())\n  chaosBagApi.drawChaosToken(closestMatColor, true, _, guidToBeResolved)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction updateStackSize()\n  if MAX_SEALED == 1 then return end\n  if #sealedTokens == 0 then return end\n\n  -- get topmost sealed token\n  local topToken = getObjectFromGUID(sealedTokens[#sealedTokens])\n  if topToken == nil then return end\n\n  -- handling for two-digit numbers\n  local fontsize = 380\n  if #sealedTokens > 9 then\n    fontsize = 360\n  end\n\n  topToken.UI.setXmlTable({\n    {\n      tag = \"Panel\",\n      attributes = {\n        height = 380,\n        width = 380,\n        rotation = \"0 0 180\",\n        scale = \"0.2 0.2 1\",\n        position = \"0 0 -12\",\n        color = tokenColor[topToken.getName()] or \"#77674DE6\"\n      },\n      children = {\n        tag = \"Text\",\n        attributes = {\n          fontSize = fontsize,\n          font = \"font_teutonic-arkham\",\n          color = \"#ffffff\",\n          outline = \"#000000\",\n          outlineSize = \"8 -8\",\n          text = \"x\" .. #sealedTokens\n        }\n      }\n    }\n  })\nend\nend)\n__bundle_register(\"playercards/cards/SealTemplate\", function(require, _LOADED, __bundle_register, __bundle_modules)\nVALID_TOKENS = {}\n\nINVALID_TOKENS = {}\n\nUPDATE_ON_HOVER = true\n\n\n\n-- RESOLVE_TOKEN config\nRESOLVE_TOKEN = true\n\nrequire(\"playercards/CardsThatSealTokens\")\nend)\n__bundle_register(\"playermat/PlayermatApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local PlayermatApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n  local searchLib = require(\"util/SearchLib\")\n  local localInvestigatorPosition = { x = -1.17, y = 1, z = -0.01 }\n\n  -- Convenience function to look up a mat's object by color, or get all mats.\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@return table: Single-element if only single playermat is requested\n  local function getMatForColor(matColor)\n    if matColor == \"All\" then\n      return guidReferenceApi.getObjectsByType(\"Playermat\")\n    else\n      return { matColor = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\") }\n    end\n  end\n\n  -- Returns the color of the closest playermat\n  ---@param startPos table Starting position to get the closest mat from\n  PlayermatApi.getMatColorByPosition = function(startPos)\n    local result, smallestDistance\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local distance = Vector.between(startPos, mat.getPosition()):magnitude()\n      if smallestDistance == nil or distance < smallestDistance then\n        smallestDistance = distance\n        result = matColor\n      end\n    end\n    return result\n  end\n\n  -- Returns the color of the player's hand that is seated next to the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getPlayerColor = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getVar(\"playerColor\")\n    end\n  end\n\n  -- Returns the color of the playermat that owns the playercolor's hand\n  ---@param handColor string Color of the playermat\n  PlayermatApi.getMatColor = function(handColor)\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local playerColor = mat.getVar(\"playerColor\")\n      if playerColor == handColor then\n        return matColor\n      end\n    end\n    return nil\n  end\n\n  -- gets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getSlotData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getTable(\"slotData\")\n    end\n  end\n\n  -- sets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param newSlotData table New slot data for the playermat\n  PlayermatApi.loadSlotData = function(matColor, newSlotData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.setTable(\"slotData\", newSlotData)\n      mat.call(\"updateSave\")\n      mat.call(\"updateSlotSymbols\")\n      return\n    end\n  end\n\n  -- Performs a search of the deck area of the requested playermat and returns the result as table\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDeckAreaObjects = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getDeckAreaObjects\")\n    end\n  end\n\n  -- Flips the top card of the deck (useful after deck manipulation for Norman Withers)\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.flipTopCardFromDeck = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"flipTopCardFromDeck\")\n    end\n  end\n\n  -- Returns the position of the discard pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDiscardPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDiscardPosition\")\n    end\n  end\n\n  -- Returns the position of the draw pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDrawPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDrawPosition\")\n    end\n  end\n\n  -- Transforms a local position into a global position\n  ---@param localPos table Local position to be transformed\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.transformLocalPosition = function(localPos, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.positionToWorld(localPos)\n    end\n  end\n\n  -- Returns the rotation of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.returnRotation = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getRotation()\n    end\n  end\n\n  -- Returns a table with spawn data (position and rotation) for a helper object\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param helperName string Name of the helper object\n  PlayermatApi.getHelperSpawnData = function(matColor, helperName)\n    local resultTable = {}\n    local localPositionTable = {\n      [\"Hand Helper\"] = Vector(-0.055, 0, -1.132),\n      [\"Search Assistant\"] = Vector(-0.34, 0, -1.132)\n    }\n\n    for color, mat in pairs(getMatForColor(matColor)) do\n      resultTable[color] = {\n        position = mat.positionToWorld(localPositionTable[helperName]),\n        rotation = mat.getRotation()\n      }\n    end\n    return resultTable\n  end\n\n\n  -- Triggers the Upkeep for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param playerColor string Color of the calling player (for messages)\n  PlayermatApi.doUpkeepFromHotkey = function(matColor, playerColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doUpkeepFromHotkey\", playerColor)\n    end\n  end\n\n  -- Handles discarding for the requested playermat for the provided list of objects\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param objList table List of objects to discard\n  PlayermatApi.discardListOfObjects = function(matColor, objList)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"discardListOfObjects\", objList)\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getActiveInvestigatorData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getActiveInvestigatorData\")\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param newData table New active investigator data (class and id)\n  PlayermatApi.setActiveInvestigatorData = function(matColor, newData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setActiveInvestigatorData\", newData)\n    end\n  end\n\n  -- Returns the position for encounter card drawing\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param stack boolean If true, returns the leftmost position instead of the first empty from the right\n  PlayermatApi.getEncounterCardDrawPosition = function(matColor, stack)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return Vector(mat.call(\"getEncounterCardDrawPosition\", stack))\n    end\n  end\n\n  -- Sets the requested playermat's snap points to limit snapping to matching card types or not.  If\n  -- matchTypes is true, the main card slot snap points will only snap assets, while the\n  -- investigator area point will only snap Investigators.  If matchTypes is false, snap points will\n  -- be reset to snap all cards.\n  ---@param matchCardTypes boolean Whether snap points should only snap for the matching card types\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.setLimitSnapsByType = function(matchCardTypes, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setLimitSnapsByType\", matchCardTypes)\n    end\n  end\n\n  -- Sets the requested playermat's draw 1 button to visible\n  ---@param isDrawButtonVisible boolean Whether the draw 1 button should be visible or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.showDrawButton = function(isDrawButtonVisible, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"showDrawButton\", isDrawButtonVisible)\n    end\n  end\n\n  -- Shows or hides the clickable clue counter for the requested playermat\n  ---@param showCounter boolean Whether the clickable counter should be present or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.clickableClues = function(showCounter, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"clickableClues\", showCounter)\n    end\n  end\n\n  -- Toggles the use of class textures for the requested playermat\n  ---@param state boolean Whether the class texture should be used or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.useClassTexture = function(state, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"useClassTexture\", state)\n    end\n  end\n\n  -- updates the texture of the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param overrideName? string Force a specific texture\n  PlayermatApi.updateTexture = function(matColor, overrideName)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateTexture\", overrideName)\n    end\n  end\n\n  -- Removes all clues (to the trash for tokens and counters set to 0) for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.removeClues = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"removeClues\")\n    end\n  end\n\n  -- Reports the clue count for the requested playermat\n  ---@param useClickableCounters boolean Controls which type of counter is getting checked\n  PlayermatApi.getClueCount = function(useClickableCounters, matColor)\n    local count = 0\n    for _, mat in pairs(getMatForColor(matColor)) do\n      count = count + mat.call(\"getClueCount\", useClickableCounters)\n    end\n    return count\n  end\n\n  -- Updates the specified owned counter\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param type string Counter to target\n  ---@param newValue number Value to set the counter to\n  ---@param modifier number If newValue is not provided, the existing value will be adjusted by this modifier\n  PlayermatApi.updateCounter = function(matColor, type, newValue, modifier)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateCounter\", { type = type, newValue = newValue, modifier = modifier })\n    end\n  end\n\n  -- Triggers the draw function for the specified playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param number number Amount of cards to draw\n  PlayermatApi.drawCardsWithReshuffle = function(matColor, number)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"drawCardsWithReshuffle\", number)\n    end\n  end\n\n  -- Returns the resource counter amount\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param type string Counter to target\n  PlayermatApi.getCounterValue = function(matColor, type)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getCounterValue\", type)\n    end\n  end\n\n  -- Returns a list of mat colors that have an investigator placed\n  PlayermatApi.getUsedMatColors = function()\n    local usedColors = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        table.insert(usedColors, matColor)\n      end\n    end\n    return usedColors\n  end\n\n  -- Returns a list of investigator card objects\n  PlayermatApi.getUsedInvestigatorCards = function()\n    local usedCards = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        usedCards[matColor] = searchResult[1]\n      end\n    end\n    return usedCards\n  end\n\n  -- Returns investigator name\n  ---@param matColor string Color of the playmat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getInvestigatorName = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult == 1 then\n        return searchResult[1].getName()\n      end\n    end\n    return \"\"\n  end\n\n  -- Resets the specified skill tracker to \"1, 1, 1, 1\"\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.resetSkillTracker = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"resetSkillTracker\")\n    end\n  end\n\n  -- Updates the XML for the slot symbols based on the slotData table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.updateSlotSymbols = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateSlotSymbols\")\n    end\n  end\n\n  -- Finds all objects on the playermat and associated set aside zone and returns a table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param filter? string Name of the filte function (see util/SearchLib)\n  PlayermatApi.searchAroundPlayermat = function(matColor, filter)\n    local objList = {}\n    for _, mat in pairs(getMatForColor(matColor)) do\n      for _, obj in ipairs(mat.call(\"searchAroundSelf\", filter)) do\n        table.insert(objList, obj)\n      end\n    end\n    return objList\n  end\n\n  -- Discard a non-hidden card from the corresponding player's hand\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.doDiscardOne = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doDiscardOne\")\n    end\n  end\n\n  -- Spawns the regular action tokens\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.spawnActionTokens = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"spawnActionTokens\")\n    end\n  end\n\n  -- Triggers the metadata sync for all playermats\n  PlayermatApi.syncAllCustomizableCards = function()\n    for _, mat in pairs(getMatForColor(\"All\")) do\n      mat.call(\"syncAllCustomizableCards\")\n    end\n  end\n\n  -- moves + rotates a playermat (and related objects)\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param position? table New position for the playermat\n  ---@param rotationY? number New y-rotation for the playermat (X and Z will be 0)\n  ---@param positionOffset? table Positional offset for the playermat\n  PlayermatApi.moveAndRotate = function(matColor, position, rotationY, positionOffset)\n    -- get mat and related objects\n    local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\")\n    if not mat then return end\n\n    -- get current transform data\n    local currentMatPos = mat.getPosition()\n    local currentMatRotY = mat.getRotation().y\n\n    -- use current values if undefined\n    position = position or currentMatPos\n    rotationY = rotationY or currentMatRotY\n\n    if positionOffset then\n      position = Vector(position) + Vector(positionOffset)\n    end\n\n    local movedObjects = {}\n    local function moveAndRotateObject(obj)\n      local relativePos = obj.getPosition() - currentMatPos\n      obj.setPosition(position + relativePos:rotateOver(\"y\", rotationY - currentMatRotY))\n\n      if obj.type == \"Hand\" then\n        obj.setRotation({ 0, rotationY + 180, 0 })\n      else\n        local objRot = obj.getRotation()\n        local relativeRotY = objRot.y - currentMatRotY\n        obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })\n      end\n\n      movedObjects[obj.getGUID()] = true\n    end\n\n    -- get objects on the mat\n    for _, obj in ipairs(searchLib.onObject(mat, \"isInteractable\")) do\n      if not movedObjects[obj.getGUID()] then\n        -- make sure object isn't owned by another mat\n        local owner = guidReferenceApi.getOwnerOfObject(obj)\n        if owner == \"Mythos\" or owner == matColor then\n          moveAndRotateObject(obj)\n        end\n      end\n    end\n\n    -- move owned objects (including the mat)\n    for _, obj in pairs(guidReferenceApi.getObjectsByOwner(matColor)) do\n      if not movedObjects[obj.getGUID()] then\n        moveAndRotateObject(obj)\n      end\n    end\n  end\n\n  return PlayermatApi\nend\nend)\n__bundle_register(\"tokens/TokenArrangerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local TokenArrangerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  -- internal function to create a copy of the table to avoid operating on variables owned by different objects\n  local function deepCopy(data)\n    if type(data) ~= \"table\" then return data end\n    local copiedList = {}\n    for key, value in pairs(data) do\n      if type(value) == \"table\" then\n        copiedList[key] = deepCopy(value)\n      else\n        copiedList[key] = value\n      end\n    end\n    return copiedList\n  end\n\n  -- local function to call the token arranger, if it is on the table\n  ---@param functionName string Name of the function to cal\n  ---@param argument? table Parameter to pass\n  local function callIfExistent(functionName, argument)\n    local tokenArranger = guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"TokenArranger\")\n    if tokenArranger ~= nil then\n      return tokenArranger.call(functionName, argument)\n    end\n  end\n\n  -- updates the token modifiers with the provided data\n  ---@param fullData table Contains the chaos token metadata\n  TokenArrangerApi.onTokenDataChanged = function(fullData)\n    callIfExistent(\"onTokenDataChanged\", fullData)\n  end\n\n  -- deletes already laid out tokens\n  TokenArrangerApi.deleteCopiedTokens = function()\n    callIfExistent(\"deleteCopiedTokens\")\n  end\n\n  -- updates the laid out tokens\n  TokenArrangerApi.layout = function()\n    Wait.time(function() callIfExistent(\"layout\") end, 0.1)\n  end\n\n  TokenArrangerApi.getSaveData = function()\n    return deepCopy(callIfExistent(\"getSaveData\"))\n  end\n\n  TokenArrangerApi.loadData = function(loadedData)\n    callIfExistent(\"loadData\", loadedData)\n  end\n\n  return TokenArrangerApi\nend\nend)\n__bundle_register(\"util/SearchLib\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local SearchLib = {}\n  local filterFunctions = {\n    isCard = function(x) return x.type == \"Card\" end,\n    isDeck = function(x) return x.type == \"Deck\" end,\n    isCardOrDeck = function(x) return x.type == \"Card\" or x.type == \"Deck\" end,\n    isClue = function(x) return x.memo == \"clueDoom\" and x.is_face_down == false end,\n    isDoom = function(x) return x.memo == \"clueDoom\" and x.is_face_down == true end,\n    isInteractable = function(x) return x.interactable end,\n    isTileOrToken = function(x) return not x.Book and (x.type == \"Tile\" or x.type == \"Generic\") end,\n    isUniversalToken = function(x) return x.getMemo() == \"universalActionAbility\" end,\n  }\n\n  -- performs the actual search and returns a filtered list of object references\n  ---@param pos tts__Vector Global position\n  ---@param rot? tts__Vector Global rotation\n  ---@param size table Size\n  ---@param filter? string Name of the filter function\n  ---@param direction? table Direction (positive is up)\n  ---@param maxDistance? number Distance for the cast\n  local function returnSearchResult(pos, rot, size, filter, direction, maxDistance)\n    local filterFunc = filter and filterFunctions[filter]\n    local searchResult = Physics.cast({\n      origin       = pos,\n      direction    = direction or { 0, 1, 0 },\n      orientation  = rot or { 0, 0, 0 },\n      type         = 3,\n      size         = size,\n      max_distance = maxDistance or 0\n    })\n\n    -- filter the result for matching objects\n    local objList = {}\n    for _, v in ipairs(searchResult) do\n      if (not filter or filterFunc(v.hit_object)) then\n        table.insert(objList, v.hit_object)\n      end\n    end\n    return objList\n  end\n\n  -- searches the specified area\n  function SearchLib.inArea(pos, rot, size, filter)\n    return returnSearchResult(pos, rot, size, filter)\n  end\n\n  -- searches the area on an object\n  function SearchLib.onObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, 1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the area directly below an object\n  function SearchLib.belowObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, -1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the specified position (a single point)\n  function SearchLib.atPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches below the specified position (downwards until y = 0)\n  function SearchLib.belowPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    local direction = { 0, -1, 0 }\n    local maxDistance = pos.y\n    return returnSearchResult(pos, _, size, filter, direction, maxDistance)\n  end\n\n  return SearchLib\nend\nend)\nreturn __bundle_require(\"__root\")\n",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Tattoos of the Void",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 108100,
          "CustomDeck": {
            "1081": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419485/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/079.BurdenofSouls_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"195aecd3-5cb5-4962-b4bd-8eed931a5565\",\n  \"type\": \"Event\",\n  \"name\": \"Burden of Souls\",\n  \"traits\": \"Spell.Spirit.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "c853e9",
          "Name": "CardCustom",
          "Nickname": "Burden of Souls",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 240200,
          "CustomDeck": {
            "2402": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419487/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/080.InscriptionofPower_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f987fdca-7704-426f-abc1-97b4a5bf5df2\",\n  \"type\": \"Event\",\n  \"name\": \"Inscription of Power\",\n  \"traits\": \"Ritual.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "5e2589",
          "Name": "CardCustom",
          "Nickname": "Inscription of Power",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 845400,
          "CustomDeck": {
            "8454": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419489/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/081.Spellshifting_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"4d982555-89c2-45f1-a5ae-c25d35ffc17d\",\n  \"type\": \"Event\",\n  \"name\": \"Spellshifting\",\n  \"traits\": \"Spell.Ritual.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "7f6cb6",
          "Name": "CardCustom",
          "Nickname": "Spellshifting",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 578400,
          "CustomDeck": {
            "5784": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419492/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/082.Imbue_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"1441364e-7f05-4a0a-a786-31a95fe1b317\",\n  \"type\": \"Skill\",\n  \"name\": \"Imbue\",\n  \"traits\": \"Practiced.\",\n  \"class\": \"Mystic\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "65fc6d",
          "Name": "CardCustom",
          "Nickname": "Imbue",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 319900,
          "CustomDeck": {
            "3199": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419494/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/083.BindthePulseofTime_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"047c2abb-cea9-4f98-b5ee-710d5539bf94\",\n  \"type\": \"Event\",\n  \"name\": \"Bind the Pulse of Time\",\n  \"traits\": \"Spell.Insight.\",\n  \"class\": \"Mystic\",\n  \"level\": 1,\n  \"cost\": 1\n}",
          "GUID": "5d3515",
          "Name": "CardCustom",
          "Nickname": "Bind the Pulse of Time",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 105700,
          "CustomDeck": {
            "1057": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419496/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/084.PriceofClarity_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"872fdbfc-244b-4001-9c6a-5431b2f3c9fa\",\n  \"type\": \"Skill\",\n  \"name\": \"Price of Clarity\",\n  \"traits\": \"Innate.Cursed.\",\n  \"class\": \"Mystic\",\n  \"level\": 1,\n  \"cost\": -1\n}",
          "GUID": "9e4647",
          "Name": "CardCustom",
          "Nickname": "Price of Clarity",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 362400,
          "CustomDeck": {
            "3624": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415067/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/085.ForbiddenKnowledge_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"402a0e08-fd2f-4265-82bf-b0c730384191\",\n  \"type\": \"Asset\",\n  \"name\": \"Forbidden Knowledge\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Mystic\",\n  \"level\": 2,\n  \"cost\": 0,\n  \"uses\": [\n    {\n      \"count\": 4,\n      \"type\": \"Secret\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "fa179d",
          "Name": "CardCustom",
          "Nickname": "Forbidden Knowledge",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 476100,
          "CustomDeck": {
            "4761": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419500/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/086.VesselofAgonies_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b895ff2e-d029-46a6-9075-3ae9bd2acb43\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Vessel of Agonies\",\n  \"traits\": \"Item.Relic.Cursed.\",\n  \"class\": \"Mystic\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "a83146",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Vessel of Agonies",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 894600,
          "CustomDeck": {
            "8946": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419502/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/087.DrawnbyProphecy_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"9d384665-fa53-40e8-b297-4386bbfac2fd\",\n  \"type\": \"Event\",\n  \"name\": \"Drawn by Prophecy\",\n  \"traits\": \"Spell.Insight.\",\n  \"class\": \"Mystic\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "cc91fe",
          "Name": "CardCustom",
          "Nickname": "Drawn by Prophecy",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 230600,
          "CustomDeck": {
            "2306": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415070/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/088.BlessingoftheOccult_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2bbfffba-21a0-4bb0-9c1e-7edc9b1846ea\",\n  \"type\": \"Asset\",\n  \"name\": \"Blessing of the Occult\",\n  \"traits\": \"Augury.Spell.Occult.\",\n  \"class\": \"Mystic\",\n  \"level\": 3,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 5,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "7b3516",
          "Name": "CardCustom",
          "Nickname": "Blessing of the Occult",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 904100,
          "CustomDeck": {
            "9041": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415073/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/089.EyesThroughtheVeil_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"dd24b4e3-b6f4-43d9-99c0-ab174e03f44b\",\n  \"type\": \"Asset\",\n  \"name\": \"Eyes Through the Veil\",\n  \"traits\": \"Spell.\",\n  \"class\": \"Mystic\",\n  \"level\": 3,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 5,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "885fe3",
          "Name": "CardCustom",
          "Nickname": "Eyes Through the Veil",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 332700,
          "CustomDeck": {
            "3327": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419508/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/090.Fearless_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"86df6f24-85f9-4a61-9cad-b938a48e2ac5\",\n  \"type\": \"Skill\",\n  \"name\": \"Fearless\",\n  \"traits\": \"Innate.Developed.\",\n  \"class\": \"Mystic\",\n  \"level\": 3,\n  \"cost\": -1\n}",
          "GUID": "b8c5a8",
          "Name": "CardCustom",
          "Nickname": "Fearless",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 781300,
          "CustomDeck": {
            "7813": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419510/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/091.InscriptionofPower_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"cdcc7546-3ada-4a26-a7ff-a6b15711cd71\",\n  \"type\": \"Event\",\n  \"name\": \"Inscription of Power\",\n  \"traits\": \"Ritual.\",\n  \"class\": \"Mystic\",\n  \"level\": 4,\n  \"cost\": 3\n}",
          "GUID": "64670b",
          "Name": "CardCustom",
          "Nickname": "Inscription of Power",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 651000,
          "CustomDeck": {
            "6510": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763416114/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/016.Yithian_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763416111/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/016.Yithian_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "A Curious Explorer",
          "GMNotes": "{\n  \"id\": \"2f687951-04fa-40ba-b21a-9c2cf4c2e9e2\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Monster. Yithian.\",\n  \"class\": \"Neutral\",\n  \"willpowerIcons\": 2,\n  \"intellectIcons\": 2,\n  \"combatIcons\": 2,\n  \"agilityIcons\": 2,\n  \"extraToken\": \"None\",\n  \"signatures\": [\n    {\n      \"9189bc89-5511-49ad-a1fa-218f58d44fe5\": 1,\n      \"70ccabf5-4f44-4ec2-b677-fa54ce9a864f\": 1\n    }\n  ]\n}",
          "GUID": "97a13c",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…Yithian",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 278200,
          "CustomDeck": {
            "2782": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415075/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/017.ThirstforKnowledge_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "There's nothing you can't learn",
          "GMNotes": "{\n  \"id\": \"9189bc89-5511-49ad-a1fa-218f58d44fe5\",\n  \"type\": \"Asset\",\n  \"name\": \"Thirst for Knowledge\",\n  \"traits\": \"Yithian.\",\n  \"class\": \"Neutral\",\n  \"level\": -1,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "251fdb",
          "Name": "CardCustom",
          "Nickname": "Thirst for Knowledge",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 873800,
          "CustomDeck": {
            "8738": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419521/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/018.ForgottenKnowledge_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"70ccabf5-4f44-4ec2-b677-fa54ce9a864f\",\n  \"type\": \"Treachery\",\n  \"name\": \"Forgotten Knowledge\",\n  \"traits\": \"Yithian.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "7e94d5",
          "Name": "CardCustom",
          "Nickname": "Forgotten Knowledge",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 675700,
          "CustomDeck": {
            "6757": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415078/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/110.Bait_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"fc7ec242-387e-4011-a0aa-54fcd1f7dc36\",\n  \"type\": \"Asset\",\n  \"name\": \"Bait\",\n  \"traits\": \"Item.Tool.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 2,\n      \"type\": \"Supply\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "ae1bc4",
          "Name": "CardCustom",
          "Nickname": "Bait",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 711400,
          "CustomDeck": {
            "7114": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419525/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/113.ForgottenBlueprint_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"c54287e6-8eb4-473d-858e-6c84e76ab496\",\n  \"type\": \"Asset\",\n  \"name\": \"Forgotten Blueprint\",\n  \"traits\": \"Item.Relic.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "badf6b",
          "Name": "CardCustom",
          "Nickname": "Forgotten Blueprint",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 706600,
          "CustomDeck": {
            "7066": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419528/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/114.OldSchematics_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"3cf57ade-f435-4bed-8277-b9158d1c8dfa\",\n  \"type\": \"Asset\",\n  \"name\": \"Old Schematics\",\n  \"traits\": \"Item.Relic.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "956213",
          "Name": "CardCustom",
          "Nickname": "Old Schematics",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 518900,
          "CustomDeck": {
            "5189": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415081/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/119.Bait_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"9d69e362-18e5-425b-b31e-35d64474af27\",\n  \"type\": \"Asset\",\n  \"name\": \"Bait\",\n  \"traits\": \"Item.Tool.\",\n  \"class\": \"Neutral\",\n  \"level\": 2,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 2,\n      \"type\": \"Supply\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "35c7b8",
          "Name": "CardCustom",
          "Nickname": "Bait",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 108400,
          "CustomDeck": {
            "1084": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419532/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/120.Kukri_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"518d7894-fdd5-4047-861e-ed06a47398f2\",\n  \"type\": \"Asset\",\n  \"name\": \"Kukri\",\n  \"traits\": \"Item.Weapon.Melee.\",\n  \"class\": \"Neutral\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "cf66b1",
          "Name": "CardCustom",
          "Nickname": "Kukri",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 930700,
          "CustomDeck": {
            "9307": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419534/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/121.RecursiveDirective_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b00ca6a6-40c3-4653-b345-0f764deb17ee\",\n  \"type\": \"Event\",\n  \"name\": \"Recursive Directive\",\n  \"traits\": \"Tactic.Fated.\",\n  \"class\": \"Neutral\",\n  \"level\": 3,\n  \"cost\": 1,\n  \"victory\": 1\n}",
          "GUID": "53b1c7",
          "Name": "CardCustom",
          "Nickname": "Recursive Directive",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 529800,
          "CustomDeck": {
            "5298": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415083/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/111.BoundtoYou_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2095e49c-bd12-4ddb-a4a4-c72a81f2b039\",\n  \"type\": \"Asset\",\n  \"name\": \"Bound to You\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "e657f5",
          "Name": "CardCustom",
          "Nickname": "Bound to You",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 270800,
          "CustomDeck": {
            "2708": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415086/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/112.CollateralDamage_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"1cea414e-217c-4b52-b268-c02121dc136d\",\n  \"type\": \"Asset\",\n  \"name\": \"Collateral Damage\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "74f499",
          "Name": "CardCustom",
          "Nickname": "Collateral Damage",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 357300,
          "CustomDeck": {
            "3573": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415090/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/115.PactofEndurance_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"df48250b-120a-47d5-b704-32cab6f6a3d6\",\n  \"type\": \"Asset\",\n  \"name\": \"Pact of Endurance\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "211585",
          "Name": "CardCustom",
          "Nickname": "Pact of Endurance",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 272200,
          "CustomDeck": {
            "2722": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415092/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/116.ReversalofSigns_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"4b37aaa1-86bb-47f4-a213-989c826506c0\",\n  \"type\": \"Asset\",\n  \"name\": \"Reversal of Signs\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "3a1751",
          "Name": "CardCustom",
          "Nickname": "Reversal of Signs",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 294400,
          "CustomDeck": {
            "2944": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415096/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/117.TheElderSign_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "Sigil of Kish",
          "GMNotes": "{\n  \"id\": \"97e40858-5059-4efc-8d36-bd06da6598a1\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…The Elder Sign\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "c794b3",
          "Name": "CardCustom",
          "Nickname": "ðŸ…The Elder Sign",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 439200,
          "CustomDeck": {
            "4392": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415098/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/118.TheThirteenthAppendix_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"fe53cec4-7a5a-49b0-a81b-aae7189c7de3\",\n  \"type\": \"Asset\",\n  \"name\": \"The Thirteenth Appendix\",\n  \"traits\": \"Contract.\",\n  \"class\": \"Neutral\",\n  \"level\": 0,\n  \"cost\": -1,\n  \"startsInPlay\": true\n}",
          "GUID": "76ca24",
          "Name": "CardCustom",
          "Nickname": "The Thirteenth Appendix",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 349900,
          "CustomDeck": {
            "3499": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419550/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/122.BrokenSeal_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6f078742-9846-48ef-bf79-3c2716fa2f94\",\n  \"type\": \"Asset\",\n  \"name\": \"Broken Seal\",\n  \"traits\": \"Omen.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "ec4ae0",
          "Name": "CardCustom",
          "Nickname": "Broken Seal",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 224100,
          "CustomDeck": {
            "2241": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419552/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/123.SlipperyGrip_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"5a36dddf-e339-4a15-a575-f39b7226a4ef\",\n  \"type\": \"Asset\",\n  \"name\": \"Slippery Grip\",\n  \"traits\": \"Curse.Blunder.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "468d52",
          "Name": "CardCustom",
          "Nickname": "Slippery Grip",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 612300,
          "CustomDeck": {
            "6123": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419554/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/124.TurnedCoat_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"648efc85-f82f-4e8c-9145-f104664bd82a\",\n  \"type\": \"Asset\",\n  \"name\": \"Turned Coat\",\n  \"traits\": \"Madness.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "daa567",
          "Name": "CardCustom",
          "Nickname": "Turned Coat",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 475700,
          "CustomDeck": {
            "4757": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415104/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/007.SkidsOToole_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415101/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/007.SkidsOToole_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "The Ex-Con",
          "GMNotes": "{\n  \"id\": \"48bd399e-1d7d-4b95-8a88-1145f95eae14\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Criminal.\",\n  \"class\": \"Rogue\",\n  \"willpowerIcons\": 2,\n  \"intellectIcons\": 2,\n  \"combatIcons\": 3,\n  \"agilityIcons\": 5,\n  \"extraToken\": \"Rogue\",\n  \"signatures\": [\n    {\n      \"c9e03dde-f067-48a5-8063-839f82167d9c\": 1,\n      \"45be196b-4f6a-494d-85c9-3b2521e7d557\": 1\n    }\n  ]\n}",
          "GUID": "61f987",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…\"Skids\" O'Toole",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 823800,
          "CustomDeck": {
            "8238": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415108/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/008.OntheLam_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"c9e03dde-f067-48a5-8063-839f82167d9c\",\n  \"type\": \"Asset\",\n  \"traits\": \"Talent. Illicit.\",\n  \"class\": \"Neutral\",\n  \"cost\": 3\n}",
          "GUID": "e29073",
          "Name": "CardCustom",
          "Nickname": "On the Lam",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 519400,
          "CustomDeck": {
            "5194": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415110/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/009.HospitalDebts_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"45be196b-4f6a-494d-85c9-3b2521e7d557\",\n  \"type\": \"Treachery\",\n  \"name\": \"Hospital Debts\",\n  \"traits\": \"Task.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Resource\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "649737",
          "Name": "CardCustom",
          "Nickname": "Hospital Debts",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 723600,
          "CustomDeck": {
            "7236": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419568/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/056.Informant_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"a510f888-7351-4f79-a4a6-cb2d609fa8c1\",\n  \"type\": \"Asset\",\n  \"name\": \"Informant\",\n  \"traits\": \"Ally.Criminal.Assistant.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "21e664",
          "Name": "CardCustom",
          "Nickname": "Informant",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 312500,
          "CustomDeck": {
            "3125": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419569/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/057.MollyBrown_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "Admirable Philanthropist ",
          "GMNotes": "{\n  \"id\": \"8771bf35-8518-4d76-a647-b798148b7d75\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Molly Brown\",\n  \"traits\": \"Ally.Socialite.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "edbab2",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Molly Brown",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 901200,
          "CustomDeck": {
            "9012": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419572/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/058.FlashofWealth_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"a2c0589e-298e-4d39-a102-9062f57461ce\",\n  \"type\": \"Event\",\n  \"name\": \"Flash of Wealth\",\n  \"traits\": \"Insight.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "925a79",
          "Name": "CardCustom",
          "Nickname": "Flash of Wealth",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 617000,
          "CustomDeck": {
            "6170": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419574/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/059.Intimidate_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"28ede381-c0ee-4e32-b704-3538447c2412\",\n  \"type\": \"Event\",\n  \"name\": \"Intimidate\",\n  \"traits\": \"Tactic.Illicit.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "7af8b7",
          "Name": "CardCustom",
          "Nickname": "Intimidate",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 230000,
          "CustomDeck": {
            "2300": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419575/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/060.LastDitchEffort_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f108dfc9-dea7-42e8-acab-a0ef7475930b\",\n  \"type\": \"Event\",\n  \"name\": \"Last-Ditch Effort\",\n  \"traits\": \"Gambit.Insight.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "3af42b",
          "Name": "CardCustom",
          "Nickname": "Last-Ditch Effort",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 302400,
          "CustomDeck": {
            "3024": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419578/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/061.LuckyStrike_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"20d0bf71-f3ee-429a-8fd2-86615762f1d4\",\n  \"type\": \"Event\",\n  \"name\": \"Lucky Strike\",\n  \"traits\": \"Trick.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "37ddf6",
          "Name": "CardCustom",
          "Nickname": "Lucky Strike",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 232100,
          "CustomDeck": {
            "2321": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419581/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/062.SmokeBomb_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"752da745-f58e-499b-8925-5a2e59735e87\",\n  \"type\": \"Event\",\n  \"name\": \"Smoke Bomb\",\n  \"traits\": \"Trick.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "bf5b09",
          "Name": "CardCustom",
          "Nickname": "Smoke Bomb",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 661300,
          "CustomDeck": {
            "6613": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419584/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/063.KeepBlastin_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f138241e-adec-43eb-920d-7d55b9191f00\",\n  \"type\": \"Skill\",\n  \"name\": \"\\\"Keep Blastin'\\\"\",\n  \"traits\": \"Practiced.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "3ef9b5",
          "Name": "CardCustom",
          "Nickname": "\"Keep Blastin'\"",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 433500,
          "CustomDeck": {
            "4335": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419586/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/064.RockBottom_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d6b72d9c-2429-4315-ba9a-ba0a6ba91900\",\n  \"type\": \"Skill\",\n  \"name\": \"Rock Bottom\",\n  \"traits\": \"Fortune.\",\n  \"class\": \"Rogue\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "d29e28",
          "Name": "CardCustom",
          "Nickname": "Rock Bottom",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 608600,
          "CustomDeck": {
            "6086": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419588/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/065.BribedSilence_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b384ff18-2009-4ddd-9784-bc8dddbcd1b1\",\n  \"type\": \"Event\",\n  \"name\": \"Bribed Silence\",\n  \"traits\": \"Illicit.Tactic.\",\n  \"class\": \"Rogue\",\n  \"level\": 1,\n  \"cost\": -1\n}",
          "GUID": "3ffac1",
          "Name": "CardCustom",
          "Nickname": "Bribed Silence",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 325100,
          "CustomDeck": {
            "3251": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419590/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/066.InsideJob_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"1723e799-953d-4106-bafe-0acba6aba5f4\",\n  \"type\": \"Event\",\n  \"name\": \"Inside Job\",\n  \"traits\": \"Trick.Illicit.\",\n  \"class\": \"Rogue\",\n  \"level\": 1,\n  \"cost\": 0\n}",
          "GUID": "b4223f",
          "Name": "CardCustom",
          "Nickname": "Inside Job",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 617700,
          "CustomDeck": {
            "6177": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419592/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/067.LastDitchEffort_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"bbc0713d-217d-4b80-94b0-cb8bb94b528f\",\n  \"type\": \"Event\",\n  \"name\": \"Last-Ditch Effort\",\n  \"traits\": \"Gambit.Insight.\",\n  \"class\": \"Rogue\",\n  \"level\": 2,\n  \"cost\": 0\n}",
          "GUID": "b3a918",
          "Name": "CardCustom",
          "Nickname": "Last-Ditch Effort",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 279000,
          "CustomDeck": {
            "2790": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419594/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/068.Negotiations_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"66de2739-63a7-4910-85e7-ef4781bdde5b\",\n  \"type\": \"Event\",\n  \"name\": \"Negotiations\",\n  \"traits\": \"Gambit.Illicit.Criminal.\",\n  \"class\": \"Rogue\",\n  \"level\": 2,\n  \"cost\": 0\n}",
          "GUID": "bf1828",
          "Name": "CardCustom",
          "Nickname": "Negotiations",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 389700,
          "CustomDeck": {
            "3897": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419596/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/069.Bloodwire_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"af6ed499-5441-457c-9a42-6c0775f77e5d\",\n  \"type\": \"Asset\",\n  \"name\": \"Bloodwire\",\n  \"traits\": \"Talent.Illicit.\",\n  \"class\": \"Rogue\",\n  \"level\": 3,\n  \"cost\": 3\n}",
          "GUID": "4cc5d1",
          "Name": "CardCustom",
          "Nickname": "Bloodwire",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 105600,
          "CustomDeck": {
            "1056": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419598/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/070.Burglary_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"14fe46eb-d4ff-4f45-ba02-6a744e749c72\",\n  \"type\": \"Asset\",\n  \"name\": \"Burglary\",\n  \"traits\": \"Talent.Illicit.\",\n  \"class\": \"Rogue\",\n  \"level\": 3,\n  \"cost\": 1\n}",
          "GUID": "43a7ed",
          "Name": "CardCustom",
          "Nickname": "Burglary",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 496900,
          "CustomDeck": {
            "4969": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419600/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/071.Pickpocketing_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"dccfc996-aecd-4271-9bcc-52ca941382f6\",\n  \"type\": \"Asset\",\n  \"name\": \"Pickpocketing\",\n  \"traits\": \"Talent.Illicit.\",\n  \"class\": \"Rogue\",\n  \"level\": 5,\n  \"cost\": 2\n}",
          "GUID": "09e5ca",
          "Name": "CardCustom",
          "Nickname": "Pickpocketing",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 844000,
          "CustomDeck": {
            "8440": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419603/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/072.StolenIdolofYoth_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f5977b45-a5bf-49cb-a7c3-1df828692c3b\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Stolen Idol of Yoth\",\n  \"traits\": \"Item.Relic.Illicit.Blessed.Cursed.\",\n  \"class\": \"Rogue\",\n  \"level\": 4,\n  \"cost\": 1,\n  \"victory\": 2\n}",
          "GUID": "4d58bc",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Stolen Idol of Yoth",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 781700,
          "CustomDeck": {
            "7817": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419605/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/073.FlashofWealth_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"402dd144-75d1-4102-a782-fd716650e40a\",\n  \"type\": \"Event\",\n  \"name\": \"Flash of Wealth\",\n  \"traits\": \"Insight.\",\n  \"class\": \"Rogue\",\n  \"level\": 4,\n  \"cost\": 0\n}",
          "GUID": "4a77d0",
          "Name": "CardCustom",
          "Nickname": "Flash of Wealth",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 816000,
          "CustomDeck": {
            "8160": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419607/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/126.Issith_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"4ac58d97-9521-4609-bcc0-a1d88d494289\",\n  \"type\": \"Enemy\",\n  \"name\": \"Issith\",\n  \"traits\": \"Humanoid.Monster.Serpent.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1\n}",
          "GUID": "196eba",
          "Name": "CardCustom",
          "Nickname": "Issith",
          "Tags": [
            "ScenarioCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 425500,
          "CustomDeck": {
            "4255": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415117/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/004.DaisyWalker_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415113/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/004.DaisyWalker_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "The Librarian",
          "GMNotes": "{\n  \"id\": \"7b48d829-0095-4b3e-a2c3-8fa609d111e2\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Miskatonic.\",\n  \"class\": \"Seeker\",\n  \"willpowerIcons\": 3,\n  \"intellectIcons\": 4,\n  \"combatIcons\": 1,\n  \"agilityIcons\": 3,\n  \"extraToken\": \"Reaction\",\n  \"signatures\": [\n    {\n      \"6a4fca38-d4f1-40cf-8544-15adb07f3789\": 1,\n      \"4b3bb0d8-9207-4503-9842-172a59d802d6\": 1\n    }\n  ]\n}",
          "GUID": "be646f",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…Daisy Walker",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 375200,
          "CustomDeck": {
            "3752": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415121/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/005.DaisysToteBag_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6a4fca38-d4f1-40cf-8544-15adb07f3789\",\n  \"type\": \"Asset\",\n  \"name\": \"Daisy's Tote Bag\",\n  \"traits\": \"Item.\",\n  \"class\": \"Neutral\",\n  \"level\": -1,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Resource\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "3d4fe1",
          "Name": "CardCustom",
          "Nickname": "Daisy's Tote Bag",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 517700,
          "CustomDeck": {
            "5177": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415124/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/006.TheNecronomicon_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "Description": "John Dee Translation",
          "GMNotes": "{\n  \"id\": \"4b3bb0d8-9207-4503-9842-172a59d802d6\",\n  \"type\": \"Asset\",\n  \"name\": \"The Necronomicon\",\n  \"traits\": \"Item.Tome.Cursed.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Horror\",\n      \"token\": \"horror\"\n    }\n  ]\n}",
          "GUID": "054774",
          "Name": "CardCustom",
          "Nickname": "The Necronomicon",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 581100,
          "CustomDeck": {
            "5811": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415126/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/037.EldritchInsight_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"3362294c-acba-4295-8014-7348ec8b1e7e\",\n  \"type\": \"Asset\",\n  \"name\": \"Eldritch Insight\",\n  \"traits\": \"Spell.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 2,\n  \"uses\": [\n    {\n      \"count\": 4,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    },\n    {\n      \"count\": 1,\n      \"type\": \"Secret\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "d9e69d",
          "Name": "CardCustom",
          "Nickname": "Eldritch Insight",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 564700,
          "CustomDeck": {
            "5647": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419621/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/038.Bookmark_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"83d1a57e-b642-4afa-9f74-9503172d71f5\",\n  \"type\": \"Event\",\n  \"name\": \"Bookmark\",\n  \"traits\": \"Item.Upgrade.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 1\n}",
          "GUID": "25789e",
          "Name": "CardCustom",
          "Nickname": "Bookmark",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 755400,
          "CustomDeck": {
            "7554": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419623/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/039.FlightorFright_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"bb097c62-c2c0-4b13-b552-2a5006b48257\",\n  \"type\": \"Event\",\n  \"name\": \"Flight or Fright\",\n  \"traits\": \"Trick.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "c929f0",
          "Name": "CardCustom",
          "Nickname": "Flight or Fright",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 817800,
          "CustomDeck": {
            "8178": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419626/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/040.FortunateFind_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"3d36bb40-d99c-472a-a900-0771646ecaa6\",\n  \"type\": \"Event\",\n  \"name\": \"Fortunate Find\",\n  \"traits\": \"Fortune.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "981f62",
          "Name": "CardCustom",
          "Nickname": "Fortunate Find",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 847700,
          "CustomDeck": {
            "8477": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419629/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/041.ProofofConcept_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"17f6376f-f4fe-45e3-85e8-b1e14c55e410\",\n  \"type\": \"Event\",\n  \"traits\": \"Insight. Tactic.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 1\n}",
          "GUID": "fd43a0",
          "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"playercards/cards/SealTemplate\")\nend)\n__bundle_register(\"chaosbag/BlessCurseManagerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local BlessCurseManagerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  local function getManager()\n    return guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"BlessCurseManager\")\n  end\n\n  -- removes all taken tokens and resets the counts\n  BlessCurseManagerApi.removeTakenTokensAndReset = function()\n    local BlessCurseManager = getManager()\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Bless\") end, 0.05)\n    Wait.time(function() BlessCurseManager.call(\"removeTakenTokens\", \"Curse\") end, 0.10)\n    Wait.time(function() BlessCurseManager.call(\"doReset\", \"White\") end, 0.15)\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.sealedToken = function(type, guid, silent)\n    getManager().call(\"sealedToken\", { type = type, guid = guid, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  ---@param fromBag? boolean Whether or not token was just drawn from the chaos bag\n  ---@param silent? boolean Whether or not to hide messages\n  BlessCurseManagerApi.releasedToken = function(type, guid, fromBag, silent)\n    getManager().call(\"releasedToken\", { type = type, guid = guid, fromBag = fromBag, silent = silent })\n  end\n\n  -- updates the internal count (called by cards that seal bless/curse tokens)\n  ---@param type string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param guid string GUID of the token\n  BlessCurseManagerApi.returnedToken = function(type, guid)\n    getManager().call(\"returnedToken\", { type = type, guid = guid })\n  end\n\n  -- broadcasts the current status for bless/curse tokens\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.broadcastStatus = function(playerColor)\n    getManager().call(\"broadcastStatus\", playerColor)\n  end\n\n  -- removes all bless / curse tokens from the chaos bag and play\n  ---@param playerColor string Color of the player to show the broadcast to\n  BlessCurseManagerApi.removeAll = function(playerColor)\n    getManager().call(\"doRemove\", playerColor)\n  end\n\n  -- adds bless / curse sealing to the hovered card\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param hoveredObject tts__Object Hovered object\n  ---@param noCurse? boolean True if just Bless sealing should be added (Parallel Mateo)\n  BlessCurseManagerApi.addBlurseSealingMenu = function(playerColor, hoveredObject, noCurse)\n    getManager().call(\"addMenuOptions\", { playerColor = playerColor, hoveredObject = hoveredObject, noCurse = noCurse })\n  end\n\n  -- adds bless / curse to the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.addToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = false })\n  end\n\n  -- removes bless / curse from the chaos bag\n  ---@param tokenType string Type of chaos token (\"Bless\" or \"Curse\")\n  ---@param playerColor? string Color of the triggering player\n  BlessCurseManagerApi.removeToken = function(tokenType, playerColor)\n    getManager().call(\"callFunctionFromApi\", { tokenType = tokenType, playerColor = playerColor, remove = true })\n  end\n\n  BlessCurseManagerApi.getBlessCurseInBag = function()\n    return getManager().call(\"getBlessCurseInBag\", {})\n  end\n\n  return BlessCurseManagerApi\nend\nend)\n__bundle_register(\"chaosbag/ChaosBagApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local ChaosBagApi = {}\n\n  -- respawns the chaos bag with a new state of tokens\n  ---@param tokenList table List of chaos token ids\n  ChaosBagApi.setChaosBagState = function(tokenList)\n    Global.call(\"setChaosBagState\", tokenList)\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getChaosBagState = function()\n    local chaosBagContentsCatcher = Global.call(\"getChaosBagState\")\n    local chaosBagContents = {}\n    for _, v in ipairs(chaosBagContentsCatcher) do\n      table.insert(chaosBagContents, v)\n    end\n    return chaosBagContents\n  end\n\n  -- checks scripting zone for chaos bag (also called by a lot of objects!)\n  ChaosBagApi.findChaosBag = function()\n    return Global.call(\"findChaosBag\")\n  end\n\n  -- returns a table of object references to the tokens in play (does not include sealed tokens!)\n  ChaosBagApi.getTokensInPlay = function()\n    return Global.call(\"getChaosTokensinPlay\")\n  end\n\n  -- returns all sealed tokens on cards to the chaos bag\n  ---@param playerColor string Color of the player to show the broadcast to\n  ---@param filterName? string Name of the token to release\n  ---@param silent? boolean Whether or not to hide messages\n  ChaosBagApi.releaseAllSealedTokens = function(playerColor, filterName, silent)\n    Global.call(\"releaseAllSealedTokens\", { playerColor = playerColor, filterName = filterName, silent = silent })\n  end\n\n  -- returns all drawn tokens to the chaos bag\n  ChaosBagApi.returnChaosTokens = function()\n    Global.call(\"returnChaosTokens\")\n  end\n\n  -- removes the specified chaos token from the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.removeChaosToken = function(id)\n    Global.call(\"removeChaosToken\", id)\n  end\n\n  -- returns a chaos token to the bag and calls all relevant functions\n  ---@param token tts__Object Chaos token to return\n  ---@param fromBag boolean whether or not the token to return was in the middle of being drawn (true) or elsewhere (false)\n  ChaosBagApi.returnChaosTokenToBag = function(token, fromBag)\n    Global.call(\"returnChaosTokenToBag\", { token = token, fromBag = fromBag })\n  end\n\n  -- spawns the specified chaos token and puts it into the chaos bag\n  ---@param id string ID of the chaos token\n  ChaosBagApi.spawnChaosToken = function(id)\n    Global.call(\"spawnChaosToken\", id)\n  end\n\n  -- Checks to see if the chaos bag can be manipulated.  If a player is searching the bag when tokens\n  -- are drawn or replaced a TTS bug can cause those tokens to vanish.  Any functions which change the\n  -- contents of the bag should check this method before doing so.\n  -- This method will broadcast a message to all players if the bag is being searched.\n  ---@return any: True if the bag is manipulated, false if it should be blocked.\n  ChaosBagApi.canTouchChaosTokens = function()\n    return Global.call(\"canTouchChaosTokens\")\n  end\n\n  ChaosBagApi.activeRedrawEffect = function(validTokens, invalidTokens, returnToPool, drawSpecificToken)\n    Global.call(\"activeRedrawEffect\", {\n      validTokens = validTokens,\n      invalidTokens = invalidTokens,\n      returnToPool = returnToPool,\n      drawSpecificToken = drawSpecificToken\n    })\n  end\n\n  ChaosBagApi.getReadableTokenName = function(tokenName)\n    return Global.call(\"getReadableTokenName\", tokenName)\n  end\n\n  ChaosBagApi.getChaosTokenName = function(chosenToken)\n    return Global.call(\"getChaosTokenName\", chosenToken)\n  end\n\n  -- draws a chaos token to a playermat\n  ---@param mat tts__Object|string Playermat that triggered this (either object or matColor)\n  ---@param drawAdditional boolean Controls whether additional tokens should be drawn\n  ---@param tokenType? string Name of token (e.g. \"Bless\") to be drawn from the bag\n  ---@param guidToBeResolved? string GUID of the sealed token to be resolved instead of drawing a token from the bag\n  ---@param takeParameters? table Position and rotation of the location where the new token should be drawn to, usually to replace a returned token\n  ---@return tts__Object: Object reference to the token that was drawn\n  ChaosBagApi.drawChaosToken = function(mat, drawAdditional, tokenType, guidToBeResolved, takeParameters)\n    return Global.call(\"drawChaosToken\", {\n      mat              = mat,\n      drawAdditional   = drawAdditional,\n      tokenType        = tokenType,\n      guidToBeResolved = guidToBeResolved,\n      takeParameters   = takeParameters\n    })\n  end\n\n  -- returns a Table List of chaos token ids in the current chaos bag\n  -- requires copying the data into a new table because TTS is weird about handling table return values in Global\n  ChaosBagApi.getIdUrlMap = function()\n    return Global.getTable(\"ID_URL_MAP\")\n  end\n\n  return ChaosBagApi\nend\nend)\n__bundle_register(\"core/GUIDReferenceApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local GUIDReferenceApi = {}\n\n  local function getGuidHandler()\n    return getObjectFromGUID(\"123456\")\n  end\n\n  -- Returns the matching object\n  ---@param owner string Parent object for this search\n  ---@param type string Type of object to search for\n  ---@return any: Object reference to the matching object\n  GUIDReferenceApi.getObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"getObjectByOwnerAndType\", { owner = owner, type = type })\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param type string Type of object to search for\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByType = function(type)\n    return getGuidHandler().call(\"getObjectsByType\", type)\n  end\n\n  -- Returns all matching objects as a table with references\n  ---@param owner string Parent object for this search\n  ---@return table: List of object references to matching objects\n  GUIDReferenceApi.getObjectsByOwner = function(owner)\n    return getGuidHandler().call(\"getObjectsByOwner\", owner)\n  end\n\n  -- Sends new information to the reference handler to edit the main index (if type/guid are omitted, entry will be removed)\n  ---@param owner string Parent of the object\n  ---@param type? string Type of the object\n  ---@param guid? string GUID of the object\n  GUIDReferenceApi.editIndex = function(owner, type, guid)\n    return getGuidHandler().call(\"editIndex\", {\n      owner = owner,\n      type = type,\n      guid = guid\n    })\n  end\n\n  -- Returns the owner of an object or the object it's located on\n  ---@param object tts__GameObject Object for this search\n  ---@return string: Parent of the object or object it's located on\n  GUIDReferenceApi.getOwnerOfObject = function(object)\n    return getGuidHandler().call(\"getOwnerOfObject\", object)\n  end\n\n  -- Remove object\n  ---@param owner string Parent of the object\n  ---@param type string Type of the object\n  GUIDReferenceApi.removeObjectByOwnerAndType = function(owner, type)\n    return getGuidHandler().call(\"removeObjectByOwnerAndType\", {\n      owner = owner,\n      type = type\n    })\n  end\n\n  return GUIDReferenceApi\nend\nend)\n__bundle_register(\"playercards/CardsThatSealTokens\", function(require, _LOADED, __bundle_register, __bundle_modules)\n--[[ Library for cards that seal tokens\nThis file is used to add sealing option to cards' context menu.\nNOTE: all cards are allowed to release a single token to enable Hallow and A Watchful Peace,\nand to release all sealed tokens to allow for cards that might leave play with sealed tokens on them.\nValid options (set before requiring this file):\n\nMAX_SEALED          --@type: number (maximum number of tokens allowable by the card to be sealed)\n  - required for all cards\n  - if MAX_SEALED is more than 1, then an XML label is created for the topmost token indicating the number of sealed tokens\n  - gives an error if user tries to seal additional tokens on the card\n  - example usage: \"The Chthonian Stone\"\n    > MAX_SEALED = 1\n\nUPDATE_ON_HOVER     --@type: boolean\n  - automatically updates the context menu options when the card is hovered\n  - the \"Read Bag\" function reads the content of the chaos bag to update the context menu\n  - example usage: \"Unrelenting\" (to only display valid tokens)\n\nKEEP_OPEN           --@type: boolean\n- meant for cards that seal single tokens multiple times (one by one)\n- makes the context menu stay open after selecting an option\n- example usage: \"Unrelenting\"\n\nSHOW_MULTI_RELEASE  --@type: number (maximum amount of tokens to release at once)\n  - enables an entry in the context menu\n  - this entry allows releasing of multiple tokens at once, to the maximum number\n  - does not fail if there are fewer than the maximum sealed\n  - example usage: \"Nephthys\" (to release up to 3 bless tokens at once)\n\nSHOW_MULTI_RETURN   --@type: number (amount of tokens to return to pool at once)\n  - enables an entry in the context menu\n  - this entry allows returning tokens to the token pool\n  - fails if not enough tokens are sealed\n  - example usage: \"Nephthys\" (to return 3 bless tokens at once)\n\nSHOW_RETURN_ALL   --@boolean:\n  - enables an entry in the context menu\n  - this entry allows returning all sealed tokens to the token pool\n  - example usage: \"Radiant Smite\" (to return whatever number of bless tokens that are sealed at once)\n\nSHOW_MULTI_SEAL     --@type: number (amount of tokens to seal at once)\n  - enables an entry in the context menu\n  - this entry allows sealing of multiple tokens at once\n  - example usage: \"Holy Spear\" (to seal two bless tokens at once)\n\nVALID_TOKENS        --@type: table ([tokenName] = true)\n  - this table defines which tokens should be abled to be sealed\n  - needs to be defined for each card -> even if empty\n  - example usage: \"The Chthonian Stone\"\n    > VALID_TOKENS = {\n    >   [\"Skull\"]       = true,\n    >   [\"Cultist\"]     = true,\n    >   [\"Tablet\"]      = true,\n    >   [\"Elder Thing\"] = true,\n    > }\n\nINVALID_TOKENS      --@type: table ([tokenName] = true)\n  - this table defines which tokens are invalid for sealing\n  - only needs to be defined if needed\n  - usually combined with empty \"VALID_TOKENS\" table\n  - example usage: \"Protective Incantation\" (not allowed to seal Auto-fail)\n\n----------------------------------------------------------\nExample 1: Crystalline Elder Sign\nThis card can only seal the \"+1\" or \"Elder Sign\" token,\nit does not need specific options for multi-sealing or releasing.\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"+1\"] = true,\n  >   [\"Elder Sign\"] = true\n  > }\n  > MAX_SEALED = 1\n  > require...\n----------------------------------------------------------\nExample 2: Holy Spear\nThis card features the following abilities (just listing the relevant parts):\n- releasing a single bless token\n- sealing two bless tokens\nThus it should be implemented like this:\n  > VALID_TOKENS = {\n  >   [\"Bless\"] = true\n  > }\n  > SHOW_MULTI_SEAL = 2\n  > MAX_SEALED = 10\n  > require...\n----------------------------------------------------------]]\n\nlocal blessCurseManagerApi = require(\"chaosbag/BlessCurseManagerApi\")\nlocal chaosBagApi          = require(\"chaosbag/ChaosBagApi\")\nlocal playermatApi         = require(\"playermat/PlayermatApi\")\nlocal tokenArrangerApi     = require(\"tokens/TokenArrangerApi\")\n\nlocal sealedTokens         = {}\nlocal ID_URL_MAP           = {}\nlocal tokensInBag          = {}\n\n-- XML background color for each token for label when stacked\nlocal tokenColor           = {\n  [\"Skull\"]       = \"#4A0400E6\",\n  [\"Cultist\"]     = \"#173B0BE6\",\n  [\"Tablet\"]      = \"#1D2238E6\",\n  [\"Elder Thing\"] = \"#4D2331E6\",\n  [\"Auto-fail\"]   = \"#9B0004E6\",\n  [\"Bless\"]       = \"#9D702CE6\",\n  [\"Curse\"]       = \"#633A84E6\",\n  [\"Frost\"]       = \"#404450E6\",\n  [\"Elder Sign\"]  = \"#50A8CEE6\",\n  [\"\"]            = \"#77674DE6\"\n}\n\nfunction updateSave()\n  updateStackSize()\n  self.script_state = JSON.encode(sealedTokens)\nend\n\nfunction onLoad(savedData)\n  -- if MAX_SEALED is not set, default to 99\n  MAX_SEALED = MAX_SEALED or 99\n\n  -- verify sealed tokens\n  for _, guid in ipairs(JSON.decode(savedData) or {}) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      table.insert(sealedTokens, guid)\n    end\n  end\n\n  ID_URL_MAP = chaosBagApi.getIdUrlMap()\n  generateContextMenu()\n  updateStackSize()\n  self.addTag(\"CardThatSeals\")\nend\n\n-- i18n menu labels (injected by generator)\nlocal MENU_RELEASE_ONE = \"Release one token\"\nlocal MENU_RELEASE_ONE_PREFIX = \"Release \"\nlocal MENU_RELEASE_ALL = \"Release all tokens\"\nlocal MENU_RELEASE_MULTI_PREFIX = \"Release \"\nlocal MENU_RETURN_MULTI_PREFIX = \"Return \"\nlocal MENU_TOKEN_SUFFIX = \" token(s)\"\nlocal MENU_RETURN_ALL = \"Return all tokens\"\nlocal MENU_RESOLVE_PREFIX = \"Resolve \"\nlocal MENU_RESOLVE_ONE = \"Resolve one token\"\nlocal MENU_RESOLVE_ONE_PREFIX = \"Resolve \"\nlocal MENU_SEAL_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_PREFIX = \"Seal \"\nlocal MENU_SEAL_MULTI_INFIX = \" \"\nlocal function TOKEN_DISPLAY(name) return name end\nlocal function TOKEN_DISPLAY_OR_DEFAULT(name, default) return (name and TOKEN_DISPLAY(name)) or default end\n\nlocal GENERIC_TOKEN_LABEL = \"token\"\n\n-- builds the context menu\nfunction generateContextMenu()\n  -- determine if exactly one valid token type is configured\n  local SINGLE_VALID_TOKEN = nil\n  for k, _ in pairs(VALID_TOKENS) do\n    if SINGLE_VALID_TOKEN == nil then\n      SINGLE_VALID_TOKEN = k\n    else\n      SINGLE_VALID_TOKEN = false -- more than one\n      break\n    end\n  end\n\n  local releaseOneLabel\n  if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n    releaseOneLabel = MENU_RELEASE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n  else\n    releaseOneLabel = MENU_RELEASE_ONE\n  end\n  self.addContextMenuItem(releaseOneLabel, releaseOneToken)\n\n  -- conditional release options\n  if MAX_SEALED > 1 then\n    self.addContextMenuItem(MENU_RELEASE_ALL, releaseAllTokens)\n  end\n\n  if SHOW_MULTI_RELEASE then\n    self.addContextMenuItem(MENU_RELEASE_MULTI_PREFIX .. SHOW_MULTI_RELEASE .. MENU_TOKEN_SUFFIX, releaseMultipleTokens)\n  end\n\n  if RESOLVE_TOKEN then\n    local resolveOneLabel\n    if SINGLE_VALID_TOKEN and type(SINGLE_VALID_TOKEN) == 'string' then\n      resolveOneLabel = MENU_RESOLVE_ONE_PREFIX .. TOKEN_DISPLAY(SINGLE_VALID_TOKEN)\n    else\n      resolveOneLabel = MENU_RESOLVE_ONE\n    end\n    self.addContextMenuItem(resolveOneLabel, resolveSealed)\n  end\n\n  if SHOW_MULTI_RETURN then\n    self.addContextMenuItem(MENU_RETURN_MULTI_PREFIX .. SHOW_MULTI_RETURN .. MENU_TOKEN_SUFFIX, returnMultipleTokens)\n  end\n\n  if SHOW_RETURN_ALL then\n    self.addContextMenuItem(MENU_RETURN_ALL, returnAllTokens)\n  end\n\n  -- main context menu options to seal tokens\n  for _, map in pairs(ID_URL_MAP) do\n    if (VALID_TOKENS[map.name] ~= nil) or (UPDATE_ON_HOVER and tokensInBag[map.name] and INVALID_TOKENS and not INVALID_TOKENS[map.name]) then\n      if not SHOW_MULTI_SEAL then\n        self.addContextMenuItem(MENU_SEAL_PREFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          sealToken(map.name, playerColor)\n        end, KEEP_OPEN)\n      else\n        self.addContextMenuItem(MENU_SEAL_MULTI_PREFIX .. SHOW_MULTI_SEAL .. MENU_SEAL_MULTI_INFIX .. TOKEN_DISPLAY(map.name), function(playerColor)\n          self.removeFromPlayerSelection(playerColor)\n          if not chaosBagApi.canTouchChaosTokens() then return end\n          readBag()\n          local allowed = true\n          local notFound\n\n          for name, _ in pairs(VALID_TOKENS) do\n            if (tokensInBag[name] or 0) < SHOW_MULTI_SEAL then\n              allowed = false\n              notFound = name\n            end\n          end\n\n          if allowed then\n            for i = SHOW_MULTI_SEAL, 1, -1 do\n              sealToken(map.name, playerColor)\n            end\n          else\n            printToColor(\"Not enough \" .. notFound .. \" tokens in the chaos bag.\", playerColor)\n          end\n        end)\n      end\n    end\n  end\nend\n\n-- generates a list of chaos tokens that is in the chaos bag\nfunction readBag()\n  local chaosbag = chaosBagApi.findChaosBag()\n  tokensInBag = {}\n\n  for _, token in ipairs(chaosbag.getObjects()) do\n    tokensInBag[token.name] = (tokensInBag[token.name] or 0) + 1\n  end\nend\n\nfunction resetSealedTokens()\n  sealedTokens = {}\n  updateSave()\nend\n\n-- native event from TTS - used to update the context menu for cards like \"Unrelenting\"\nfunction onHover()\n  if UPDATE_ON_HOVER then\n    readBag()\n    self.clearContextMenu()\n    generateContextMenu()\n  end\nend\n\n-- seals the named token on this card\nfunction sealToken(name, playerColor)\n  if #sealedTokens >= MAX_SEALED then\n    printToColor(\"Cannot seal any more tokens on this card\", playerColor, \"Red\")\n    return\n  end\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  local chaosbag = chaosBagApi.findChaosBag()\n  for i, obj in ipairs(chaosbag.getObjects()) do\n    if obj.name == name then\n      return chaosbag.takeObject({\n        position = self.getPosition() + Vector(0, 0.5 + 0.1 * #sealedTokens, 0),\n        rotation = self.getRotation(),\n        index = i - 1,\n        smooth = false,\n        callback_function = function(token)\n          local guid = token.getGUID()\n          table.insert(sealedTokens, guid)\n          tokenArrangerApi.layout()\n          if name == \"Bless\" or name == \"Curse\" then\n            blessCurseManagerApi.sealedToken(name, guid)\n          end\n          -- destroy XML on just covered token\n          if #sealedTokens > 1 then\n            local coveredToken = getObjectFromGUID(sealedTokens[#sealedTokens - 1])\n            if coveredToken ~= nil then\n              coveredToken.UI.setXml(\"\")\n            else\n              table.remove(sealedTokens, #sealedTokens - 1)\n            end\n          end\n          updateSave()\n        end\n      })\n    end\n  end\n  printToColor(name .. \" token not found in chaos bag\", playerColor)\nend\n\n-- release the last sealed token\nfunction releaseOneToken(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"No sealed token(s) found\", playerColor)\n  else\n    printToColor(\"Releasing token\", playerColor)\n\n    -- make list of token names\n    local tokenNames = {}\n    local differentNames = 0\n    for _, guid in ipairs(sealedTokens) do\n      local token = getObjectFromGUID(guid)\n      if token ~= nil then\n        local name = token.getName()\n        if tokenNames[name] == nil then\n          differentNames = differentNames + 1\n        end\n        tokenNames[name] = guid\n      end\n    end\n\n    -- if there are multiple tokens, ask the player to choose\n    if differentNames < 2 then\n      putTokenAway(table.remove(sealedTokens))\n      updateSave()\n    else\n      local choices = {}\n      for name, _ in pairs(tokenNames) do\n        table.insert(choices, name)\n      end\n      Player[playerColor].showOptionsDialog(\"Choose token to release:\", choices, 1, function(optionText, optionIndex)\n        for i = #sealedTokens, 1, -1 do\n          local token = getObjectFromGUID(sealedTokens[i])\n          if token ~= nil and token.getName() == optionText then\n            putTokenAway(table.remove(sealedTokens, i))\n            updateSave()\n            break\n          end\n        end\n      end)\n    end\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- release up to multiple tokens at once with no minimum\nfunction releaseMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n    return\n  end\n\n  local numRemoved = SHOW_MULTI_RELEASE\n  if #sealedTokens < SHOW_MULTI_RELEASE then\n    numRemoved = #sealedTokens\n  end\n\n  for i = 1, numRemoved do\n    putTokenAway(table.remove(sealedTokens))\n  end\n  updateSave()\n  printToColor(\"Releasing \" .. numRemoved .. \" tokens\", playerColor)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction releaseAllTokensWrapper(params)\n  releaseAllTokens(params.playerColor, _, _, params.filterName, params.silent)\nend\n\n-- releases all sealed tokens\nfunction releaseAllTokens(playerColor, _, _, filterName, silent)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if #sealedTokens == 0 then\n    if not silent then\n      printToColor(\"No sealed token(s) found\", playerColor)\n    end\n  else\n    if not silent then\n      printToColor(\"Releasing token(s)\", playerColor)\n    end\n\n    for i = #sealedTokens, 1, -1 do\n      local success = putTokenAway(sealedTokens[i], filterName, silent)\n      if success then\n        table.remove(sealedTokens, i)\n      end\n    end\n\n    updateSave()\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns multiple tokens at once to the token pool (with minimum)\nfunction returnMultipleTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  if SHOW_MULTI_RETURN <= #sealedTokens then\n    for i = 1, SHOW_MULTI_RETURN do\n      returnToken(table.remove(sealedTokens))\n    end\n    updateSave()\n    printToColor(\"Returning \" .. SHOW_MULTI_RETURN .. \" tokens to the token pool\", playerColor)\n  else\n    printToColor(\"Not enough tokens sealed.\", playerColor)\n  end\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns all sealed tokens to the token pool\nfunction returnAllTokens(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if not chaosBagApi.canTouchChaosTokens() then return end\n  printToColor(\"Returning \" .. #sealedTokens .. \" tokens to the token pool\", playerColor)\n  for i = 1, #sealedTokens do\n    returnToken(table.remove(sealedTokens))\n  end\n  updateSave()\n  Player[playerColor].clearSelectedObjects()\nend\n\n-- returns the token (referenced by GUID) to the chaos bag\n---@return boolean: True if a token was returned\nfunction putTokenAway(guid, filterName, silent)\n  local token = getObjectFromGUID(guid)\n  if not token then return false end\n\n  local name = token.getName()\n  if filterName and filterName ~= name then return false end\n\n  local chaosbag = chaosBagApi.findChaosBag()\n  chaosbag.putObject(token)\n\n  tokenArrangerApi.layout()\n\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.releasedToken(name, guid, nil, silent)\n  end\n\n  return true\nend\n\n-- returns the token to the pool (== removes it)\nfunction returnToken(guid)\n  local token = getObjectFromGUID(guid)\n  if not token then return end\n\n  local name = token.getName()\n  token.destruct()\n  if name == \"Bless\" or name == \"Curse\" then\n    blessCurseManagerApi.returnedToken(name, guid)\n  end\nend\n\n-- resolves sealed token as if it came from the chaos bag\nfunction resolveSealed(playerColor)\n  self.removeFromPlayerSelection(playerColor)\n  if #sealedTokens == 0 then\n    broadcastToAll(\"No tokens sealed.\", \"Red\")\n    return\n  end\n\n  -- make list of token names\n  local tokenNames = {}\n  local differentNames = 0\n  for _, guid in ipairs(sealedTokens) do\n    local token = getObjectFromGUID(guid)\n    if token ~= nil then\n      local name = token.getName()\n      if tokenNames[name] == nil then\n        differentNames = differentNames + 1\n      end\n      tokenNames[name] = guid\n    end\n  end\n\n  -- if there are multiple tokens, ask the player to choose\n  if differentNames < 2 then\n    resolveTokenByGuid(playerColor, table.remove(sealedTokens))\n    updateSave()\n  else\n    local choices = {}\n    for name, _ in pairs(tokenNames) do\n      table.insert(choices, name)\n    end\n    Player[playerColor].showOptionsDialog(\"Choose token to resolve:\", choices, 1, function(optionText, optionIndex)\n      for i = #sealedTokens, 1, -1 do\n        local token = getObjectFromGUID(sealedTokens[i])\n        if token ~= nil and token.getName() == optionText then\n          resolveTokenByGuid(playerColor, table.remove(sealedTokens, i))\n          updateSave()\n          return\n        end\n      end\n    end)\n  end\nend\n\nfunction resolveTokenByGuid(playerColor, guidToBeResolved)\n  local resolvedToken = getObjectFromGUID(guidToBeResolved)\n  if resolvedToken ~= nil then\n    resolvedToken.UI.setXml(\"\")\n  end\n\n  local closestMatColor = playermatApi.getMatColorByPosition(self.getPosition())\n  chaosBagApi.drawChaosToken(closestMatColor, true, _, guidToBeResolved)\n  Player[playerColor].clearSelectedObjects()\nend\n\nfunction updateStackSize()\n  if MAX_SEALED == 1 then return end\n  if #sealedTokens == 0 then return end\n\n  -- get topmost sealed token\n  local topToken = getObjectFromGUID(sealedTokens[#sealedTokens])\n  if topToken == nil then return end\n\n  -- handling for two-digit numbers\n  local fontsize = 380\n  if #sealedTokens > 9 then\n    fontsize = 360\n  end\n\n  topToken.UI.setXmlTable({\n    {\n      tag = \"Panel\",\n      attributes = {\n        height = 380,\n        width = 380,\n        rotation = \"0 0 180\",\n        scale = \"0.2 0.2 1\",\n        position = \"0 0 -12\",\n        color = tokenColor[topToken.getName()] or \"#77674DE6\"\n      },\n      children = {\n        tag = \"Text\",\n        attributes = {\n          fontSize = fontsize,\n          font = \"font_teutonic-arkham\",\n          color = \"#ffffff\",\n          outline = \"#000000\",\n          outlineSize = \"8 -8\",\n          text = \"x\" .. #sealedTokens\n        }\n      }\n    }\n  })\nend\nend)\n__bundle_register(\"playercards/cards/SealTemplate\", function(require, _LOADED, __bundle_register, __bundle_modules)\nVALID_TOKENS = {\n  [\"+1\"] = true,\n  [\"0\"] = true\n}\n\nINVALID_TOKENS = nil\n\nUPDATE_ON_HOVER = true\n\n\n\n-- RESOLVE_TOKEN config\nRESOLVE_TOKEN = true\n\nrequire(\"playercards/CardsThatSealTokens\")\nend)\n__bundle_register(\"playermat/PlayermatApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local PlayermatApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n  local searchLib = require(\"util/SearchLib\")\n  local localInvestigatorPosition = { x = -1.17, y = 1, z = -0.01 }\n\n  -- Convenience function to look up a mat's object by color, or get all mats.\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@return table: Single-element if only single playermat is requested\n  local function getMatForColor(matColor)\n    if matColor == \"All\" then\n      return guidReferenceApi.getObjectsByType(\"Playermat\")\n    else\n      return { matColor = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\") }\n    end\n  end\n\n  -- Returns the color of the closest playermat\n  ---@param startPos table Starting position to get the closest mat from\n  PlayermatApi.getMatColorByPosition = function(startPos)\n    local result, smallestDistance\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local distance = Vector.between(startPos, mat.getPosition()):magnitude()\n      if smallestDistance == nil or distance < smallestDistance then\n        smallestDistance = distance\n        result = matColor\n      end\n    end\n    return result\n  end\n\n  -- Returns the color of the player's hand that is seated next to the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getPlayerColor = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getVar(\"playerColor\")\n    end\n  end\n\n  -- Returns the color of the playermat that owns the playercolor's hand\n  ---@param handColor string Color of the playermat\n  PlayermatApi.getMatColor = function(handColor)\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local playerColor = mat.getVar(\"playerColor\")\n      if playerColor == handColor then\n        return matColor\n      end\n    end\n    return nil\n  end\n\n  -- gets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getSlotData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getTable(\"slotData\")\n    end\n  end\n\n  -- sets the slot data for the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param newSlotData table New slot data for the playermat\n  PlayermatApi.loadSlotData = function(matColor, newSlotData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.setTable(\"slotData\", newSlotData)\n      mat.call(\"updateSave\")\n      mat.call(\"updateSlotSymbols\")\n      return\n    end\n  end\n\n  -- Performs a search of the deck area of the requested playermat and returns the result as table\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDeckAreaObjects = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getDeckAreaObjects\")\n    end\n  end\n\n  -- Flips the top card of the deck (useful after deck manipulation for Norman Withers)\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.flipTopCardFromDeck = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"flipTopCardFromDeck\")\n    end\n  end\n\n  -- Returns the position of the discard pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDiscardPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDiscardPosition\")\n    end\n  end\n\n  -- Returns the position of the draw pile of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getDrawPosition = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"returnGlobalDrawPosition\")\n    end\n  end\n\n  -- Transforms a local position into a global position\n  ---@param localPos table Local position to be transformed\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.transformLocalPosition = function(localPos, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.positionToWorld(localPos)\n    end\n  end\n\n  -- Returns the rotation of the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.returnRotation = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.getRotation()\n    end\n  end\n\n  -- Returns a table with spawn data (position and rotation) for a helper object\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param helperName string Name of the helper object\n  PlayermatApi.getHelperSpawnData = function(matColor, helperName)\n    local resultTable = {}\n    local localPositionTable = {\n      [\"Hand Helper\"] = Vector(-0.055, 0, -1.132),\n      [\"Search Assistant\"] = Vector(-0.34, 0, -1.132)\n    }\n\n    for color, mat in pairs(getMatForColor(matColor)) do\n      resultTable[color] = {\n        position = mat.positionToWorld(localPositionTable[helperName]),\n        rotation = mat.getRotation()\n      }\n    end\n    return resultTable\n  end\n\n\n  -- Triggers the Upkeep for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param playerColor string Color of the calling player (for messages)\n  PlayermatApi.doUpkeepFromHotkey = function(matColor, playerColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doUpkeepFromHotkey\", playerColor)\n    end\n  end\n\n  -- Handles discarding for the requested playermat for the provided list of objects\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param objList table List of objects to discard\n  PlayermatApi.discardListOfObjects = function(matColor, objList)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"discardListOfObjects\", objList)\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getActiveInvestigatorData = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getActiveInvestigatorData\")\n    end\n  end\n\n  -- Gets data about the active investigator\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param newData table New active investigator data (class and id)\n  PlayermatApi.setActiveInvestigatorData = function(matColor, newData)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setActiveInvestigatorData\", newData)\n    end\n  end\n\n  -- Returns the position for encounter card drawing\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param stack boolean If true, returns the leftmost position instead of the first empty from the right\n  PlayermatApi.getEncounterCardDrawPosition = function(matColor, stack)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return Vector(mat.call(\"getEncounterCardDrawPosition\", stack))\n    end\n  end\n\n  -- Sets the requested playermat's snap points to limit snapping to matching card types or not.  If\n  -- matchTypes is true, the main card slot snap points will only snap assets, while the\n  -- investigator area point will only snap Investigators.  If matchTypes is false, snap points will\n  -- be reset to snap all cards.\n  ---@param matchCardTypes boolean Whether snap points should only snap for the matching card types\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.setLimitSnapsByType = function(matchCardTypes, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"setLimitSnapsByType\", matchCardTypes)\n    end\n  end\n\n  -- Sets the requested playermat's draw 1 button to visible\n  ---@param isDrawButtonVisible boolean Whether the draw 1 button should be visible or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.showDrawButton = function(isDrawButtonVisible, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"showDrawButton\", isDrawButtonVisible)\n    end\n  end\n\n  -- Shows or hides the clickable clue counter for the requested playermat\n  ---@param showCounter boolean Whether the clickable counter should be present or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.clickableClues = function(showCounter, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"clickableClues\", showCounter)\n    end\n  end\n\n  -- Toggles the use of class textures for the requested playermat\n  ---@param state boolean Whether the class texture should be used or not\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.useClassTexture = function(state, matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"useClassTexture\", state)\n    end\n  end\n\n  -- updates the texture of the playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param overrideName? string Force a specific texture\n  PlayermatApi.updateTexture = function(matColor, overrideName)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateTexture\", overrideName)\n    end\n  end\n\n  -- Removes all clues (to the trash for tokens and counters set to 0) for the requested playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.removeClues = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"removeClues\")\n    end\n  end\n\n  -- Reports the clue count for the requested playermat\n  ---@param useClickableCounters boolean Controls which type of counter is getting checked\n  PlayermatApi.getClueCount = function(useClickableCounters, matColor)\n    local count = 0\n    for _, mat in pairs(getMatForColor(matColor)) do\n      count = count + mat.call(\"getClueCount\", useClickableCounters)\n    end\n    return count\n  end\n\n  -- Updates the specified owned counter\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param type string Counter to target\n  ---@param newValue number Value to set the counter to\n  ---@param modifier number If newValue is not provided, the existing value will be adjusted by this modifier\n  PlayermatApi.updateCounter = function(matColor, type, newValue, modifier)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateCounter\", { type = type, newValue = newValue, modifier = modifier })\n    end\n  end\n\n  -- Triggers the draw function for the specified playermat\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param number number Amount of cards to draw\n  PlayermatApi.drawCardsWithReshuffle = function(matColor, number)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"drawCardsWithReshuffle\", number)\n    end\n  end\n\n  -- Returns the resource counter amount\n  ---@param matColor string Color of the playermat - White, Orange, Green or Red (does not support \"All\")\n  ---@param type string Counter to target\n  PlayermatApi.getCounterValue = function(matColor, type)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      return mat.call(\"getCounterValue\", type)\n    end\n  end\n\n  -- Returns a list of mat colors that have an investigator placed\n  PlayermatApi.getUsedMatColors = function()\n    local usedColors = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        table.insert(usedColors, matColor)\n      end\n    end\n    return usedColors\n  end\n\n  -- Returns a list of investigator card objects\n  PlayermatApi.getUsedInvestigatorCards = function()\n    local usedCards = {}\n    for matColor, mat in pairs(getMatForColor(\"All\")) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult > 0 then\n        usedCards[matColor] = searchResult[1]\n      end\n    end\n    return usedCards\n  end\n\n  -- Returns investigator name\n  ---@param matColor string Color of the playmat - White, Orange, Green or Red (does not support \"All\")\n  PlayermatApi.getInvestigatorName = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      local searchPos = mat.positionToWorld(localInvestigatorPosition)\n      local searchResult = searchLib.atPosition(searchPos, \"isCardOrDeck\")\n      if #searchResult == 1 then\n        return searchResult[1].getName()\n      end\n    end\n    return \"\"\n  end\n\n  -- Resets the specified skill tracker to \"1, 1, 1, 1\"\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.resetSkillTracker = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"resetSkillTracker\")\n    end\n  end\n\n  -- Updates the XML for the slot symbols based on the slotData table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.updateSlotSymbols = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"updateSlotSymbols\")\n    end\n  end\n\n  -- Finds all objects on the playermat and associated set aside zone and returns a table\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param filter? string Name of the filte function (see util/SearchLib)\n  PlayermatApi.searchAroundPlayermat = function(matColor, filter)\n    local objList = {}\n    for _, mat in pairs(getMatForColor(matColor)) do\n      for _, obj in ipairs(mat.call(\"searchAroundSelf\", filter)) do\n        table.insert(objList, obj)\n      end\n    end\n    return objList\n  end\n\n  -- Discard a non-hidden card from the corresponding player's hand\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.doDiscardOne = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"doDiscardOne\")\n    end\n  end\n\n  -- Spawns the regular action tokens\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  PlayermatApi.spawnActionTokens = function(matColor)\n    for _, mat in pairs(getMatForColor(matColor)) do\n      mat.call(\"spawnActionTokens\")\n    end\n  end\n\n  -- Triggers the metadata sync for all playermats\n  PlayermatApi.syncAllCustomizableCards = function()\n    for _, mat in pairs(getMatForColor(\"All\")) do\n      mat.call(\"syncAllCustomizableCards\")\n    end\n  end\n\n  -- moves + rotates a playermat (and related objects)\n  ---@param matColor string Color of the playermat - White, Orange, Green, Red or All\n  ---@param position? table New position for the playermat\n  ---@param rotationY? number New y-rotation for the playermat (X and Z will be 0)\n  ---@param positionOffset? table Positional offset for the playermat\n  PlayermatApi.moveAndRotate = function(matColor, position, rotationY, positionOffset)\n    -- get mat and related objects\n    local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, \"Playermat\")\n    if not mat then return end\n\n    -- get current transform data\n    local currentMatPos = mat.getPosition()\n    local currentMatRotY = mat.getRotation().y\n\n    -- use current values if undefined\n    position = position or currentMatPos\n    rotationY = rotationY or currentMatRotY\n\n    if positionOffset then\n      position = Vector(position) + Vector(positionOffset)\n    end\n\n    local movedObjects = {}\n    local function moveAndRotateObject(obj)\n      local relativePos = obj.getPosition() - currentMatPos\n      obj.setPosition(position + relativePos:rotateOver(\"y\", rotationY - currentMatRotY))\n\n      if obj.type == \"Hand\" then\n        obj.setRotation({ 0, rotationY + 180, 0 })\n      else\n        local objRot = obj.getRotation()\n        local relativeRotY = objRot.y - currentMatRotY\n        obj.setRotation({ objRot.x, rotationY + relativeRotY, objRot.z })\n      end\n\n      movedObjects[obj.getGUID()] = true\n    end\n\n    -- get objects on the mat\n    for _, obj in ipairs(searchLib.onObject(mat, \"isInteractable\")) do\n      if not movedObjects[obj.getGUID()] then\n        -- make sure object isn't owned by another mat\n        local owner = guidReferenceApi.getOwnerOfObject(obj)\n        if owner == \"Mythos\" or owner == matColor then\n          moveAndRotateObject(obj)\n        end\n      end\n    end\n\n    -- move owned objects (including the mat)\n    for _, obj in pairs(guidReferenceApi.getObjectsByOwner(matColor)) do\n      if not movedObjects[obj.getGUID()] then\n        moveAndRotateObject(obj)\n      end\n    end\n  end\n\n  return PlayermatApi\nend\nend)\n__bundle_register(\"tokens/TokenArrangerApi\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local TokenArrangerApi = {}\n  local guidReferenceApi = require(\"core/GUIDReferenceApi\")\n\n  -- internal function to create a copy of the table to avoid operating on variables owned by different objects\n  local function deepCopy(data)\n    if type(data) ~= \"table\" then return data end\n    local copiedList = {}\n    for key, value in pairs(data) do\n      if type(value) == \"table\" then\n        copiedList[key] = deepCopy(value)\n      else\n        copiedList[key] = value\n      end\n    end\n    return copiedList\n  end\n\n  -- local function to call the token arranger, if it is on the table\n  ---@param functionName string Name of the function to cal\n  ---@param argument? table Parameter to pass\n  local function callIfExistent(functionName, argument)\n    local tokenArranger = guidReferenceApi.getObjectByOwnerAndType(\"Mythos\", \"TokenArranger\")\n    if tokenArranger ~= nil then\n      return tokenArranger.call(functionName, argument)\n    end\n  end\n\n  -- updates the token modifiers with the provided data\n  ---@param fullData table Contains the chaos token metadata\n  TokenArrangerApi.onTokenDataChanged = function(fullData)\n    callIfExistent(\"onTokenDataChanged\", fullData)\n  end\n\n  -- deletes already laid out tokens\n  TokenArrangerApi.deleteCopiedTokens = function()\n    callIfExistent(\"deleteCopiedTokens\")\n  end\n\n  -- updates the laid out tokens\n  TokenArrangerApi.layout = function()\n    Wait.time(function() callIfExistent(\"layout\") end, 0.1)\n  end\n\n  TokenArrangerApi.getSaveData = function()\n    return deepCopy(callIfExistent(\"getSaveData\"))\n  end\n\n  TokenArrangerApi.loadData = function(loadedData)\n    callIfExistent(\"loadData\", loadedData)\n  end\n\n  return TokenArrangerApi\nend\nend)\n__bundle_register(\"util/SearchLib\", function(require, _LOADED, __bundle_register, __bundle_modules)\ndo\n  local SearchLib = {}\n  local filterFunctions = {\n    isCard = function(x) return x.type == \"Card\" end,\n    isDeck = function(x) return x.type == \"Deck\" end,\n    isCardOrDeck = function(x) return x.type == \"Card\" or x.type == \"Deck\" end,\n    isClue = function(x) return x.memo == \"clueDoom\" and x.is_face_down == false end,\n    isDoom = function(x) return x.memo == \"clueDoom\" and x.is_face_down == true end,\n    isInteractable = function(x) return x.interactable end,\n    isTileOrToken = function(x) return not x.Book and (x.type == \"Tile\" or x.type == \"Generic\") end,\n    isUniversalToken = function(x) return x.getMemo() == \"universalActionAbility\" end,\n  }\n\n  -- performs the actual search and returns a filtered list of object references\n  ---@param pos tts__Vector Global position\n  ---@param rot? tts__Vector Global rotation\n  ---@param size table Size\n  ---@param filter? string Name of the filter function\n  ---@param direction? table Direction (positive is up)\n  ---@param maxDistance? number Distance for the cast\n  local function returnSearchResult(pos, rot, size, filter, direction, maxDistance)\n    local filterFunc = filter and filterFunctions[filter]\n    local searchResult = Physics.cast({\n      origin       = pos,\n      direction    = direction or { 0, 1, 0 },\n      orientation  = rot or { 0, 0, 0 },\n      type         = 3,\n      size         = size,\n      max_distance = maxDistance or 0\n    })\n\n    -- filter the result for matching objects\n    local objList = {}\n    for _, v in ipairs(searchResult) do\n      if (not filter or filterFunc(v.hit_object)) then\n        table.insert(objList, v.hit_object)\n      end\n    end\n    return objList\n  end\n\n  -- searches the specified area\n  function SearchLib.inArea(pos, rot, size, filter)\n    return returnSearchResult(pos, rot, size, filter)\n  end\n\n  -- searches the area on an object\n  function SearchLib.onObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, 1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the area directly below an object\n  function SearchLib.belowObject(obj, filter, scale)\n    scale = scale or 1\n    local pos = obj.getPosition() + Vector(0, -1, 0) -- offset by half the cast's height\n    local size = obj.getBounds().size:scale(scale):setAt(\"y\", 2)\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches the specified position (a single point)\n  function SearchLib.atPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    return returnSearchResult(pos, _, size, filter)\n  end\n\n  -- searches below the specified position (downwards until y = 0)\n  function SearchLib.belowPosition(pos, filter)\n    local size = { 0.1, 2, 0.1 }\n    local direction = { 0, -1, 0 }\n    local maxDistance = pos.y\n    return returnSearchResult(pos, _, size, filter, direction, maxDistance)\n  end\n\n  return SearchLib\nend\nend)\nreturn __bundle_require(\"__root\")\n",
          "Name": "CardCustom",
          "Nickname": "Proof of Concept",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 580600,
          "CustomDeck": {
            "5806": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419631/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/042.SlipBy_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"1ed3dcf6-54aa-45ec-8800-ce7901bc7ef9\",\n  \"type\": \"Event\",\n  \"name\": \"Slip By\",\n  \"traits\": \"Tactic.Trick.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "9b91c0",
          "Name": "CardCustom",
          "Nickname": "Slip By",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 905100,
          "CustomDeck": {
            "9051": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419633/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/043.TwoStepsAhead_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"ae4771ef-e64c-47e2-888d-8e26b04f4fff\",\n  \"type\": \"Event\",\n  \"name\": \"Two Steps Ahead\",\n  \"traits\": \"Insight.Tactic.Bold.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": 2\n}",
          "GUID": "dc75fa",
          "Name": "CardCustom",
          "Nickname": "Two Steps Ahead",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 772500,
          "CustomDeck": {
            "7725": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419637/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/044.Inspect_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"32262e8d-8882-4536-b657-835705aeb0c0\",\n  \"type\": \"Skill\",\n  \"name\": \"Inspect\",\n  \"traits\": \"Practiced.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "e0f571",
          "Name": "CardCustom",
          "Nickname": "Inspect",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 442800,
          "CustomDeck": {
            "4428": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419640/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/045.SharedInsight_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"1702d362-197e-400b-8217-93cf2f868021\",\n  \"type\": \"Skill\",\n  \"name\": \"Shared Insight\",\n  \"traits\": \"Practiced.\",\n  \"class\": \"Seeker\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "35651c",
          "Name": "CardCustom",
          "Nickname": "Shared Insight",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 267700,
          "CustomDeck": {
            "2677": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419644/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/046.SeedofClarity_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"38ceeed0-a9c6-4b8c-9015-b8a6aa345422\",\n  \"type\": \"Asset\",\n  \"name\": \"Seed of Clarity\",\n  \"traits\": \"Fortune.Blessed.\",\n  \"class\": \"Seeker\",\n  \"level\": 1,\n  \"cost\": 0\n}",
          "GUID": "71dd28",
          "Name": "CardCustom",
          "Nickname": "Seed of Clarity",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 635300,
          "CustomDeck": {
            "6353": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940351785/F64D8EFB75A9E15446D24343DA0A6EEF5B3E43DB/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419646/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/047.RevelationofPurpose_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"9685ec95-f2a8-4042-b6ee-b026d279d59e\",\n  \"type\": \"Event\",\n  \"name\": \"Revelation of Purpose\",\n  \"traits\": \"Fortune.Blessed.\",\n  \"level\": -1,\n  \"cost\": 0\n}",
          "GUID": "59d5e5",
          "Name": "CardCustom",
          "Nickname": "Revelation of Purpose",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 515800,
          "CustomDeck": {
            "5158": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419648/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/048.SlipstreamTheorem_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f772c0e3-ed15-40fa-a923-369df6c87f3b\",\n  \"type\": \"Asset\",\n  \"name\": \"Slipstream Theorem\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Seeker\",\n  \"level\": 1,\n  \"cost\": 2\n}",
          "GUID": "e21f76",
          "Name": "CardCustom",
          "Nickname": "Slipstream Theorem",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 275500,
          "CustomDeck": {
            "2755": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419651/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/049.FortunateFind_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"29f41154-594b-4f5b-b035-0b74b05524cf\",\n  \"type\": \"Event\",\n  \"name\": \"Fortunate Find\",\n  \"traits\": \"Fortune.\",\n  \"class\": \"Seeker\",\n  \"level\": 1,\n  \"cost\": 0\n}",
          "GUID": "2cc28c",
          "Name": "CardCustom",
          "Nickname": "Fortunate Find",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 220200,
          "CustomDeck": {
            "2202": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419654/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/050.PatternRecognition_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d6ff5bb1-6e28-454a-acea-b69c193e12c9\",\n  \"type\": \"Event\",\n  \"name\": \"Pattern Recognition\",\n  \"traits\": \"Insight.Gambit.\",\n  \"class\": \"Seeker\",\n  \"level\": 1,\n  \"cost\": 1\n}",
          "GUID": "90eb45",
          "Name": "CardCustom",
          "Nickname": "Pattern Recognition",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 677500,
          "CustomDeck": {
            "6775": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419657/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/051.SeekingKnowledge_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d1821617-b70c-45df-b490-a9355a1058ae\",\n  \"type\": \"Asset\",\n  \"name\": \"Seeking Knowledge\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Seeker\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "6b99de",
          "Name": "CardCustom",
          "Nickname": "Seeking Knowledge",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 500000,
          "CustomDeck": {
            "5000": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415132/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/052.ArchivistsLens_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"a941e24e-114e-41ab-8cb7-275436a007e7\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Archivist's Lens\",\n  \"traits\": \"Item.Tool.Relic.Science.\",\n  \"class\": \"Seeker\",\n  \"level\": 3,\n  \"cost\": 2,\n  \"uses\": [\n    {\n      \"count\": 2,\n      \"type\": \"Secret\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "5bbc4f",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Archivist's Lens",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 344700,
          "CustomDeck": {
            "3447": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415134/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/053.EldritchInsight_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"daafcbd4-15c8-4731-898d-2666636d43b7\",\n  \"type\": \"Asset\",\n  \"name\": \"Eldritch Insight\",\n  \"traits\": \"Spell.\",\n  \"class\": \"Seeker\",\n  \"level\": 3,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 4,\n      \"type\": \"Charge\",\n      \"token\": \"resource\"\n    },\n    {\n      \"count\": 3,\n      \"type\": \"Secret\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "462595",
          "Name": "CardCustom",
          "Nickname": "Eldritch Insight",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 468500,
          "CustomDeck": {
            "4685": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415137/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/054.IntheKnow_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"fd677ef4-8375-476c-9572-258c2948c258\",\n  \"type\": \"Asset\",\n  \"name\": \"In the Know\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Seeker\",\n  \"level\": 3,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 5,\n      \"type\": \"Secret\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "a53554",
          "Name": "CardCustom",
          "Nickname": "In the Know",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 495500,
          "CustomDeck": {
            "4955": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419667/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/055.Deduction_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"565ba68d-5c47-41a0-9b44-8711846f5890\",\n  \"type\": \"Skill\",\n  \"name\": \"Deduction\",\n  \"traits\": \"Practiced.Expert.\",\n  \"class\": \"Seeker\",\n  \"level\": 3,\n  \"cost\": -1\n}",
          "GUID": "ae30a2",
          "Name": "CardCustom",
          "Nickname": "Deduction",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 543500,
          "CustomDeck": {
            "5435": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419670/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/125.FocusedField_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"9e67ad62-fa4b-45e5-8e06-d592916da3ff\",\n  \"type\": \"Event\",\n  \"name\": \"Focused Field\",\n  \"traits\": \"Insight.\",\n  \"class\": \"Neutral\",\n  \"level\": -1,\n  \"cost\": 0\n}",
          "GUID": "06aae5",
          "Name": "CardCustom",
          "Nickname": "Focused Field",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 766100,
          "CustomDeck": {
            "7661": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415143/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/013.WendyAdams_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415140/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/013.WendyAdams_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": true
            }
          },
          "Description": "The Urchin",
          "GMNotes": "{\n  \"id\": \"fc608485-056c-4371-bc77-5b30ffe0c897\",\n  \"type\": \"Investigator\",\n  \"traits\": \"Drifter.\",\n  \"class\": \"Survivor\",\n  \"willpowerIcons\": 4,\n  \"intellectIcons\": 3,\n  \"combatIcons\": 1,\n  \"agilityIcons\": 4,\n  \"extraToken\": \"Reaction\",\n  \"signatures\": [\n    {\n      \"9873ff45-a720-4ed5-8df4-b4f81a43a52d\": 1,\n      \"2e915f87-3ee3-4851-9cd1-9169910a6e14\": 1\n    }\n  ]\n}",
          "GUID": "649342",
          "HideWhenFaceDown": false,
          "Name": "CardCustom",
          "Nickname": "ðŸ…Wendy Adams",
          "SidewaysCard": true,
          "Tags": [
            "Investigator",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.15,
            "scaleY": 1.0,
            "scaleZ": 1.15
          }
        },
        {
          "CardID": 969600,
          "CustomDeck": {
            "9696": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763805688/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/014.WendysAmulet_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"9873ff45-a720-4ed5-8df4-b4f81a43a52d\",\n  \"type\": \"Asset\",\n  \"traits\": \"Item. Relic.\",\n  \"class\": \"Neutral\",\n  \"cost\": 2\n}",
          "GUID": "9a9607",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Wendy's Amulet",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 598500,
          "CustomDeck": {
            "5985": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415148/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/015.AbandonedandAlone_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2e915f87-3ee3-4851-9cd1-9169910a6e14\",\n  \"type\": \"Treachery\",\n  \"name\": \"Abandoned and Alone\",\n  \"traits\": \"Curse.\",\n  \"class\": \"å¼±ç‚¹\",\n  \"level\": -1,\n  \"cost\": -1,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Horror\",\n      \"token\": \"horror\"\n    }\n  ]\n}",
          "GUID": "ca5552",
          "Name": "CardCustom",
          "Nickname": "Abandoned and Alone",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 952700,
          "CustomDeck": {
            "9527": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419684/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/092.LumberjacksAxe_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"6bbd7f4a-0317-4985-a86c-e441feea3756\",\n  \"type\": \"Asset\",\n  \"name\": \"Lumberjack's Axe\",\n  \"traits\": \"Item.Tool.Weapon.Melee.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "241dd4",
          "Name": "CardCustom",
          "Nickname": "Lumberjack's Axe",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 357400,
          "CustomDeck": {
            "3574": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419687/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/093.NailedBoard_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"b2166ff3-1155-4209-8055-3b14f864f0bd\",\n  \"type\": \"Asset\",\n  \"name\": \"Nailed Board\",\n  \"traits\": \"Item.Weapon.Melee.Improvised.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "717983",
          "Name": "CardCustom",
          "Nickname": "Nailed Board",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 346700,
          "CustomDeck": {
            "3467": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763415151/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/094.RexTrustyRetriever_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"87740f1e-140d-45bb-82d8-e50587c560a8\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Rex, Trusty Retriever\",\n  \"traits\": \"Ally.Creature.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 3,\n  \"uses\": [\n    {\n      \"count\": 3,\n      \"type\": \"Resource\",\n      \"token\": \"resource\"\n    }\n  ]\n}",
          "GUID": "e9078f",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Rex, Trusty Retriever",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 201400,
          "CustomDeck": {
            "2014": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419693/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/095.BlindRage_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"c92b8e57-0233-4238-9e78-4957122171fb\",\n  \"type\": \"Event\",\n  \"name\": \"Blind Rage\",\n  \"traits\": \"Trick.Tactic.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "c82a87",
          "Name": "CardCustom",
          "Nickname": "Blind Rage",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 876400,
          "CustomDeck": {
            "8764": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419696/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/096.ErgonomicGrip_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"aa9ab0da-c565-4d1d-87a6-f4d51133a609\",\n  \"type\": \"Event\",\n  \"name\": \"Ergonomic Grip\",\n  \"traits\": \"Upgrade.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 3\n}",
          "GUID": "380716",
          "Name": "CardCustom",
          "Nickname": "Ergonomic Grip",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 299100,
          "CustomDeck": {
            "2991": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419700/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/097.ItAintOver_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"7cad32f3-a710-4d4f-92a2-90015d53682d\",\n  \"type\": \"Event\",\n  \"name\": \"\\\"It Ain't Over\\\"\",\n  \"traits\": \"Spirit.Tactic.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "b835ec",
          "Name": "CardCustom",
          "Nickname": "\"It Ain't Over\"",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 574500,
          "CustomDeck": {
            "5745": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419703/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/098.NightCamp_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2419ec6d-41ff-4046-9d15-c97cba10b794\",\n  \"type\": \"Event\",\n  \"name\": \"Night Camp\",\n  \"traits\": \"Spirit.Improvised.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": 0\n}",
          "GUID": "85ed19",
          "Name": "CardCustom",
          "Nickname": "Night Camp",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 938300,
          "CustomDeck": {
            "9383": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419705/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/099.FromtheAshes_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d37ebe80-d340-45ae-a01c-ebac6216cbd9\",\n  \"type\": \"Skill\",\n  \"name\": \"From the Ashes\",\n  \"traits\": \"Fortune.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "bd3617",
          "Name": "CardCustom",
          "Nickname": "From the Ashes",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 783800,
          "CustomDeck": {
            "7838": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419708/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/100.GamblersResolve_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"cc481493-e80c-4fa8-bd87-8665ea7a9f21\",\n  \"type\": \"Skill\",\n  \"name\": \"Gambler's Resolve\",\n  \"traits\": \"Gambit.\",\n  \"class\": \"Survivor\",\n  \"level\": 0,\n  \"cost\": -1\n}",
          "GUID": "e49a7e",
          "Name": "CardCustom",
          "Nickname": "Gambler's Resolve",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 133400,
          "CustomDeck": {
            "1334": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419710/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/101.WeatheredOilskin_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"f6ff98c1-f744-4d11-a1e6-a3f46d8cc50d\",\n  \"type\": \"Asset\",\n  \"name\": \"Weathered Oilskin\",\n  \"traits\": \"Item.Armor.\",\n  \"class\": \"Survivor\",\n  \"level\": 1,\n  \"cost\": 1\n}",
          "GUID": "4ba9c8",
          "Name": "CardCustom",
          "Nickname": "Weathered Oilskin",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 243500,
          "CustomDeck": {
            "2435": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419712/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/102.CleartheDeck_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"dd4820e0-c7b0-47dc-bbd4-fc5363e4318d\",\n  \"type\": \"Event\",\n  \"name\": \"Clear the Deck\",\n  \"traits\": \"Tactic.Improvised.\",\n  \"class\": \"Survivor\",\n  \"level\": 1,\n  \"cost\": 3\n}",
          "GUID": "ec95c9",
          "Name": "CardCustom",
          "Nickname": "Clear the Deck",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 284200,
          "CustomDeck": {
            "2842": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419714/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/103.FrayedToken_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d5259e9c-9c75-435f-84ff-b2f3cd66eb04\",\n  \"type\": \"Asset\",\n  \"name\": \"ðŸ…Frayed Token\",\n  \"traits\": \"Item.Relic.\",\n  \"class\": \"Survivor\",\n  \"level\": 2,\n  \"cost\": 2\n}",
          "GUID": "f3bac3",
          "Name": "CardCustom",
          "Nickname": "ðŸ…Frayed Token",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 782000,
          "CustomDeck": {
            "7820": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419716/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/104.StrayCat_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"67f760d7-549b-4010-a37d-fca9b9fd5271\",\n  \"type\": \"Asset\",\n  \"name\": \"Stray Cat\",\n  \"traits\": \"Ally.Creature.\",\n  \"class\": \"Survivor\",\n  \"level\": 2,\n  \"cost\": 1\n}",
          "GUID": "704b43",
          "Name": "CardCustom",
          "Nickname": "Stray Cat",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 447200,
          "CustomDeck": {
            "4472": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419720/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/105.ErgonomicGrip_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"20c7f505-31da-4a1a-b0b0-b988e9c7210c\",\n  \"type\": \"Event\",\n  \"name\": \"Ergonomic Grip\",\n  \"traits\": \"Upgrade.\",\n  \"class\": \"Survivor\",\n  \"level\": 2,\n  \"cost\": 3\n}",
          "GUID": "772e66",
          "Name": "CardCustom",
          "Nickname": "Ergonomic Grip",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 763200,
          "CustomDeck": {
            "7632": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419722/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/106.PlantedEvidence_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d3d5dc70-58ba-4cc3-9a02-70cfaf3c4a45\",\n  \"type\": \"Event\",\n  \"name\": \"Planted Evidence\",\n  \"traits\": \"Illicit.Trick.\",\n  \"class\": \"Survivor\",\n  \"level\": 2,\n  \"cost\": 1\n}",
          "GUID": "fd35f3",
          "Name": "CardCustom",
          "Nickname": "Planted Evidence",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 233000,
          "CustomDeck": {
            "2330": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419725/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/107.JunkyardInstinct_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"04045206-a2ee-445d-9c97-36e7a9aa32e0\",\n  \"type\": \"Asset\",\n  \"name\": \"Junkyard Instinct\",\n  \"traits\": \"Talent.\",\n  \"class\": \"Survivor\",\n  \"level\": 3,\n  \"cost\": 2\n}",
          "GUID": "c1b692",
          "Name": "CardCustom",
          "Nickname": "Junkyard Instinct",
          "Tags": [
            "Asset",
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 800700,
          "CustomDeck": {
            "8007": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419727/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/108.ButterflyEffect_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"43e5c76c-d4a3-42ce-834c-e3c62522b0d7\",\n  \"type\": \"Event\",\n  \"name\": \"Butterfly Effect\",\n  \"traits\": \"Paradox.Blessed.Cursed.\",\n  \"class\": \"Survivor\",\n  \"level\": 3,\n  \"cost\": 0\n}",
          "GUID": "8c5852",
          "Name": "CardCustom",
          "Nickname": "Butterfly Effect",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 197800,
          "CustomDeck": {
            "1978": {
              "BackIsHidden": true,
              "BackURL": "https://steamusercontent-a.akamaihd.net/ugc/2342503777940352139/A2D42E7E5C43D045D72CE5CFC907E4F886C8C690/",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1762419729/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/109.TenaciousResolve_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"8dac66c4-21a7-4070-9378-8ce3d53e81c1\",\n  \"type\": \"Skill\",\n  \"name\": \"Tenacious Resolve\",\n  \"traits\": \"Innate.\",\n  \"class\": \"Survivor\",\n  \"level\": 3,\n  \"cost\": -1\n}",
          "GUID": "4c2c4b",
          "Name": "CardCustom",
          "Nickname": "Tenacious Resolve",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 1.0,
            "scaleY": 1.0,
            "scaleZ": 1.0
          }
        },
        {
          "CardID": 691300,
          "CustomDeck": {
            "6913": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479343/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/RolandBanksMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479340/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/RolandBanksMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"d545b38e-f3cf-486a-a026-12ed94b33453-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "20b8ca",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        },
        {
          "CardID": 895800,
          "CustomDeck": {
            "8958": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479494/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/AgnesBakerMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479492/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/AgnesBakerMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"43c6f1af-6bfc-40f6-af6c-a597816517b1-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "8cc477",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        },
        {
          "CardID": 216300,
          "CustomDeck": {
            "2163": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479614/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/YithianMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479612/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/YithianMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"2f687951-04fa-40ba-b21a-9c2cf4c2e9e2-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "d9db64",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        },
        {
          "CardID": 729100,
          "CustomDeck": {
            "7291": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479617/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/SkidsOTooleMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479616/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/SkidsOTooleMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"48bd399e-1d7d-4b95-8a88-1145f95eae14-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "9b2261",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        },
        {
          "CardID": 869200,
          "CustomDeck": {
            "8692": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479620/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/DaisyWalkerMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479619/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/DaisyWalkerMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"7b48d829-0095-4b3e-a2c3-8fa609d111e2-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "93264f",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        },
        {
          "CardID": 481900,
          "CustomDeck": {
            "4819": {
              "BackIsHidden": true,
              "BackURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479623/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/WendyAdamsMini_back.jpg",
              "FaceURL": "https://res.cloudinary.com/dxdnloddw/image/upload/v1763479622/Return_to_Night_of_the_Zealot_Custom_Investigator_Expansion/WendyAdamsMini_front.jpg",
              "NumHeight": 1,
              "NumWidth": 1,
              "Type": 0,
              "UniqueBack": false
            }
          },
          "GMNotes": "{\n  \"id\": \"fc608485-056c-4371-bc77-5b30ffe0c897-m\",\n  \"type\": \"Minicard\"\n}",
          "GUID": "c0bf92",
          "Name": "CardCustom",
          "Nickname": "",
          "Tags": [
            "PlayerCard"
          ],
          "Transform": {
            "rotY": 270,
            "scaleX": 0.6,
            "scaleY": 1.0,
            "scaleZ": 0.6
          }
        }
      ],
      "CustomMesh": {
        "CustomShader": {
          "FresnelStrength": 0.0,
          "SpecularColor": {
            "b": 1.0,
            "g": 1.0,
            "r": 1.0
          },
          "SpecularIntensity": 0.0,
          "SpecularSharpness": 2.0
        },
        "DiffuseURL": "https://steamusercontent-a.akamaihd.net/ugc/2450601198422160026/E21C455A90B78E48E0D03FCA4AF52A9C33C31534/",
        "MaterialIndex": 3,
        "MeshURL": "https://steamusercontent-a.akamaihd.net/ugc/62583916778515295/AFB8F257CE1E4973F4C06160A2E156C147AEE1E3/",
        "TypeIndex": 6
      },
      "Description": "A full rework of the five Core Set investigators, along with a complete support set to reinforce early archetypes from the Core through The Forgotten Age. This set includes 124 new cards total, 6 investigators, each with unique signature cards, 9 level 0 and 9 upgraded cards for each class, 12 neutral cards and 3 basic weaknesses. - ç”±é˜¿å¡å§†å°ç‰Œå§¬ç”Ÿæˆ",
      "GUID": "557fdc",
      "Hands": false,
      "HideWhenFaceDown": false,
      "Name": "Custom_Model_Bag",
      "Nickname": "Unofficial Return to Night of the Zealot - Investigator Expansion",
      "Transform": {
        "rotY": 270,
        "scaleX": 1.0,
        "scaleY": 0.14,
        "scaleZ": 1.0
      }
    },
    {
      "ColorDiffuse": {
        "b": 1.0,
        "g": 1.0,
        "r": 1.0
      },
      "CustomPDF": {
        "PDFPage": 0,
        "PDFPageOffset": 0,
        "PDFPassword": "",
        "PDFUrl": "https://steamusercontent-a.akamaihd.net/ugc/18010575805875998625/44D49ED0726CEAF7B8E4CEC0442ED85F9E7067AE/"
      },
      "GUID": "d29c3d",
      "Hands": false,
      "HideWhenFaceDown": false,
      "Name": "Custom_PDF",
      "Nickname": "",
      "Transform": {
        "rotY": 270,
        "scaleX": 2.12,
        "scaleY": 1.0,
        "scaleZ": 2.12
      }
    },
    {
      "ColorDiffuse": {
        "b": 1.0,
        "g": 1.0,
        "r": 1.0
      },
      "Description": "Click on this button to place all the cards. The actual memory bag can be found in the \"Additional Player Cards\" box.\n\nYou can delete this note.",
      "GUID": "beb0b4",
      "Hands": false,
      "HideWhenFaceDown": false,
      "Name": "Notecard",
      "Nickname": "/\\",
      "Transform": {
        "rotY": 90,
        "scaleX": 1.0,
        "scaleY": 1.0,
        "scaleZ": 1.0
      }
    }
  ],
  "CustomMesh": {
    "ColliderURL": "https://steamusercontent-a.akamaihd.net/ugc/62583916778515251/E1C8E8EDBCFEDCB529D88539FD89104537DE3584/",
    "CustomShader": {
      "FresnelStrength": 0.0,
      "SpecularColor": {
        "b": 1.0,
        "g": 1.0,
        "r": 1.0
      },
      "SpecularIntensity": 0.0,
      "SpecularSharpness": 2.0
    },
    "DiffuseURL": "https://steamusercontent-a.akamaihd.net/ugc/10646293062076402524/4308C110D4F0756E4827A25324CE9C9887829D05/",
    "MaterialIndex": 3,
    "MeshURL": "https://steamusercontent-a.akamaihd.net/ugc/62583916778515295/AFB8F257CE1E4973F4C06160A2E156C147AEE1E3/",
    "TypeIndex": 6
  },
  "Description": "by Seymour",
  "GMNotes": "{\"filename\":\"unofficial_return_to_the_night_of_the_zealot_investigator_expansion\"}",
  "GUID": "564334",
  "Hands": false,
  "HideWhenFaceDown": false,
  "LuaScript": "-- Bundled by luabundle {\"version\":\"1.6.0\"}\nlocal __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)\n\tlocal loadingPlaceholder = {[{}] = true}\n\n\tlocal register\n\tlocal modules = {}\n\n\tlocal require\n\tlocal loaded = {}\n\n\tregister = function(name, body)\n\t\tif not modules[name] then\n\t\t\tmodules[name] = body\n\t\tend\n\tend\n\n\trequire = function(name)\n\t\tlocal loadedModule = loaded[name]\n\n\t\tif loadedModule then\n\t\t\tif loadedModule == loadingPlaceholder then\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\tif not modules[name] then\n\t\t\t\tif not superRequire then\n\t\t\t\t\tlocal identifier = type(name) == 'string' and '\\\"' .. name .. '\\\"' or tostring(name)\n\t\t\t\t\terror('Tried to require ' .. identifier .. ', but no such module has been registered')\n\t\t\t\telse\n\t\t\t\t\treturn superRequire(name)\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tloaded[name] = loadingPlaceholder\n\t\t\tloadedModule = modules[name](require, loaded, register, modules)\n\t\t\tloaded[name] = loadedModule\n\t\tend\n\n\t\treturn loadedModule\n\tend\n\n\treturn require, loaded, register, modules\nend)(nil)\n__bundle_register(\"MemoryBag\", function(require, _LOADED, __bundle_register, __bundle_modules)\nfunction updateSave()\n  self.script_state = JSON.encode({ ml = memoryList, setupButton = setupButton })\nend\n\nfunction onLoad(savedData)\n  if savedData and savedData ~= \"\" then\n    local loadedData = JSON.decode(savedData)\n    memoryList = loadedData.ml\n    setupButton = loadedData.setupButton\n  end\n\n  memoryList = memoryList or {}\n  self.addContextMenuItem(\"Toggle setup button\", toggleSetupButton)\n\n  -- make sure the model is loaded so that we can use the bounds\n  Wait.condition(function()\n    Wait.frames(function()\n      generateButtonData()\n      createMemoryActionButtons()\n    end, 5)\n  end, function() return not self.loading_custom end)\nend\n\nfunction generateButtonData()\n  local selfScale = self.getScale()\n  local selfBounds = self.getBoundsNormalized()\n  buttonScale = Vector(1 / selfScale.x, 1, 1 / selfScale.z)\n\n  buttonX = math.max(selfBounds.size.x / 5, 1.5) / selfScale.x\n  buttonY = -(selfBounds.size.y / 2 + selfBounds.offset.y) / selfScale.y + 0.5\n  buttonZ = {}\n  for i = 1, 4 do\n    buttonZ[i] = (selfBounds.size.z / 2 + i * 1.15 - 0.15) / selfScale.z\n  end\n\n  local upperButtonMult = 1.1\n  buttonData = {\n    [\"Add\"]       = {\n      tooltip = \"Add highlighted objects to memory\",\n      pos = { buttonX * upperButtonMult, buttonY, -buttonZ[1] },\n      fColor = { 0.25, 1, 0.25 }\n    },\n    [\"Cancel\"]    = {\n      tooltip = \"Abort setup mode\",\n      pos = { -buttonX * upperButtonMult, buttonY, -buttonZ[1] },\n    },\n    [\"Internal\"]    = {\n      tooltip = \"Copy memory from internal bags\",\n      pos = { -buttonX * upperButtonMult, buttonY, -buttonZ[4] },\n    },\n    [\"Place\"]     = {\n      pos = { buttonX, buttonY, buttonZ[1] },\n      fSize = 350,\n      w = 1200\n    },\n    [\"Recall\"]    = {\n      pos = { -buttonX, buttonY, buttonZ[1] },\n      fSize = 350,\n      w = 1200\n    },\n    [\"Remove\"]    = {\n      tooltip = \"Remove highlighted objects from memory\",\n      pos = { buttonX * upperButtonMult, buttonY, -buttonZ[2] },\n      fColor = { 1, 0.25, 0.25 }\n    },\n    [\"Reset\"]     = {\n      tooltip = \"Completely reset memory\",\n      pos = { -buttonX * upperButtonMult, buttonY, -buttonZ[3] },\n    },\n    [\"Selection\"] = {\n      tooltip = \"Add / Remove highlight for selected objects\",\n      pos = { -buttonX * upperButtonMult, buttonY, -buttonZ[2] },\n    },\n    [\"Setup\"]     = {\n      pos = { 0, buttonY, -buttonZ[1] },\n      fSize = 350\n    },\n    [\"Update\"]   = {\n      tooltip = \"Update memory for placed objects\",\n      pos = { buttonX * upperButtonMult, buttonY, -buttonZ[3] },\n      fColor = { 0.75, 0.75, 1 }\n    }\n  }\nend\n\nfunction createButtonByName(label)\n  self.createButton({\n    label = label,\n    tooltip = buttonData[label].tooltip or \"\",\n    position = buttonData[label].pos,\n    height = buttonData[label].h or 500,\n    width = buttonData[label].w or 1500,\n    font_size = buttonData[label].fSize or 325,\n    font_color = buttonData[label].fColor or { 1, 1, 1 },\n    function_owner = self,\n    color = { 0, 0, 0 },\n    scale = buttonScale,\n    click_function = \"buttonClick_\" .. string.lower(string.gsub(label, \"%s+\", \"\"))\n  })\nend\n\n-- context menu function to toggle the setup button visibility\nfunction toggleSetupButton()\n  if setupButton then\n    setupButton = false\n    broadcastToAll(\"Setup button disabled\")\n  else\n    setupButton = true\n    broadcastToAll(\"Setup button enabled\")\n  end\n  updateSave()\n  removeAllHighlights()\n  createMemoryActionButtons()\nend\n\nfunction buttonClick_setup()\n  tempList = {}\n  self.clearButtons()\n  createButtonsOnAllObjects()\n  createSetupActionButtons()\nend\n\nfunction broadcastFeedback(str1, count, name, str2, color)\n  local bcStr = count .. \" \" .. name\n  if str1 then\n    bcStr = str1 .. \" \" .. bcStr\n  end\n  if count ~= 1 then\n    bcStr = bcStr .. \"s\"\n  end\n  if str2 then\n    bcStr = bcStr .. \" \" .. str2\n  end\n  broadcastToAll(bcStr, color)\nend\n\nfunction createButtonsOnAllObjects()\n  buttonIndexMap = {}\n\n  local buttonCount = 0\n  for _, obj in ipairs(getObjects()) do\n    if obj ~= self and obj.type ~= \"Scripting\" and obj.type ~= \"Hand\" then\n      local objPos = obj.getPosition()\n      local objBounds = obj.getBounds()\n      local offSet = Vector(0, objBounds.size.y / 2 + 1, 0)\n      local scaleVec = Vector(-1, 1, 1)\n      local buttonPos = self.positionToLocal(objPos + offSet):scale(scaleVec)\n\n      local fName = \"selectButton_\" .. buttonCount\n      _G[fName] = function() buttonClick_selectObject(obj) end\n      self.createButton({\n        click_function = fName,\n        function_owner = self,\n        position = buttonPos,\n        height = 600,\n        width = 600,\n        color = { 0.75, 0.25, 0.25, 0.75 },\n        scale = buttonScale\n      })\n      buttonIndexMap[obj.getGUID()] = buttonCount\n      buttonCount = buttonCount + 1\n    end\n  end\nend\n\nfunction createSetupActionButtons()\n  createButtonByName(\"Cancel\")\n  createButtonByName(\"Selection\")\n  createButtonByName(\"Reset\")\n  createButtonByName(\"Internal\")\n  createButtonByName(\"Add\")\n\n  if next(memoryList) then\n    createButtonByName(\"Remove\")\n    createButtonByName(\"Update\")\n  end\nend\n\nfunction buttonClick_selectObject(obj)\n  local guid = obj.getGUID()\n  local index = buttonIndexMap[guid]\n  if not index then return end\n\n  if tempList[guid] == nil then\n    self.editButton({ index = index, color = { 0, 1, 0, 0.75 } })\n    tempList[guid] = {\n      pos = roundVector(obj.getPosition(), 3),\n      rot = roundVector(obj.getRotation(), 0),\n      lock = obj.getLock()\n    }\n    obj.highlightOn({ 0, 1, 0 })\n  else\n    self.editButton({ index = index, color = { 0.75, 0.25, 0.25, 0.75 } })\n    tempList[guid] = nil\n    obj.highlightOff()\n  end\nend\n\nfunction buttonClick_cancel()\n  broadcastToAll(\"Setup Canceled\")\n  removeAllHighlights()\n  createMemoryActionButtons()\nend\n\nfunction buttonClick_selection(_, playerColor)\n  local objList = Player[playerColor].getSelectedObjects()\n\n  if #objList == 0 then\n    broadcastToAll(\"No objects selected!\")\n  else\n    broadcastFeedback(\"Toggled selection for\", #objList, \"object\")\n    for _, obj in ipairs(objList) do\n      buttonClick_selectObject(obj)\n    end\n  end\nend\n\nfunction buttonClick_add()\n  local count = 0\n  for _ in pairs(tempList) do\n    count = count + 1\n  end\n  broadcastFeedback(\"Added\", count, \"Object\", \"from selection\")\n\n  -- copy data from tempList to memoryList\n  for guid, entry in pairs(tempList) do\n    memoryList[guid] = entry\n  end\n\n  updateSave()\n  removeAllHighlights()\n  createMemoryActionButtons()\nend\n\nfunction buttonClick_update()\n  local count = 0\n  for guid, entry in pairs(memoryList) do\n    local obj = getObjectFromGUID(guid)\n    if obj ~= nil then\n      count = count + 1\n      memoryList[guid] = {\n        pos = roundVector(obj.getPosition(), 3),\n        rot = roundVector(obj.getRotation(), 0),\n        lock = obj.getLock()\n      }\n    end\n  end\n  broadcastFeedback(\"Updated data for\", count, \"Object\")\n  updateSave()\nend\n\nfunction buttonClick_remove()\n  local count = 0\n  for guid in pairs(tempList) do\n    count = count + 1\n    memoryList[guid] = nil\n  end\n  broadcastFeedback(_, count, \"Object\", \"Removed\", { 1, 1, 1 })\n\n  updateSave()\n  removeAllHighlights()\n  createMemoryActionButtons()\nend\n\nfunction buttonClick_setNew()\n  local count = 0\n  for _, obj in ipairs(getObjects()) do\n    if memoryList[obj.guid] then\n      count = count + 1\n      memoryList[obj.guid].pos = roundVector(obj.getPosition(), 3)\n      memoryList[obj.guid].rot = roundVector(obj.getRotation(), 0)\n      memoryList[obj.guid].lock = obj.getLock()\n    end\n  end\n  broadcastFeedback(\"Updated Data for\", count, \"Object\", _, { 1, 1, 1 })\n  updateSave()\n  createMemoryActionButtons()\nend\n\nfunction buttonClick_reset()\n  memoryList = {}\n  updateSave()\n  removeAllHighlights()\n  broadcastToAll(\"Tool Reset\", { 1, 1, 1 })\n  self.clearButtons()\n\n  if setupButton then\n    createButtonByName(\"Setup\")\n  end\nend\n\nfunction buttonClick_internal()\n  local count = 0\n  for _, bagObj in ipairs(self.getObjects()) do\n    local data = bagObj.lua_script_state\n    if data ~= nil then\n      local j = JSON.decode(data)\n      if j ~= nil and j.ml ~= nil then\n        count = count + 1\n        for guid, entry in pairs(j.ml) do\n          memoryList[guid] = entry\n        end\n      end\n    end\n  end\n\n  if count > 0 then\n    broadcastFeedback(\"Added\", count, \"internal bag\", \"to existing memory\")\n  end\nend\n\nfunction createMemoryActionButtons()\n  self.clearButtons()\n\n  if next(memoryList) then\n    createButtonByName(\"Place\")\n    createButtonByName(\"Recall\")\n  end\n\n  if setupButton then\n    createButtonByName(\"Setup\")\n  end\nend\n\n-- Sends objects from bag/table to their saved position/rotation\nfunction buttonClick_place()\n  local data = self.getData()\n\n  -- get names of contained objects\n  local guidToName = {}\n  for _, bagObjData in ipairs(data.ContainedObjects or {}) do\n    guidToName[bagObjData[\"GUID\"]] = bagObjData[\"Nickname\"]\n  end\n\n  local updateGuids = {}\n  local placeCount = 0\n  local moveCount = 0\n  for guid, entry in pairs(memoryList) do\n    local obj = getObjectFromGUID(guid)\n    if obj ~= nil and (obj.getName() == guidToName[guid] or guidToName[guid] == nil) then\n      -- If obj is out on the table and has the same name (or there's no contained copy), move it\n      moveCount = moveCount + 1\n      obj.setPositionSmooth(entry.pos)\n      obj.setRotationSmooth(entry.rot)\n      obj.setLock(entry.lock)\n    elseif guidToName[guid] then\n      -- If obj is inside of the bag\n      placeCount = placeCount + 1\n      local item = self.takeObject({\n        guid = guid,\n        position = entry.pos,\n        rotation = entry.rot,\n        smooth = false\n      })\n      item.setLock(entry.lock)\n\n      if obj ~= nil then\n        updateGuids[guid] = item.getGUID()\n      end\n    end\n  end\n\n  -- update memoryList if we placed an item that got a new GUID\n  if next(updateGuids) then\n    for oldGuid, newGuid in pairs(updateGuids) do\n      memoryList[newGuid] = memoryList[oldGuid]\n      memoryList[oldGuid] = nil\n    end\n    updateSave()\n  end\n\n  if placeCount > 0 then\n    broadcastFeedback(_, placeCount, \"Object\", \"Placed\", { 1, 1, 1 })\n  end\n\n  if moveCount > 0 then\n    broadcastFeedback(_, moveCount, \"Object\", \"Moved\", { 1, 1, 1 })\n  end\n\n  if placeCount == 0 and moveCount == 0 then\n    broadcastToAll(\"Bag is empty and no matching objects were found in play\", { 1, 1, 1 })\n  end\nend\n\nfunction buttonClick_recall()\n  local count = 0\n  for guid, _ in pairs(memoryList) do\n    local obj = getObjectFromGUID(guid)\n    if obj ~= nil then\n      self.putObject(obj)\n      count = count + 1\n    end\n  end\n  broadcastFeedback(_, count, \"Object\", \"Recalled\", { 1, 1, 1 })\nend\n\nfunction removeAllHighlights()\n  for _, obj in ipairs(getObjects()) do\n    obj.highlightOff()\n  end\nend\n\n-- Round vector to the Nth decimal\nfunction roundVector(vec, dec)\n  local mult = 10 ^ (dec or 0)\n  local t = {}\n  for _, k in ipairs({ \"x\", \"y\", \"z\" }) do\n    t[k] = math.floor(vec[k] * mult + 0.5) / mult\n  end\n  return t\nend\nend)\n__bundle_register(\"__root\", function(require, _LOADED, __bundle_register, __bundle_modules)\nrequire(\"MemoryBag\")\nend)\nreturn __bundle_require(\"__root\")",
  "LuaScriptState": "{\"ml\":{\"557fdc\":{\"lock\":false,\"pos\":{\"x\":62.317,\"y\":2.181,\"z\":46.877},\"rot\":{\"x\":0,\"y\":270,\"z\":0}},\"beb0b4\":{\"lock\":false,\"pos\":{\"x\":49.919,\"y\":1.647,\"z\":74.188},\"rot\":{\"x\":357,\"y\":90,\"z\":0}},\"d29c3d\":{\"lock\":false,\"pos\":{\"x\":49.797,\"y\":1.481,\"z\":47.138},\"rot\":{\"x\":0,\"y\":270,\"z\":0}}},\"setupButton\":true}",
  "Name": "Custom_Model_Bag",
  "Nickname": "Unofficial Return to Night of the Zealot - Investigator Expansion",
  "Tags": [
    "Reloadable"
  ],
  "Transform": {
    "posX": 0,
    "posY": 1.5,
    "posZ": 0,
    "rotX": 0,
    "rotY": 270,
    "rotZ": 0,
    "scaleX": 1.0,
    "scaleY": 0.14,
    "scaleZ": 1.0
  }
}
