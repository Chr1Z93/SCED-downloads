function updateSave()
  self.script_state = JSON.encode({ ml = memoryList, setupButton = setupButton })
end

function onLoad(savedData)
  if savedData ~= "" then
    local loadedData = JSON.decode(savedData)
    memoryList = loadedData.ml
    setupButton = loadedData.setupButton
  end

  memoryList = memoryList or {}
  self.addContextMenuItem("Toggle setup button", toggleSetupButton)

  -- make sure the model is loaded so that we can use the bounds
  Wait.condition(function()
    selfScale = self.getScale()
    selfBounds = self.getBoundsNormalized()
    buttonX = math.max(selfBounds.size.x / 5, 1.5) / selfScale.x
    buttonY = -(selfBounds.size.y / 2 + selfBounds.offset.y) / selfScale.y + 0.5

    -- get z-positions
    buttonZ = {}
    for i = 1, 3 do
      buttonZ[i] = (selfBounds.size.z / 2 + i * 1.15 - 0.15) / selfScale.z
    end
    buttonScale = Vector(1 / selfScale.x, 1, 1 / selfScale.z)

    createMemoryActionButtons()
  end, function() return not self.loading_custom end)
end

-- context menu function to toggle the setup button visibility
function toggleSetupButton()
  if setupButton then
    setupButton = false
    broadcastToAll("Setup button disabled", { 1, 1, 1 })
  else
    setupButton = true
    broadcastToAll("Setup button enabled", { 1, 1, 1 })
  end
  removeAllHighlights()
  createMemoryActionButtons()
end

function combineMemoryFromBagsWithin()
  local bagObjList = self.getObjects()
  for _, bagObj in ipairs(bagObjList) do
    local data = bagObj.lua_script_state
    if data ~= nil then
      local j = JSON.decode(data)
      if j ~= nil and j.ml ~= nil then
        for guid, entry in pairs(j.ml) do
          memoryList[guid] = entry
        end
      end
    end
  end
end

-- Beginning Setup
function createSetupButton()
  if setupButton ~= true then return end
  self.createButton({
    label = "Setup",
    click_function = "buttonClick_setup",
    function_owner = self,
    position = { x = 0, y = buttonY, z = -buttonZ[1] },
    height = 500,
    width = 1200,
    font_size = 350,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  })
end

function buttonClick_setup()
  tempList = {}
  self.clearButtons()
  createButtonsOnAllObjects()
  createSetupActionButtons()
end

-- Creates selection buttons on objects
function createButtonsOnAllObjects()
  buttonIndexMap = {}

  local color = { 0.75, 0.25, 0.25, 0.75 }
  local buttonCount = 0
  for _, obj in ipairs(getObjects()) do
    if obj ~= self and obj.type ~= "Scripting" and obj.type ~= "Hand" then
      local objPos = obj.getPosition()
      local objBounds = obj.getBounds()
      local offSet = Vector(0, objBounds.size.y / 2 + 1, 0)
      local scaleVec = Vector(-1, 1, 1)
      local buttonPos = self.positionToLocal(objPos + offSet):scale(scaleVec)

      local fName = "selectButton_" .. buttonCount
      _G[fName] = function() buttonClick_selectObject(obj) end
      self.createButton({
        click_function = fName,
        function_owner = self,
        position = buttonPos,
        height = 600,
        width = 600,
        color = color,
        scale = buttonScale
      })
      buttonIndexMap[obj.getGUID()] = buttonCount
      buttonCount = buttonCount + 1
    end
  end
end

-- Creates submit and cancel buttons
function createSetupActionButtons()
  local bWidth = 1500
  local bHeight = 500
  local bParams = {
    function_owner = self,
    height = bHeight,
    width = bWidth,
    font_size = 325,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  }

  bParams.label = "Cancel"
  bParams.tooltip = "Abort setup mode"
  bParams.click_function = "buttonClick_cancel"
  bParams.position = { x = -buttonX, y = buttonY, z = -buttonZ[1] }
  self.createButton(bParams)

  bParams.label = "Selection"
  bParams.click_function = "buttonClick_selection"
  bParams.position = { x = -buttonX, y = buttonY, z = -buttonZ[2] }
  self.createButton(bParams)

  bParams.label = "Reset"
  bParams.click_function = "buttonClick_reset"
  bParams.position = { x = -buttonX, y = buttonY, z = -buttonZ[3]}
  self.createButton(bParams)

  bParams.label = "Add"
  bParams.click_function = "buttonClick_add"
  bParams.position = { x = buttonX, y = buttonY, z = -buttonZ[1] }
  bParams.font_color = { 0.25, 1, 0.25 }
  self.createButton(bParams)

  if next(memoryList) then
    bParams.label = "Set New"
    bParams.click_function = "buttonClick_setNew"
    bParams.position = { x = buttonX, y = buttonY, z = -buttonZ[3] }
    bParams.font_color = { 0.75, 0.75, 1 }
    self.createButton(bParams)

    bParams.label = "Remove"
    bParams.click_function = "buttonClick_remove"
    bParams.position = { x = buttonX, y = buttonY, z = -buttonZ[2] }
    bParams.font_color = { 1, 0.25, 0.25 }
    self.createButton(bParams)
  end
end

-- During Setup
-- Checks or unchecks buttons
function buttonClick_selectObject(obj)
  local guid = obj.getGUID()
  local index = buttonIndexMap[guid]
  if not index then return end

  local color
  if tempList[guid] == nil then
    color = { 0, 1, 0, 0.75 }
    tempList[guid] = {
      pos = roundVector(obj.getPosition(), 3),
      rot = roundVector(obj.getRotation(), 0),
      lock = obj.getLock()
    }
    obj.highlightOn({ 0, 1, 0 })
  else
    color = { 0.75, 0.25, 0.25, 0.75 }
    tempList[guid] = nil
    obj.highlightOff()
  end

  self.editButton({ index = index, color = color })
end

-- Cancels selection process
function buttonClick_cancel()
  broadcastToAll("Setup Canceled", { 1, 1, 1 })
  removeAllHighlights()
  createMemoryActionButtons()
end

-- Executes the selectObject function for each selected object
function buttonClick_selection(_, playerColor)
  local selectedObjs = Player[playerColor].getSelectedObjects()
  for _, obj in ipairs(selectedObjs) do
    buttonClick_selectObject(obj)
  end
end

function buttonClick_add()
  combineTables(memoryList, tempList)
  broadcastToAll("Adding internal bags to existing memory", { 0.25, 0.75, 0.25 })
  combineMemoryFromBagsWithin()

  local count = 0
  for _ in pairs(tempList) do
    count = count + 1
  end
  broadcastToAll("Added " .. count .. " Object(s) from selection", { 1, 1, 1 })

  updateSave()
  removeAllHighlights()
  createMemoryActionButtons()
end

function buttonClick_remove()
  local count = 0
  for guid in pairs(tempList) do
    count = count + 1
    memoryList[guid] = nil
  end
  broadcastToAll(count .. " Object(s) Removed", { 1, 1, 1 })

  updateSave()
  removeAllHighlights()
  createMemoryActionButtons()
end

function buttonClick_setNew()
  local count = 0
  for _, obj in ipairs(getObjects()) do
    if memoryList[obj.guid] then
      count = count + 1
      memoryList[obj.guid].pos = roundVector(obj.getPosition(), 3)
      memoryList[obj.guid].rot = roundVector(obj.getRotation(), 0)
      memoryList[obj.guid].lock = obj.getLock()
    end
  end
  broadcastToAll("Updated Data for " .. count .. " Object(s)", { 1, 1, 1 })
  updateSave()
  createMemoryActionButtons()
end

-- Resets bag to starting status
function buttonClick_reset()
  self.clearButtons()
  memoryList = {}
  updateSave()

  createSetupButton()
  removeAllHighlights()
  broadcastToAll("Tool Reset", { 1, 1, 1 })
end

-- After Setup
-- Creates recall and place buttons
function createMemoryActionButtons()
  self.clearButtons()

  if next(memoryList) then
    self.createButton({
      label = "Place",
      click_function = "buttonClick_place",
      function_owner = self,
      position = { x = buttonX, y = buttonY, z = buttonZ[1] },
      height = 500,
      width = 1200,
      font_size = 350,
      color = { 0, 0, 0 },
      font_color = { 1, 1, 1 },
      scale = buttonScale
    })
    self.createButton({
      label = "Recall",
      click_function = "buttonClick_recall",
      function_owner = self,
      position = { x = -buttonX, y = buttonY, z = buttonZ[1] },
      height = 500,
      width = 1200,
      font_size = 350,
      color = { 0, 0, 0 },
      font_color = { 1, 1, 1 },
      scale = buttonScale
    })
  end
  createSetupButton()
end

-- Sends objects from bag/table to their saved position/rotation
function buttonClick_place()
  local data = self.getData()

  -- get names of contained objects
  local guidToName = {}
  for _, bagObjData in ipairs(data.ContainedObjects or {}) do
    guidToName[bagObjData["GUID"]] = bagObjData["Nickname"]
  end

  local updateGuids = {}
  local placeCount = 0
  local moveCount = 0
  for guid, entry in pairs(memoryList) do
    local obj = getObjectFromGUID(guid)
    if obj ~= nil and obj.getName() == guidToName[guid] then
      -- If obj is out on the table and has the same name, move it
      moveCount = moveCount + 1
      obj.setPositionSmooth(entry.pos)
      obj.setRotationSmooth(entry.rot)
      obj.setLock(entry.lock)
    elseif guidToName[guid] then
      -- If obj is inside of the bag
      placeCount = placeCount + 1
      local item = self.takeObject({
        guid = guid,
        position = entry.pos,
        rotation = entry.rot,
        smooth = false
      })
      item.setLock(entry.lock)

      if obj ~= nil then
        updateGuids[guid] = item.getGUID()
      end
    end
  end

  -- update memoryList if we placed an item that got a new GUID
  if next(updateGuids) then
    for oldGuid, newGuid in pairs(updateGuids) do
      memoryList[newGuid] = memoryList[oldGuid]
      memoryList[oldGuid] = nil
    end
    updateSave()
  end

  if placeCount > 0 then
    broadcastToAll(placeCount .. " Object(s) Placed", { 1, 1, 1 })
  end

  if moveCount > 0 then
    broadcastToAll(moveCount .. " Object(s) Moved", { 1, 1, 1 })
  end

  if placeCount == 0 and moveCount == 0 then
    broadcastToAll("Bag is empty and no matching objects were found in play", { 1, 1, 1 })
  end
end

function buttonClick_recall()
  local count = 0
  for guid, _ in pairs(memoryList) do
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then
      self.putObject(obj)
      count = count + 1
    end
  end
  broadcastToAll(count .. " Object(s) Recalled", { 1, 1, 1 })
end

-- Utility functions
-- Duplicates a table (since Lua passes tables by reference)
function duplicateTable(oldTable)
  local newTable = {}
  for k, v in pairs(oldTable) do
    newTable[k] = v
  end
  return newTable
end

function removeAllHighlights()
  for _, obj in ipairs(getObjects()) do
    obj.highlightOff()
  end
end

function combineTables(t1, t2)
  for k, v in pairs(t2) do t1[k] = v end
end

-- Round vector to the Nth decimal
function roundVector(vec, dec)
  local mult = 10 ^ (dec or 0)
  local t = {}
  for _, k in ipairs({ "x", "y", "z" }) do
    t[k] = math.floor(vec[k] * mult + 0.5) / mult
  end
  return t
end
