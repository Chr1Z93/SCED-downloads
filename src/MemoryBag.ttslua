-- Utility memory bag
-- based on Version 2.5.2 by Directsun (fork of Memory Bag 2.0 by MrStump)

-- TODO:
-- use selected objects to add / remove items (via additional button)

function updateSave()
  self.script_state = JSON.encode({
    ml = memoryList,
    setupButton = setupButton
  })
end

function onLoad(savedData)
  fresh = true
  memoryList = {}
  moveList = {}

  if savedData ~= "" then
    local loadedData = JSON.decode(savedData)
    memoryList = loadedData.ml
    setupButton = loadedData.setupButton
  end

  self.addContextMenuItem("Toggle setup button", function()
    if setupButton then
      setupButton = false
      broadcastToAll("Setup button disabled", { 1, 1, 1 })
    else
      setupButton = true
      broadcastToAll("Setup button enabled", { 1, 1, 1 })
    end
    moveList = {}
    updateSave()
    self.clearButtons()
    removeAllHighlights()
    if fresh then
      createSetupButton()
    else
      createMemoryActionButtons()
    end
  end)

  -- make sure the model is loaded so that we can use the bounds
  Wait.condition(function()
    selfScale = self.getScale()
    selfBounds = self.getBoundsNormalized()
    buttonX = math.max(selfBounds.size.x / 5, 1.5) / selfScale.x
    buttonY = -(selfBounds.size.y / 2 + selfBounds.offset.y) / selfScale.y + 0.5
    buttonZ = (selfBounds.size.z / 2 + 1) / selfScale.z
    buttonZ2 = (selfBounds.size.z / 2 + 2.15) / selfScale.z
    buttonZ3 = (selfBounds.size.z / 2 + 3.3) / selfScale.z
    buttonScale = Vector( 1 / selfScale.x, 1, 1 / selfScale.z )

    if next(memoryList) == nil then
      createSetupButton()
    else
      fresh = false
      createMemoryActionButtons()
    end
  end, function() return not self.loading_custom end)
end

function combineMemoryFromBagsWithin()
  local bagObjList = self.getObjects()
  for _, bagObj in ipairs(bagObjList) do
    local data = bagObj.lua_script_state
    if data ~= nil then
      local j = JSON.decode(data)
      if j ~= nil and j.ml ~= nil then
        for guid, entry in pairs(j.ml) do
          memoryList[guid] = entry
        end
      end
    end
  end
end

function updateMemoryWithMoves()
  memoryList = memoryListBackup
  local obj = getObjectFromGUID(moveGuid)
  local deltaPos = findOffsetDistance(obj.getPosition(), Vector(memoryList[moveGuid].pos))
  for _, entry in pairs(memoryList) do
    entry.pos.x = entry.pos.x - deltaPos.x
    entry.pos.y = entry.pos.y - deltaPos.y
    entry.pos.z = entry.pos.z - deltaPos.z
  end
  moveList = {}
end

-- Beginning Setup
function createSetupButton()
  if setupButton ~= true then return end
  self.createButton({
    label = "Setup",
    click_function = "buttonClick_setup",
    function_owner = self,
    position = { x = 0, y = buttonY, z = -buttonZ },
    height = 500,
    width = 1200,
    font_size = 350,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  })
end

function buttonClick_transpose()
  moveGuid = nil
  broadcastToAll("Select one object and move it - all objects will move relative to the new location", { 0.75, 0.75, 1 })
  memoryListBackup = duplicateTable(memoryList)
  memoryList = {}
  moveList = {}
  self.clearButtons()
  createButtonsOnAllObjects(true)
  createSetupActionButtons(true)
end

function buttonClick_setup()
  memoryListBackup = duplicateTable(memoryList)
  memoryList = {}
  self.clearButtons()
  createButtonsOnAllObjects(false)
  createSetupActionButtons(false)
end

-- Creates selection buttons on objects
function createButtonsOnAllObjects(move)
  local color = { 0.75, 0.25, 0.25, 0.75 }
  local objsToHaveButtons = {}
  if move == true then
    color = { 0, 0, 1, 0.75 }
    for guid in pairs(memoryListBackup) do
      local curObj = getObjectFromGUID(guid)
      table.insert(objsToHaveButtons, curObj)
    end
  else
    objsToHaveButtons = getObjects()
  end

  local buttonCount = 0
  for _, obj in ipairs(objsToHaveButtons) do
    if obj ~= self and obj.type ~= "Scripting" and obj.type ~= "Hand" then
      local objBounds = obj.getBounds()
      local buttonPos = self.positionToLocal(obj.getPosition() + Vector(0, objBounds.size.y / 2 + 1, 0))
      buttonPos.x = -buttonPos.x

      local funcName = "selectButton_" .. buttonCount
      local func = function() buttonClick_selection(buttonCount, obj, move) end
      self.setVar(funcName, func)
      self.createButton({
        click_function = funcName,
        function_owner = self,
        position = buttonPos,
        height = 600,
        width = 600,
        color = color,
        scale = buttonScale
      })
      buttonCount = buttonCount + 1
    end
  end
end

-- Creates submit and cancel buttons
function createSetupActionButtons(move)
  local buttonParameters = {
    function_owner = self,
    height = 500,
    width = 1300,
    font_size = 335,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  }

  buttonParameters.label = "Cancel"
  buttonParameters.click_function = "buttonClick_cancel"
  buttonParameters.position = { x = -buttonX, y = buttonY, z = -buttonZ }
  self.createButton(buttonParameters)

  buttonParameters.label = "Submit"
  buttonParameters.click_function = "buttonClick_submit"
  buttonParameters.position = { x = -buttonX, y = buttonY, z = -buttonZ2 }
  self.createButton(buttonParameters)

  buttonParameters.label = "Reset"
  buttonParameters.click_function = "buttonClick_reset"
  buttonParameters.position = { x = -buttonX, y = buttonY, z = -buttonZ3 }
  self.createButton(buttonParameters)

  if move == false then
    buttonParameters.label = "Add"
    buttonParameters.click_function = "buttonClick_add"
    buttonParameters.position = { x = buttonX, y = buttonY, z = -buttonZ }
    buttonParameters.font_color = { 0.25, 1, 0.25 }
    self.createButton(buttonParameters)

    if fresh == false then
      buttonParameters.label = "Set New"
      buttonParameters.click_function = "buttonClick_setNew"
      buttonParameters.position = { x = buttonX, y = buttonY, z = -buttonZ3 }
      buttonParameters.font_color = { 0.75, 0.75, 1 }
      self.createButton(buttonParameters)

      buttonParameters.label = "Remove"
      buttonParameters.click_function = "buttonClick_remove"
      buttonParameters.position = { x = buttonX, y = buttonY, z = -buttonZ2 }
      buttonParameters.font_color = { 1, 0.25, 0.25 }
      self.createButton(buttonParameters)
    end
  end
end

-- During Setup
-- Checks or unchecks buttons
function buttonClick_selection(index, obj, move)
  local colorMove = { 0, 0, 1, 0.75 }
  local color = { 0, 1, 0, 0.75 }

  previousGuid = selectedGuid
  selectedGuid = obj.getGUID()

  theList = memoryList
  if move == true then
    if previousGuid ~= nil and previousGuid ~= selectedGuid then
      local prevObj = getObjectFromGUID(previousGuid)
      prevObj.highlightOff()
      self.editButton({ index = previousIndex, color = colorMove })
      theList[previousGuid] = nil
    end
    previousIndex = index
  end

  if theList[selectedGuid] == nil then
    theList[selectedGuid] = {
      pos = roundVector(obj.getPosition(), 3),
      rot = roundVector(obj.getRotation(), 0),
      lock = obj.getLock()
    }
    obj.highlightOn({ 0, 1, 0 })
  else
    color = { 0.75, 0.25, 0.25, 0.75 }
    if move == true then
      color = colorMove
    end
    theList[selectedGuid] = nil
    obj.highlightOff()
  end

  self.editButton({ index = index, color = color })
end

-- Cancels selection process
function buttonClick_cancel()
  memoryList = memoryListBackup
  moveList = {}
  if next(memoryList) == nil then
    self.clearButtons()
    createSetupButton()
  else
    createMemoryActionButtons()
  end
  removeAllHighlights()
  broadcastToAll("Selection Canceled", { 1, 1, 1 })
  moveGuid = nil
end

-- Saves selections
function buttonClick_submit()
  fresh = false
  if next(moveList) ~= nil then
    for guid in pairs(moveList) do
      moveGuid = guid
    end
    if memoryListBackup[moveGuid] == nil then
      broadcastToAll("Item selected for moving is not already in memory", { 1, 0.25, 0.25 })
    else
      broadcastToAll("Moving all items in memory relative to new objects position!", { 0.75, 0.75, 1 })
      createMemoryActionButtons()
      local count = 0
      for guid in pairs(moveList) do
        moveGuid = guid
        count = count + 1
        local obj = getObjectFromGUID(guid)
        if obj ~= nil then obj.highlightOff() end
      end
      updateMemoryWithMoves()
      updateSave()
      buttonClick_place()
    end
  elseif next(memoryList) == nil and moveGuid == nil then
    memoryList = memoryListBackup
    broadcastToAll("No selections made.", { 0.75, 0.25, 0.25 })
  end
  combineMemoryFromBagsWithin()
  createMemoryActionButtons()
  local count = 0
  for guid in pairs(memoryList) do
    count = count + 1
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then obj.highlightOff() end
  end
  broadcastToAll(count .. " Objects Saved", { 1, 1, 1 })
  updateSave()
  moveGuid = nil
end

function buttonClick_add()
  fresh = false
  combineTables(memoryList, memoryListBackup)
  broadcastToAll("Adding internal bags and selections to existing memory", { 0.25, 0.75, 0.25 })
  combineMemoryFromBagsWithin()
  createMemoryActionButtons()
  local count = 0
  for guid in pairs(memoryList) do
    count = count + 1
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then obj.highlightOff() end
  end
  broadcastToAll(count .. " Objects Saved", { 1, 1, 1 })
  updateSave()
end

function buttonClick_remove()
  broadcastToAll("Removing Selected Entries From Memory", { 1.0, 0.25, 0.25 })
  createMemoryActionButtons()
  local count = 0
  for guid in pairs(memoryList) do
    count = count + 1
    memoryListBackup[guid] = nil
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then obj.highlightOff() end
  end
  broadcastToAll(count .. " Objects Removed", { 1, 1, 1 })
  memoryList = memoryListBackup
  updateSave()
end

function buttonClick_setNew()
  broadcastToAll("Setting new position relative to items in memory", { 0.75, 0.75, 1 })
  createMemoryActionButtons()
  local count = 0
  for _, obj in ipairs(getObjects()) do
    if memoryListBackup[obj.guid] ~= nil then
      count = count + 1
      memoryListBackup[obj.guid].pos = obj.getPosition()
      memoryListBackup[obj.guid].rot = obj.getRotation()
      memoryListBackup[obj.guid].lock = obj.getLock()
    end
  end
  broadcastToAll(count .. " Objects Saved", { 1, 1, 1 })
  memoryList = memoryListBackup
  updateSave()
end

-- Resets bag to starting status
function buttonClick_reset()
  fresh = true
  memoryList = {}
  self.clearButtons()
  createSetupButton()
  removeAllHighlights()
  broadcastToAll("Tool Reset", { 1, 1, 1 })
  updateSave()
end

-- After Setup
-- Creates recall and place buttons
function createMemoryActionButtons()
  self.clearButtons()

  self.createButton({
    label = "Place",
    click_function = "buttonClick_place",
    function_owner = self,
    position = { x = buttonX, y = buttonY, z = buttonZ },
    height = 500,
    width = 1200,
    font_size = 350,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  })
  self.createButton({
    label = "Recall",
    click_function = "buttonClick_recall",
    function_owner = self,
    position = { x = -buttonX, y = buttonY, z = buttonZ },
    height = 500,
    width = 1200,
    font_size = 350,
    color = { 0, 0, 0 },
    font_color = { 1, 1, 1 },
    scale = buttonScale
  })
  createSetupButton()
end

-- Sends objects from bag/table to their saved position/rotation
function buttonClick_place()
  memoryListBackup = duplicateTable(memoryList)
  local data = self.getData()

  if not data.ContainedObjects then
    broadcastToAll("Bag is already empty", { 1, 1, 1 })
    return
  end

  -- get names of contained objects
  local guidToName = {}
  for _, bagObjData in ipairs(data.ContainedObjects or {}) do
    guidToName[bagObjData["GUID"]] = bagObjData["Nickname"]
  end

  local placeCount = 0
  local moveCount = 0
  for guid, entry in pairs(memoryList) do
    local obj = getObjectFromGUID(guid)
    if obj ~= nil and obj.getName() == guidToName[guid] then
      -- If obj is out on the table and has the same name, move it
      moveCount = moveCount + 1
      obj.setPositionSmooth(entry.pos)
      obj.setRotationSmooth(entry.rot)
      obj.setLock(entry.lock)
    elseif guidToName[guid] then
      -- If obj is inside of the bag
      placeCount = placeCount + 1
      local item = self.takeObject({
        guid = guid,
        position = entry.pos,
        rotation = entry.rot,
        smooth = false
      })
      item.setLock(entry.lock)

      -- update the memory list since we just placed an item that got a new GUID
      if obj ~= nil then
        memoryListBackup[item.getGUID()] = entry
        memoryListBackup[guid] = nil
      end
    end
  end
  memoryList = memoryListBackup

  if placeCount > 0 then
    broadcastToAll(placeCount .. " Object(s) Placed", { 1, 1, 1 })
  end

  if moveCount > 0 then
    broadcastToAll(moveCount .. " Object(s) Moved", { 1, 1, 1 })
  end
end

function buttonClick_recall()
  for guid, _ in pairs(memoryList) do
    local obj = getObjectFromGUID(guid)
    if obj ~= nil then self.putObject(obj) end
  end
  broadcastToAll("Objects Recalled", { 1, 1, 1 })
end

-- Utility functions
-- Find delta (difference) between 2 x/y/z coordinates
function findOffsetDistance(p1, p2, obj)
  local yOffset = 0
  if obj ~= nil then
    local bounds = obj.getBounds()
    yOffset = (bounds.size.y - bounds.offset.y)
  end
  local deltaPos = p2 - p1 - Vector(0, yOffset, 0)
  return deltaPos
end

-- Duplicates a table (since Lua passes tables by reference)
function duplicateTable(oldTable)
  local newTable = {}
  for k, v in pairs(oldTable) do
    newTable[k] = v
  end
  return newTable
end

function removeAllHighlights()
  for _, obj in ipairs(getObjects()) do
    obj.highlightOff()
  end
end

function combineTables(t1, t2)
  for k, v in pairs(t2) do t1[k] = v end
end

-- Round vector to the Nth decimal
function roundVector(vec, dec)
  local mult = 10 ^ (dec or 0)
  local t = {}
  for _, k in ipairs({"x", "y", "z"}) do
    t[k] = math.floor(vec[k] * mult + 0.5) / mult
  end
  return t
end
