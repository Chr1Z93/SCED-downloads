local deckLib           = require("util/DeckLib")
local guidReferenceApi  = require("core/GUIDReferenceApi")
local MythosAreaApi     = require("mythos/MythosAreaApi")
local playAreaApi       = require("playarea/PlayAreaApi")
local searchLib         = require("util/SearchLib")
local victoryDisplayApi = require("mythos/VictoryDisplayApi")

SET_ASIDE               = {
  position = Vector(-2.52, 2, 14.87),
  rotation = Vector(0, 270, 0)
}

RFG                     = {
  position = Vector(-6.01, 1.61, 14.90),
  rotation = Vector(0, 270, 0)
}

ROTATION                = Vector(0, 270, 180)
RIGHT                   = Vector(0, 0, -2.5)
LEFT                    = Vector(0, 0, 2.5)

CRAWLING_MIST           = "aa76f7"

LOCATIONS               = {
  -- Skai
  { name = "Ulthar",                         id = "", region = "Skai" },
  { name = "Skai River",                     id = "", region = "Skai" },
  { name = "Dylath-Leen",                    id = "", region = "Skai" },
  -- Oriab
  { name = "Baharna",                        id = "", region = "Oriab",           position = { -36.77, 1.6, 0 } },
  { name = "Mt. Ngranek",                    id = "", region = "Oriab",           position = { -43.37, 1.6, 0 } },
  { name = "Nameless Ruins",                 id = "", region = "Oriab",           position = { -43.37, 1.6, 7.57 } },
  -- Mnar
  { name = "Kadatheron",                     id = "", region = "Mnar",            position = { -30.22, 1.6, 7.57 } },
  { name = "Ruins of Ib",                    id = "", region = "Mnar",            position = { -36.77, 1.6, 15.19 } },
  { name = "Sarnath",                        id = "", region = "Mnar",            position = { -30.22, 1.6, 15.19 } },
  -- Forbidden Lands
  { name = "Ilek-Vad",                       id = "", region = "Forbidden Lands", position = { -17.12, 1.6, 0 } },
  { name = "Zulan-Thek",                     id = "", region = "Forbidden Lands", position = { -17.12, 1.6, 15.19 } },
  { name = "Forbidden Lands",                id = "", region = "Forbidden Lands", position = { -17.12, 1.6, 7.57 } },
  -- Timeless Realm
  { name = "Serannian",                      id = "", region = "Timeless Realm",  position = { -23.68, 1.6, -15.28 } },
  { name = "Celephaïs",                      id = "", region = "Timeless Realm",  position = { -30.22, 1.6, -15.28 } },
  { name = "Hazuth-Kleg",                    id = "", region = "Timeless Realm",  position = { -36.77, 1.64, -15.28 } },
  { name = "City-Which-Appears-On-No-Map",   id = "", region = "Timeless Realm", },
  { name = "Temple of Unattainable Desires", id = "", region = "Timeless Realm", }
}

local RFG_IDS           = {
  ["06151"] = true, -- "Pack of Vooniths"
  ["06145"] = true, -- "Cats of Ulthar"
  ["06109"] = true, -- "Zoog Burrow"
  ["06107"] = true, -- "Stealthy Zoog"
  ["06106"] = true, -- "Furtive Zoog"
  ["06108"] = true  -- "Inconspicuous Zoog"
}

local act1WasAdvanced   = false
local visited           = {}

local buttonParameters  = {
  function_owner = self,
  height         = 1000,
  width          = 2100,
  scale          = { x = 0.5, y = 0.5, z = 0.5 },
  font_size      = 375
}

function updateSave()
  self.script_state = JSON.encode({ act1WasAdvanced = act1WasAdvanced, visited = visited })
end

function onLoad(saveData)
  if saveData and saveData ~= "" then
    local loadedData = JSON.decode(saveData)
    act1WasAdvanced  = loadedData.act1WasAdvanced or false
    visited          = loadedData.visited or {}
  end

  self.addContextMenuItem("Reset state",
    function()
      visited = {}
      buttonCreation()
      updateSave()
    end
  )

  buttonCreation()

  -- delay to allow mythos area and chest to spawn
  Wait.time(function()
    chest = MythosAreaApi.getSetAsideChest()
    ENCOUNTER_DECK_POS = MythosAreaApi.getEncounterDeckPosition()
    ENCOUNTER_DECK_DISCARD_POSITION = MythosAreaApi.getEncounterDiscardPosition()
    makeIndexes()
  end, 1)
end

function buttonCreation()
  self.clearButtons()

  for i, region in ipairs({ "Oriab", "Mnar", "Forbidden Lands", "Timeless Realm" }) do
    local funcName                  = "setup_" .. string.lower(region):gsub(" ", "_")
    _G[funcName]                    = function() maybeSetup(region) end
    buttonParameters.click_function = funcName
    buttonParameters.label          = region:gsub(" ", "\n")
    buttonParameters.position       = Vector(0, 0.1, -3 + 1.2 * i)
    buttonParameters.color          = visited[region] and { r = 0.5, g = 0.5, b = 0.5 } or { r = 1, g = 1, b = 1 }
    self.createButton(buttonParameters)
  end
end

function makeIndexes()
  nameMap = {}
  for i, loc in ipairs(LOCATIONS) do
    if (loc.name == "City-Which-Appears-On-No-Map" or loc.name == "Temple of Unattainable Desires") then
      loc.position = chest.getPosition() + Vector(0, i - 10, 0)
    end
    nameMap[loc.name] = loc
  end
end

function maybeSetup(region)
  if visited[region] then
    broadcastToAll(region .. " was already visited.")
  else
    visited[region] = true
    buttonCreation()
    updateSave()
    setup(region)
  end
end

function setup(region)
  -- remove clues from players
  local masterClueCounter = guidReferenceApi.getObjectByOwnerAndType("Mythos", "MasterClueCounter")
  if masterClueCounter ~= nil then
    masterClueCounter.call("removeAllPlayerClues")
  end

  -- spawn locationDeck if not yet done
  if locationDeck == nil then
    locationDeck = chest.takeObject({
      guid     = "c5ed15", -- locations
      smooth   = false,
      position = SET_ASIDE.position,
      rotation = SET_ASIDE.rotation
    })
  end

  if region == "Timeless Realm" then
    local card = chest.takeObject({ guid = CRAWLING_MIST })
    deckLib.placeOrMergeIntoDeck(card, ENCOUNTER_DECK_POS, ROTATION)
  end

  Wait.time(function() MythosAreaApi.reshuffleEncounterDeck(true) end, 0.1)
  Wait.time(cleanZone, 1)
  Wait.time(function() placeLocations(region) end, 2)
  Wait.time(shuffleDeck, 2)
end

function shuffleDeck()
  local encounterDeckObjects = MythosAreaApi.getEncounterDeckObjects()

  if encounterDeckObjects.draw and encounterDeckObjects.topCard then
    encounterDeckObjects.draw.putObject(encounterDeckObjects.topCard)
    encounterDeckObjects.draw.shuffle()
    MythosAreaApi.flipTopCardFromDeck(1)
  elseif encounterDeckObjects.draw then
    encounterDeckObjects.draw.shuffle()
  end
end

function cleanZone()
  -- clean the encounter deck
  if not act1WasAdvanced then
    local encounterDeckObjects = MythosAreaApi.getEncounterDeckObjects()
    if encounterDeckObjects.draw and encounterDeckObjects.topCard then
      encounterDeckObjects.draw.putObject(encounterDeckObjects.topCard)
    end

    local cardsToRemove = {}
    for i, card in ipairs(encounterDeckObjects.draw.getObjects()) do
      local md = getMetadata(card)
      if md.id and RFG_IDS[md.id] then
        table.insert(cardsToRemove, card.index)
      end
    end

    for i = #cardsToRemove, 1, -1 do
      encounterDeckObjects.draw.takeObject({
        position = RFG.position,
        rotation = RFG.rotation,
        smooth   = false,
        index    = cardsToRemove[i]
      })
    end
  end

  -- clean the play area
  local zone = guidReferenceApi.getObjectByOwnerAndType("Mythos", "PlayAreaZone")
  for i, obj in ipairs(zone.getObjects()) do
    -- remove certain cards from game
    if not act1WasAdvanced then
      if obj.type == "Card" then
        local md = getMetadata(obj)
        if md.id and RFG_IDS[md.id] then
          obj.setRotation(RFG.rotation)
          obj.setPosition(RFG.position)
          goto continue
        end
      elseif obj.type == "Deck" then
        local cardsToRemove = {}
        for _, card in ipairs(obj.getObjects()) do
          local md = getMetadata(obj)
          if md.id and RFG_IDS[md.id] then
            table.insert(cardsToRemove, card.index)
          end
        end

        for i = #cardsToRemove, 1, -1 do
          obj.takeObject({
            position = RFG.position,
            rotation = RFG.rotation,
            smooth   = false,
            index    = cardsToRemove[i]
          })
        end
        goto continue
      end
    end

    -- move enemies and treacheries to the encounter deck
    if obj.type == "Card" and obj.hasTag("ScenarioCard") and not obj.hasTag("Location") then
      deckLib.placeOrMergeIntoDeck(obj, ENCOUNTER_DECK_POS, ROTATION)
    end

    -- move locations to victory display or set aside
    if obj.type == "Card" then
      local md = getMetadata(obj)
      if md.locationFront and md.locationFront.victory and not obj.is_face_down and not cardHasClues(obj) then
        playAreaApi.maybeUntrackLocation(obj)
        victoryDisplayApi.placeCard(obj)
      else
        obj.setPosition(SET_ASIDE.position + Vector(0, 1, 0))
      end
    end

    -- delete clues and doom tokens
    if obj.memo == "clueDoom" then
      obj.destruct()
    end

    ::continue::
  end

  if not act1WasAdvanced then -- add in copies of Priest of A Thousand Masks
    local card = chest.takeObject({ guid = "678204" })
    deckLib.placeOrMergeIntoDeck(card, ENCOUNTER_DECK_POS, ROTATION, nil, true)
  end

  act1WasAdvanced = true
  updateSave()
end

function placeLocations(region)
  -- take locations from locationDeck if region matches
  for i, loc in ipairs(LOCATIONS) do
    if loc.region == region then
      for j, card in ipairs(locationDeck.getObjects()) do
        if loc.name == card.name then
          locationDeck.takeObject({
            position = loc.position,
            smooth   = false,
            index    = card.index
          })
          break
        end
      end
    end
  end

  local numPlayers = playAreaApi.getInvestigatorCount()

  if lastRegion == "Timeless Realm" then
    placeEnemyFromEncounterDeck("06086", "The Crawling Mist", RFG.position, Vector({ 0, 1, 0 }))
  end

  if region == "Oriab" then
    placeEnemyFromEncounterDeck("06152", "Nightriders", nameMap["Mt. Ngranek"].position, RIGHT)
    if numPlayers >= 3 then
      placeEnemyFromEncounterDeck("06152", "Nightriders", nameMap["Nameless Ruins"].position, LEFT)
    end
    broadcastToAll("Place each investigator at Baharna. Add swarm cards to enemies.")
  elseif region == "Mnar" then
    placeEnemyFromContainer("06148", "Beings of Ib", chest, nameMap["Ruins of Ib"].position, RIGHT)
    broadcastToAll("Place each investigator at Kadatheron. Add swarm cards to enemies.")
  elseif region == "Forbidden Lands" then
    placeEnemyFromContainer("06146", "Stalking Manticore", chest, nameMap["Forbidden Lands"].position, RIGHT)
    placeEnemyFromContainer("06147", "Horde of Night", chest, nameMap["Zulan-Thek"].position, RIGHT)
    broadcastToAll("Place each investigator at Ilek-Vad. Add swarm cards to enemies.")
  elseif region == "Timeless Realm" then
    placeEnemyFromEncounterDeck("06149", "Priest of a Thousand Masks", nameMap["Hazuth-Kleg"].position, LEFT)
    if numPlayers >= 3 then
      placeEnemyFromEncounterDeck("06149", "Priest of a Thousand Masks", nameMap["Celephaïs"].position, LEFT)
    end
    broadcastToAll("Place each investigator at Celephaïs.")
  end

  lastRegion = region
end

function placeEnemyFromEncounterDeck(id, name, position, side)
  local encounterDeckObjects = MythosAreaApi.getEncounterDeckObjects()

  if encounterDeckObjects.topCard then
    local md = getMetadata(encounterDeckObjects.topCard)
    if md.id and md.id == id then
      encounterDeckObjects.topCard.setPosition(Vector(position) + side)
      encounterDeckObjects.topCard.setRotation({ 0, 270, 0 })
      MythosAreaApi.flipTopCardFromDeck()
      return
    end
  end

  if encounterDeckObjects.draw then
    for i, card in ipairs(encounterDeckObjects.draw.getObjects()) do
      local md = getMetadata(card.gm_notes)
      if md.id and md.id == id then
        encounterDeckObjects.draw.takeObject({
          index    = card.index,
          position = Vector(position) + side,
          rotation = { 0, 270, 0 },
          smooth   = false
        })
        return
      end
    end
  end

  broadcastToAll("Couldn't find " .. name, "Orange")
end

function placeEnemyFromContainer(id, name, container, position, side)
  for i, card in ipairs(container.getObjects()) do
    local md = getMetadata(card)
    if md.id and md.id == id then
      container.takeObject({
        index    = card.index,
        position = Vector(position) + side,
        rotation = { 0, 270, 0 },
        smooth   = false
      })
      return
    end
  end
  broadcastToAll("Couldn't find " .. name, "Orange")
end

-- Checks if a card has clues on it
---@param card tts__Object Card to check for clues
---@return boolean hasClues True if card has clues on it
function cardHasClues(card)
  local searchResult = searchLib.onObject(card, "isClue")
  return #searchResult > 0
end

function getMetadata(objectOrNotes)
  if objectOrNotes == nil then return {} end

  local notes
  if type(objectOrNotes) == "string" then
    notes = objectOrNotes
  elseif type(objectOrNotes) == "table" then
    notes = objectOrNotes["GMNotes"] or objectOrNotes["gm_notes"]
  else
    notes = objectOrNotes.getGMNotes()
  end

  return JSON.decode(notes or "") or {}
end
