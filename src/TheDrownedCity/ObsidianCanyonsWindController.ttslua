local CoroutineLib                         = require("util/CoroutineLib")
local DeckLib                              = require("util/DeckLib")
local GUIDReferenceApi                     = require("core/GUIDReferenceApi")
local LocationLib                          = require("LocationLib")
local PlayAreaApi                          = require("playarea/PlayAreaApi")
local SearchLib                            = require("util/SearchLib")
local VictoryDisplayApi                    = require("mythos/VictoryDisplayApi")

-- Non movable locations IDs
local CENTRAL_SPIRE_ID                     = "11649"
local FLOATING_SPIRE_ID                    = "11650"
local RLYEH_STREETS_ID                     = "11648"
local WESTERN_WALL_ID                      = "11651"

-- Deck names
local SUMMIT_DECK_NAME                     = "Summit Deck"
-- Other
local LIGHT_BLUE                           = { r = 0.7, g = 0.8, b = 1 }
local LIGHT_GREEN                          = { r = 0.7, g = 1, b = 0.6 }
local VERTICAL_ROTATION                    = { x = 0, y = 270, z = 180 }
local BUTTON_HEIGHT = 250
local BUTTON_WIDTH = 720
local SCALE                                = { x = 2, y = 2, z = 2 }

-----------
-- Act 1
-----------

local ACT1_RIGHTMOST_POSITIONS             = {
  { x = 2, y = 0 }
}
local ACT1_LEFTMOST_POSITIONS              = {
  { x = -1, y = 1 },
  { x = 0,  y = -1 },
}

local ACT1_NotRIGHTMOST_POSITIONS          = { -- this has to be sorted
  { x = 1,  y = 0 },
  { x = 0,  y = 0 },
  { x = -1, y = 0 }
}

local ACT1_NotLEFTMOST_POSITIONS_BOTTOMROW = { -- this has to be sorted
  { x = 1, y = -1 },
  { x = 2, y = -1 },
}

local ACT1_NotLEFTMOST_POSITIONS_TOPROW    = { -- this has to be sorted
  { x = 0, y = 1 },
  { x = 1, y = 1 },
  { x = 2, y = 1 },
}

local ACT1_POSSIBLE_EMPTY_SPACES_RIGHT     = {
  { x = 2, y = 1 },
  { x = 2, y = -1 },
}

local ACT1_POSSIBLE_EMPTY_SPACES_LEFT      = {
  { x = -1, y = 0 }
}

-----------
-- Act 2
-----------
local ACT2_RIGHTMOST_POSITIONS             = ACT1_RIGHTMOST_POSITIONS

local ACT2_LEFTMOST_POSITIONS              = {
  { x = -2, y = 1 },
  { x = -2, y = -1 },
}

local ACT2_NotRIGHTMOST_POSITIONS          = { -- this has to be sorted
  { x = 1,  y = 0 },
  { x = 0,  y = 0 },
  { x = -1, y = 0 }
}

local ACT2_NotLEFTMOST_POSITIONS_BOTTOMROW = { -- this has to be sorted
  { x = -1, y = -1 },
  { x = 0,  y = -1 },
  { x = 1,  y = -1 },
  { x = 2,  y = -1 },
}

local ACT2_NotLEFTMOST_POSITIONS_TOPROW    = { -- this has to be sorted
  { x = -1, y = 1 },
  { x = 0,  y = 1 },
  { x = 1,  y = 1 },
  { x = 2,  y = 1 },
}

local ACT2_POSSIBLE_EMPTY_SPACES_RIGHT     = ACT1_POSSIBLE_EMPTY_SPACES_RIGHT

local ACT2_POSSIBLE_EMPTY_SPACES_LEFT      = {
  { x = -1, y = 0 }
}

-----------
-- Act 3
-----------

local ACT3_RIGHTMOST_POSITIONS             = {
  { x = 2, y = 0 },
  { x = 2, y = -2 }
}

local ACT3_LEFTMOST_POSITIONS              = {
  { x = -1, y = 1 },
  { x = -2, y = -1 },
}

ACT3_NotRIGHTMOST_POSITIONS_BOTTOMROW      = {
  { x = 1,  y = -2 },
  { x = 0,  y = -2 },
  { x = -1, y = -2 },
  { x = -2, y = -2 }
}

ACT3_NotRIGHTMOST_POSITIONS_TOPROW         = {
  { x = 1,  y = 0 },
  { x = 0,  y = 0 },
  { x = -1, y = 0 },
  { x = -2, y = 0 }
}

ACT3_NotLEFTMOST_POSITIONS_BOTTOMROW       = {
  { x = -1, y = -1 },
  { x = 0,  y = -1 },
  { x = 1,  y = -1 },
  { x = 2,  y = -1 },
}

ACT3_NotLEFTMOST_POSITIONS_TOPROW          = {
  { x = 0, y = 1 },
  { x = 1, y = 1 },
  { x = 2, y = 1 },
}

local ACT3_POSSIBLE_EMPTY_SPACES_RIGHT     = ACT1_POSSIBLE_EMPTY_SPACES_RIGHT

local ACT3_POSSIBLE_EMPTY_SPACES_LEFT      = {
  { x = -2, y = 0 },
  { x = -2, y = -2 }
}

-- ░█████╗░░█████╗░██████╗░███████╗
-- ██╔══██╗██╔══██╗██╔══██╗██╔════╝
-- ██║░░╚═╝██║░░██║██║░░██║█████╗░░
-- ██║░░██╗██║░░██║██║░░██║██╔══╝░░
-- ╚█████╔╝╚█████╔╝██████╔╝███████╗
-- ░╚════╝░░╚════╝░╚═════╝░╚══════╝

function onSave()
  return JSON.encode({
    currentAct = currentAct,
    expeditionDirection = expeditionDirection,
    windDirection = windDirection
  })
end

function loadFromSaveTable(savedData)
  for var, val in pairs(JSON.decode(savedData)) do
    _G[var] = val
  end
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    loadFromSaveTable(savedData)
  else
    currentAct = 0
    expeditionDirection = nil
    windDirection = nil
  end

  self.createButton({
    label          = "←Eastern\nWinds blow←",
    click_function = "easternWindsBlow",
    function_owner = self,
    position       = { 0, 0.0, -3.5 },
    rotation       = { 0, 0, 180 },
    height         = BUTTON_HEIGHT,
    width          = BUTTON_WIDTH,
    scale          = SCALE
  })

  self.createButton({
    label          = "→Western\nWinds blow→",
    click_function = "westernWindsBlow",
    function_owner = self,
    position       = { 0, 0, -2.3 },
    height         = BUTTON_HEIGHT,
    width          = BUTTON_WIDTH,
    scale          = SCALE
  })
end

-- Clicked functions

function westernWindsBlow(_, color)
  windDirection = 'western'
  genericWindsBlow()
end

function easternWindsBlow(_, color)
  windDirection = 'eastern'
  genericWindsBlow()
end

-- Update information

function updateToAct1()
  currentAct = 1
end

function updateToAct2()
  currentAct = 2
end

function updateToAct3()
  currentAct = 3
end

-- Complex functions

function genericWindsBlow()
  if windDirection ~= 'western' and windDirection ~= 'eastern' then
    error("genericWindsBlow::ValueError", 2)
    return
  end

  function coroutineGenericWindsBlow()
    -- Verification of integrity
    if currentAct == 0 then
      printToAll('Please, click setup before.')
      return
    end

    local summitDeck = getObjectByName(SUMMIT_DECK_NAME)
    local aboveSummitDeck = nil
    if not summitDeck then
      printToAll('We assume the Summit deck is on the topleft corner.')
      aboveSummitDeck = PlayAreaApi.gridToWorld({ x = -2, y = 2 }) + Vector(0, 0.7, 0)
    else
      aboveSummitDeck = summitDeck.getPosition() + Vector(0, 0.7, 0)
    end

    -- Start of the program
    if windDirection == 'western' then
      printToAll('Western Winds blow strongly.', LIGHT_BLUE)
    elseif windDirection == 'eastern' then
      printToAll('Eastern Winds blow strongly.', LIGHT_GREEN)
    end

    -- Choose coordinates to remove.
    local coordinatesToRemove = {}
    local rowNumbers = {}
    local isFrozen = {}
    local coordinatesToFill = {}

    if currentAct == 1 and windDirection == 'western' then
      coordinatesToRemove = ACT1_RIGHTMOST_POSITIONS
      rowNumbers = { 2 }
      isFrozen = { false }
      coordinatesToFill = ACT1_POSSIBLE_EMPTY_SPACES_LEFT
    elseif currentAct == 1 and windDirection == 'eastern' then
      coordinatesToRemove = ACT1_LEFTMOST_POSITIONS
      rowNumbers = { 1, 3 }
      isFrozen = { false, false }
      coordinatesToFill = ACT1_POSSIBLE_EMPTY_SPACES_RIGHT
    elseif currentAct == 2 and windDirection == 'western' then
      coordinatesToRemove = ACT2_RIGHTMOST_POSITIONS
      rowNumbers = { 2 }
      isFrozen = { false }
      coordinatesToFill = ACT2_POSSIBLE_EMPTY_SPACES_LEFT
    elseif currentAct == 2 and windDirection == 'eastern' then
      coordinatesToRemove = ACT2_LEFTMOST_POSITIONS
      rowNumbers = { 1, 3 }
      isFrozen = { false, false }
      coordinatesToFill = ACT2_POSSIBLE_EMPTY_SPACES_RIGHT
    elseif currentAct == 3 and windDirection == 'western' then
      coordinatesToRemove = ACT3_RIGHTMOST_POSITIONS
      rowNumbers = { 2, 4 }
      isFrozen = { false, false }
      coordinatesToFill = ACT3_POSSIBLE_EMPTY_SPACES_LEFT
    elseif currentAct == 3 and windDirection == 'eastern' then
      coordinatesToRemove = ACT3_LEFTMOST_POSITIONS
      rowNumbers = { 1, 3 }
      isFrozen = { false, false }
      coordinatesToFill = ACT3_POSSIBLE_EMPTY_SPACES_RIGHT
    end

    -- Step 2. Find if any of the to-move locations freezes the row
    local locationsToRemove = {}
    local params = canRemoveLocationsToSummitDeck(coordinatesToRemove, isFrozen)
    isFrozen = params.isFrozen
    locationsToRemove = params.locationsToRemove

    -- Shuffle the Xmost opensky or summit location in rows X and Y and place them on top
    -- of the summit deck, or place them into the victory
    -- Shuffle the cards you remove
    locationsToRemove = randomizeTwo(locationsToRemove)
    placeOnDeckOrVpDisplaySafelyCoroutine(locationsToRemove, aboveSummitDeck)

    -- Show message for user
    if #locationsToRemove == 2 then
      printToAll('Two locations were placed on top of the summit deck. Don\'t shuffle it.')
    elseif #locationsToRemove == 1 then
      printToAll('One location was placed on top of the summit deck. Don\'t shuffle it.')
    elseif #locationsToRemove == 0 then
      printToAll('No location was placed on top of the summit deck. Don\'t shuffle it.', 'Red')
    end

    -- Step 2. Choose what coordinates to move.
    -- Depending on the act and the windDirection, we will move some coordinates or others
    CoroutineLib.yieldSeconds(0.1)
    if windDirection == 'western' and currentAct == 1 then
      someRows = { ACT1_NotRIGHTMOST_POSITIONS }
    elseif windDirection == 'eastern' and currentAct == 1 then
      someRows = { ACT1_NotLEFTMOST_POSITIONS_TOPROW, ACT1_NotLEFTMOST_POSITIONS_BOTTOMROW }
    elseif windDirection == 'western' and currentAct == 2 then
      someRows = { ACT2_NotRIGHTMOST_POSITIONS }
    elseif windDirection == 'eastern' and currentAct == 2 then
      someRows = { ACT2_NotLEFTMOST_POSITIONS_TOPROW, ACT2_NotLEFTMOST_POSITIONS_BOTTOMROW }
    elseif windDirection == 'western' and currentAct == 3 then
      someRows = { ACT3_NotRIGHTMOST_POSITIONS_TOPROW, ACT3_NotRIGHTMOST_POSITIONS_BOTTOMROW }
    elseif windDirection == 'eastern' and currentAct == 3 then
      someRows = { ACT2_NotLEFTMOST_POSITIONS_TOPROW, ACT2_NotLEFTMOST_POSITIONS_BOTTOMROW }
    end

    -- Step 2.1 We have to find if any row is frozen because of the presence of a not movable object
    -- Double for loop, we run row by row, then right to left
    for i = 1, #coordinatesToRemove do
      if not isFrozen[i] then
        for _, coordinates in ipairs(someRows[i]) do
          found = LocationLib.getObjectsAt(coordinates)
          -- Studying a determinate coordinate
          for _, obj in ipairs(found) do
            if isLocationOrOpenSkies(obj) and cannotBeMovedLocation(obj) then
              isFrozen[i] = true
            end
          end
        end
      end
    end

    -- Winds::Slide each open sky and Summit location in rows X and Y once to the direction
    moveCardsSafely(someRows, isFrozen, rowNumbers)


    -- Place the bottom card of the summit Deck in each gap canRemoveLocationsToSummitDeck
    for i = 1, #someRows do
      if isFrozen[i] == true then
      elseif isFrozen[i] == false then
        --place card in the space
        local pos1 = PlayAreaApi.gridToWorld(coordinatesToFill[i])
        takeFromBottom(summitDeck, { position = pos1 })
        CoroutineLib.yieldSeconds(0.5)
      end
    end

    -- Winds:: Flip this card
    if windDirection == 'western' then
      newDirection = 'eastern'
    else
      newDirection = 'eastern'
    end

    placeWindCardAccordingly()
  end

  CoroutineLib.start(coroutineGenericWindsBlow)
end

-- HELPER, LOCATION IDENTIFICATION

function isLocationOrOpenSkies(obj)
  local rawNotes = obj.getGMNotes() or "{}"
  local md = JSON.decode(rawNotes) or {}
  local type = md['type'] or ''
  if type == 'Location' or obj.getName() == 'Open Sky' then
    return true
  end
end

function isVisibleVPlocation(obj)
  -- In this algorithm, if a VP card is visible it might not be removedTokens
  -- We need this lojic
  local rawNotes = obj.getGMNotes() or "{}"
  local md = JSON.decode(rawNotes) or {}
  local type = md['type'] or ''
  if type ~= 'Location' then
    return false
  end
  local lf = md['locationFront']
  local victory = lf['victory'] or nil

  if obj.is_face_down then
    return false
  elseif victory == nil then
    return false
  elseif victory then
    return true
  end
  return false
end

function cannotBeMovedLocation(obj)
  if obj.is_face_down then
    return false     -- can be moved
  end
  if getId(obj) == RLYEH_STREETS_ID then
    return true
  elseif getId(obj) == CENTRAL_SPIRE_ID then
    return true
  elseif getId(obj) == FLOATING_SPIRE_ID then
    return true
  elseif getId(obj) == WESTERN_WALL_ID then
    return true
  end
  return false
end

-- HELPER MOVER

function moveCardsSafely(someRows, isFrozen, rowNumbers)
  -- someRows is a table of tables

  if #isFrozen ~= #someRows or #isFrozen ~= #rowNumbers or #someRows ~= #rowNumbers then
    error("moveCardsSafely::incorrect call", 2)
  end

  -- Consult object variable
  if windDirection == 'western' then
    directionToMove = 'east'
  elseif windDirection == 'eastern' then
    directionToMove = 'west'
  end

  function moveOneRow()
    assert(type(oneRow) == 'table', 'Error value 1')
    assert(type(frozen) == 'boolean', 'Error value 2')
    assert(type(rowNumber) == 'number', 'Error value 3')
    if frozen == false then
      printToAll('Moving row number ' .. tostring(rowNumber))
      for _, coordinates in ipairs(oneRow) do
        found = LocationLib.getObjectsAt(coordinates)         -- The pair of coordinates is well defined
        for _, obj in ipairs(found) do
          if isLocationOrOpenSkies(obj) and not cannotBeMovedLocation(obj) then
            obj.highlightOn('Orange', 0.15)
            LocationLib.moveCardInDirection(obj, directionToMove)
            CoroutineLib.yieldSeconds(1.1)
          end
        end
      end
    elseif frozen == true then
      printToAll('We dont move the row number ' .. tostring(rowNumber) .. ', because there is a "locked" location.')
      printToAll('Please, move row card manually.')
    end
  end

  for i = 1, #someRows do
    oneRow = someRows[i]
    frozen = isFrozen[i]
    rowNumber = rowNumbers[i]
    moveOneRow()
    CoroutineLib.yieldSeconds(0.1)
  end
end

function placeWindCardAccordingly()

  if windDirection == 'eastern' then
    makeSureIsFaceUp(self)
    printToAll('→→ Western winds will blow →→.')
  elseif windDirection == 'western' then
    makeSureIsFaceDown(self)
    printToAll('←← Eastern winds will blow ←←.')
  else
    error('placeWindCardAccordingly:: wind direction has a wrong value', 2)
  end
end

function canRemoveLocationsToSummitDeck(coordinatesToRemove, isFrozen)
  -- This answers the question Which locations are going to be removed and
  -- what rows are frozen

  if #coordinatesToRemove ~= #isFrozen then
    error('canRemoveLocationsToSummitDeck::Implementation error in the relation toRemove-isFrozen.', 2)
    return
  end

  local locationsToRemove = {}

  for i = 1, #coordinatesToRemove do
    local found = LocationLib.getObjectsAt(coordinatesToRemove[i])
    for _, obj in ipairs(found) do
      if isVisibleVPlocation(obj) then
        table.insert(locationsToRemove, obj)
      elseif isLocationOrOpenSkies(obj) and not cannotBeMovedLocation(obj) then
        table.insert(locationsToRemove, obj)
      elseif isLocationOrOpenSkies(obj) and cannotBeMovedLocation(obj) then
        isFrozen[i] = true
      end
    end
  end

  return { locationsToRemove = locationsToRemove, isFrozen = isFrozen }
end

function placeOnDeckOrVpDisplaySafelyCoroutine(locations, deckLocation)
  -- Places Location cards on a deck-position slowly
  -- Or in the VP, if they have VP and no clues
  for j = 1, #locations do
    local location = locations[j]
    assert(location.tag == 'Card', 'For safety, this function should take as argument only a table of locations.')
    if isVisibleVPlocation(location) and not cardHasClues(location) then
      location.highlightOn('Green', 4)
      VictoryDisplayApi.placeCard(location)
      makeSureIsFaceUp(location)
      CoroutineLib.yieldSeconds(0.05)
    else
      location.highlightOn({ r = 1, g = 1, b = 0 }, 0.1)
      cleanLocation(location)
      CoroutineLib.yieldSeconds(0.05)
      makeSureIsFaceDown(location)
      CoroutineLib.yieldSeconds(0.05)
      DeckLib.placeOrMergeIntoDeck(location, deckLocation, VERTICAL_ROTATION, false, false, true)
      CoroutineLib.yieldSeconds(0.05)
    end
  end
end

-- Location helpers

function makeSureIsFaceUp(card)
  if card.is_face_down then
    card.flip()
  end
end

function makeSureIsFaceDown(card)
  if not card.is_face_down then
    card.flip()
  end
end

function randomizeTwo(pairOrNot)
  if #pairOrNot == 0 then
    return pairOrNot
  end
  if #pairOrNot == 1 then
    return pairOrNot
  end

  assert(#pairOrNot == 2, "Implementation error.")

  if math.random(2) == 1 then
    return { pairOrNot[1], pairOrNot[2] }
  else
    return { pairOrNot[2], pairOrNot[1] }
  end
end

function takeFromBottom(deck, params)
  if deck.tag ~= "Deck" then return end

  local objects = deck.getObjects()
  if #objects == 0 then return end

  local bottomIndex = #objects
  local bottomCardGUID = objects[bottomIndex].guid


  params['guid'] = bottomCardGUID

  deck.takeObject(params)
end

-- Checks if a card has clues on it
---@param card tts__Object Card to check for clues
---@return boolean hasClues True if card has clues on it
function cardHasClues(card)
  local searchResult = SearchLib.onObject(card, "isClue")
  return #searchResult > 0
end

---@param location tts__Object Card to check for tokens
function cleanLocation(location)
  local trash = GUIDReferenceApi.getObjectByOwnerAndType("Mythos", "Trash")
  for _, obj in ipairs(SearchLib.onObject(location, "isTileOrToken")) do
    if obj.memo and not obj.getLock() and obj.interactable then
      trash.putObject(obj)
    end
  end
end

------------------
-- Generic getters
------------------

---@param name string
---@return tts__Object|nil
function getObjectByName(name)
  for _, obj in ipairs(getObjects()) do
    if obj.getName() == name then
      return obj
    end
  end
end

---@param id string|number
---@return tts__Object|nil
function getObjectById(id)
  local objects = getAllObjects()
  for _, obj in ipairs(objects) do
    local md = JSON.decode(obj.getGMNotes() or "{}")
    if md then
      local id2 = md['id']
      if id2 == id then
        return obj
      end
    end
    -- continue
  end
  return nil
end

---@param obj tts__Object
---@return string|nil
function getId(obj)
  local md = JSON.decode(obj.getGMNotes() or "{}")
  local id = md['id'] or nil
  return id
end

------------------
--- Math operations
------------------

---@param listA table
---@param listB table
---@return table
function exclude_pairs(listA, listB)
  -- This function performs the exclusion operation on a set
  -- And that set is made of pairs x,y

  local function same_pos(a, b)
    return a.x == b.x and a.y == b.y
  end

  local result = {}

  for _, a in ipairs(listA) do
    local found = false
    for _, b in ipairs(listB) do
      if same_pos(a, b) then
        found = true
        break
      end
    end
    if not found then
      table.insert(result, a)
    end
  end

  return result
end
